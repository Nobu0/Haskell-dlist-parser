Build profile: -w ghc-9.6.7 -O1
In order, the following will be built (use -v for more details):
 - dlist-parser-0.1.0.0 (exe:dlist-parser) (file src\Expr\PatternParser.hs changed)
Preprocessing executable 'dlist-parser' for dlist-parser-0.1.0.0...
Building executable 'dlist-parser' for dlist-parser-0.1.0.0...
[ 7 of 10] Compiling Expr.PatternParser ( src\Expr\PatternParser.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\dlist-parser\build\dlist-parser\dlist-parser-tmp\Expr\PatternParser.o ) [Source file changed]
[ 8 of 10] Compiling Expr.ExprParser  ( src\Expr\ExprParser.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\dlist-parser\build\dlist-parser\dlist-parser-tmp\Expr\ExprParser.o ) [Expr.PatternParser changed]
[11 of 11] Linking C:\\Users\\blue3\\haskell\\dlist-parser\\dist-newstyle\\build\\x86_64-windows\\ghc-9.6.7\\dlist-parser-0.1.0.0\\x\\dlist-parser\\build\\dlist-parser\\dlist-parser.exe [Objects changed]
=== Running Parser Test Suite ===

-- Simple let-return --
-- Input: do { let x = 1; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- Multiple lets --
-- Input: do { let x = 1; let y = 2; return (x + y) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "let",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator "+",TokIdent "y",TokSymbol ")",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- If in do --
-- Input: do { let x = 10; if x > 5 then return x else return 0 }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 10,TokSymbol ";",TokKeyword "if",TokIdent "x",TokOperator ">",TokNumber 5,TokKeyword "then",TokKeyword "return",TokIdent "x",TokKeyword "else",TokKeyword "return",TokNumber 0,TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- Nested do --
-- Input: do { let x = 1; do { let y = x + 1; return y } }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- Do in if --
-- Input: if cond then do { let x = 1; return x } else return 0
Tokens: [TokKeyword "if",TokIdent "cond",TokKeyword "then",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}",TokKeyword "else",TokKeyword "return",TokNumber 0]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "if"
<< keyword: if
<< atomBase next token: TokIdent "cond"
<< atomBase next token: TokKeyword "then"
<< keyword: then
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< keyword: if
<< atomBase next token: TokIdent "cond"
<< atomBase next token: TokKeyword "then"
<< keyword: then
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< atomBase next token: TokKeyword "if"
<< expr next token: TokKeyword "if"
<< keyword: if
<< atomBase next token: TokIdent "cond"
<< atomBase next token: TokKeyword "then"
<< keyword: then
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< keyword: if
<< atomBase next token: TokIdent "cond"
<< atomBase next token: TokKeyword "then"
<< keyword: then
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< atomBase next token: TokKeyword "if"
Nothing

-- Let with lambda --
-- Input: do { let f = \x -> x + 1 * 2; return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "\\",TokIdent "x",TokArrow,TokIdent "x",TokOperator "+",TokNumber 1,TokOperator "*",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- Let without semicolon --
-- Input: do { let x = 1 return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- Do in case --
-- Input: case v of Just x -> do { let y = x + 1; return y }; Nothing -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "x",TokArrow,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokNumber 0]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "case"
<< keyword: case
<< expr next token: TokIdent "v"
<< atomBase next token: TokIdent "v"
<< atomBase next token: TokKeyword "of"
<< keyword: of
<< caseAlt
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "x")
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< atomBase next token: TokKeyword "case"
<< expr next token: TokKeyword "case"
<< keyword: case
<< expr next token: TokIdent "v"
<< atomBase next token: TokIdent "v"
<< atomBase next token: TokKeyword "of"
<< keyword: of
<< caseAlt
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "x")
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< atomBase next token: TokKeyword "case"
Nothing

-- Empty do --
-- Input: do { }
Tokens: [TokKeyword "do",TokSymbol "{",TokSymbol "}"]
Just (EDo [])

-- Case with as-pattern --
-- Input: case v of x@(Just y) -> return x _ -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokIdent "x",TokSymbol "@",TokSymbol "(",TokTypeIdent "Just",TokIdent "y",TokSymbol ")",TokArrow,TokKeyword "return",TokIdent "x",TokSymbol "_",TokArrow,TokKeyword "return",TokNumber 0]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "case"
<< keyword: case
<< expr next token: TokIdent "v"
<< atomBase next token: TokIdent "v"
<< atomBase next token: TokKeyword "of"
<< keyword: of
<< caseAlt
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "y")
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "y")
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "case"
<< expr next token: TokKeyword "case"
<< keyword: case
<< expr next token: TokIdent "v"
<< atomBase next token: TokIdent "v"
<< atomBase next token: TokKeyword "of"
<< keyword: of
<< caseAlt
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "y")
<< pattern1: (pAsPattern <|> makeCons)PApp (PConstr "Just" []) (PVar "y")
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "case"
Nothing

-- x; y; z statements --
-- Input: x; y; z
Tokens: [TokIdent "x",TokSymbol ";",TokIdent "y",TokSymbol ";",TokIdent "z"]
Just (ESeq [EVar "x",EVar "y",EVar "z"])

-- Let with case --
-- Input: do { let x = case v of Just n -> n; Nothing -> 0; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "n",TokArrow,TokIdent "n",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokNumber 0,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- simple --
-- Input: { x = 1 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}"]
Just (ERecord [("x",EInt 1)])

-- 2 --
-- Input: { x = 1, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

-- tag --
-- Input: r { x = 3 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3)]))

-- nest --
-- Input: { a = { b = 3 } }
Tokens: [TokSymbol "{",TokIdent "a",TokSymbol "=",TokSymbol "{",TokIdent "b",TokSymbol "=",TokNumber 3,TokSymbol "}",TokSymbol "}"]
Just (ERecord [("a",ERecord [("b",EInt 3)])])

-- 2 equation --
-- Input: { x = 1 + 2, y = f 3 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ",",TokIdent "y",TokSymbol "=",TokIdent "f",TokNumber 3,TokSymbol "}"]
Just (ERecord [("x",EBinOp "+" (EInt 1) (EInt 2)),("y",EApp (EVar "f") (EInt 3))])

-- space --
-- Input: {  x=1 , y =2}
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

--  --
-- Input: r { x = 3, y = 4 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 4,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3),("y",EInt 4)]))

--  --
-- Input: (f x) { y = 10 }
Tokens: [TokSymbol "(",TokIdent "f",TokIdent "x",TokSymbol ")",TokSymbol "{",TokIdent "y",TokSymbol "=",TokNumber 10,TokSymbol "}"]
Just (EApp (EApp (EVar "f") (EVar "x")) (ERecord [("y",EInt 10)]))

--  --
-- Input: { x = 1, y = 2 } { x = 9 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 9,TokSymbol "}"]
Just (EApp (ERecord [("x",EInt 1),("y",EInt 2)]) (ERecord [("x",EInt 9)]))

--  --
-- Input: (+ 1)
Tokens: [TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: (1 +)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (EInt 1) "+")

--  --
-- Input: (* 2) (2 *) (> 3) (3 >)
Tokens: [TokSymbol "(",TokOperator "*",TokNumber 2,TokSymbol ")",TokSymbol "(",TokNumber 2,TokOperator "*",TokSymbol ")",TokSymbol "(",TokOperator ">",TokNumber 3,TokSymbol ")",TokSymbol "(",TokNumber 3,TokOperator ">",TokSymbol ")"]
Just (EApp (EApp (EApp (EOpSectionL "*" (EInt 2)) (EOpSectionR (EInt 2) "*")) (EOpSectionL ">" (EInt 3))) (EOpSectionR (EInt 3) ">"))

--  --
-- Input: ((+ 1))
Tokens: [TokSymbol "(",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: { f = (+ 1) }
Tokens: [TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol "}"]
Just (ERecord [("f",EOpSectionL "+" (EInt 1))])

--  --
-- Input: r { f = (1 +) }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")",TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("f",EOpSectionR (EInt 1) "+")]))

--  --
-- Input: ({ x = 1 } +)
Tokens: [TokSymbol "(",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (ERecord [("x",EInt 1)]) "+")

--  --
-- Input: do { let r = { x = 1 }; return r }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokIdent "r",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

--  --
-- Input: do { let r = { x = 1 }; return (r { x = 2 }) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol ")",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "r"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

--  --
-- Input: do { let f = (+ 1); return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
<< expr next token: TokKeyword "do"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< keyword: do
<< doExpr
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< expr next token: TokKeyword "let"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "f"
<< atomBase next token: TokKeyword "let"
<< atomBase next token: TokKeyword "do"
Nothing

-- error1 --
-- Input: { = 1 }
Tokens: [TokSymbol "{",TokSymbol "=",TokNumber 1,TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
Nothing

-- error2 --
-- Input: { x = 1,, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokNumber 1
<< atomBase next token: TokNumber 1
<< int: 1
<< atomBase next token: TokSymbol ","
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokNumber 1
<< atomBase next token: TokNumber 1
<< int: 1
<< atomBase next token: TokSymbol ","
Nothing

-- error3 --
-- Input: ()
Tokens: [TokSymbol "(",TokSymbol ")"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "("
<< atomBase next token: TokSymbol ")"
<< expr next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol "("
<< expr next token: TokSymbol "("
<< atomBase next token: TokSymbol ")"
<< expr next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol "("
Nothing

-- error4 Ok --
-- Input: (1 + 2)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ")"]
Just (EBinOp "+" (EInt 1) (EInt 2))

-- case gard1 --
-- Input: case x of { p | cond1 -> e1; p2 | cond2 -> e2; p3 -> e3 }
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokSymbol "{",TokIdent "p",TokSymbol "|",TokIdent "cond1",TokArrow,TokIdent "e1",TokSymbol ";",TokIdent "p2",TokSymbol "|",TokIdent "cond2",TokArrow,TokIdent "e2",TokSymbol ";",TokIdent "p3",TokArrow,TokIdent "e3",TokSymbol "}"]
Just (ECase (EVar "x") [CaseAltGuard (PVar "p") [(EVar "cond1",EVar "e1")],CaseAltGuard (PVar "p2") [(EVar "cond2",EVar "e2")],CaseAlt (PVar "p3") (EVar "e3")])

-- case gard2 --
-- Input: case x of n | n < 0 -> 1 
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt 1)]])

-- case gard3 --
-- Input: case x of n | n < 0 -> -1 | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt (-1)),(EBinOp ">" (EVar "n") (EInt 0),EInt 1)]])

-- case gard4 --
-- Input: case x of n | n < 0 -> -1
  0 -> 0
  n | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokNewline,TokNumber 0,TokArrow,TokNumber 0,TokNewline,TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt (-1))],CaseAlt (PInt 0) (EInt 0),CaseAltGuard (PVar "n") [(EBinOp ">" (EVar "n") (EInt 0),EInt 1)]])
