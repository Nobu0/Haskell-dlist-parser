{-# LANGUAGE OverloadedStrings #-}

-- module Test.DeclParserSpec (spec) where

import Test.Hspec
import AST.Decl
import AST.Type
import Decl.DeclParserCore (program)
import Lexer.Lexer (runLexer)
import Parser.Core.Combinator (runParser)

spec :: Spec
spec = describe "Decl parser" $ do

  it "parses a simple type alias" $
    parse "type Yen = Int"
      `shouldBe` Just [DeclTypeAlias "Yen" [] (TCon "Int")]

  it "parses a type alias with type variable" $
    parse "type Pair a = (a, a)"
      `shouldBe` Just [DeclTypeAlias "Pair" ["a"] (TTuple [TVar "a", TVar "a"])]

  it "parses a class declaration with no methods" $
    parse "class Eq a where {}"
      `shouldBe` Just [DeclClass "Eq" ["a"] []]

  it "parses a class declaration with one method" $
    parse "class Show a where { show :: a -> String }"
      `shouldBe` Just
        [ DeclClass
            "Show"
            ["a"]
            [DeclTypeSig "show" (TArrow (TVar "a") (TCon "String"))]
        ]

  it "parses an instance declaration with no context" $
    parse "instance Show Int where {}"
      `shouldBe` Just [DeclInstance Nothing "Show" [TCon "Int"] []]

  it "parses an instance declaration with context" $
    parse "instance (Eq a, Show a) => Ord a where {}"
      `shouldBe` Just
        [ DeclInstance
            (Just [Constraint "Eq" [TVar "a"], Constraint "Show" [TVar "a"]])
            "Ord"
            [TVar "a"]
            []
        ]

  it "parses an instance with method" $
    parse "instance Eq Int where { (==) :: Int -> Int -> Bool }"
      `shouldBe` Just
        [ DeclInstance
            Nothing
            "Eq"
            [TCon "Int"]
            [DeclTypeSig "==" (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Bool")))]
        ]

-- ヘルパー関数：文字列をパースしてASTを返す
parse :: String -> Maybe [Decl]
parse src = case runParser program (runLexer src) of
  Just (ast, _) -> Just ast
  Nothing -> Nothing

{-}
module Test.DeclParserSpec (spec) where

-- 実際のパーサーモジュールに合わせて調整
import AST.Decl
import AST.Expr
import AST.Pattern
import AST.Type
import Data.Either (isRight)
import Data.Text.IO hiding (putStrLn)
import Decl.DeclParserCore (program)
import Lexer.Lexer (runLexer)
import Parser.Core.Combinator (Parser (..), runParser, try)
import TypeInference.Infer
import TypeInference.Infer (inferExpr)
import TypeInference.Pretty (prettyType)
import TypeInference.Type (Type (..))
import TypeInference.TypeEnv (emptyEnv)

parseDecl :: String -> IO ()
parseDecl src = do
  putStrLn $ "\n-- test " ++ " Input: " ++ src
  let toks = runLexer src
  putStrLn $ "Tokens: " ++ show toks

  let parsed = runParser program toks
  case parsed of
    Nothing -> putStrLn "Parse failed"
    Just (ast, _) -> do
      putStrLn $ "AST: " ++ show ast

{-}
      case inferExpr emptyEnv ast of
        Left err -> putStrLn $ "TypeError: " ++ show err
        Right (_, ty) -> putStrLn $ "Type: " ++ prettyType ty
        _ -> putStrLn $ "error"
-}
-- spec :: Spec
spec = do
  putStrLn $ "parses a simple type alias"
  parseDecl "type Yen = Int"
  --  `shouldBe` Right (DeclTypeAlias "Yen" [] (TCon "Int"))

  putStrLn $ "parses a type alias with type variable"
  parseDecl "type Pair a = (a, a)"
  --  `shouldBe` Right (DeclTypeAlias "Pair" ["a"] (TTuple [TVar "a", TVar "a"]))

  putStrLn $ "parses a class declaration with no methods"
  parseDecl "class Eq a where {}"
  --  `shouldBe` Right (DeclClass "Eq" ["a"] [])

  putStrLn $ "parses a class declaration with one method"
  parseDecl "class Show a where { show :: a -> String }"
  {-}
        `shouldBe` Right
          ( DeclClass
              "Show"
              ["a"]
              [DeclTypeSig "show" (TArrow (TVar "a") (TCon "String"))]
          )
  -}
  putStrLn $ "parses an instance declaration with no context"
  parseDecl "instance Show Int where {}"
  --  `shouldBe` Right (DeclInstance Nothing "Show" [TCon "Int"] [])

  putStrLn $ "parses an instance declaration with context"
  parseDecl "instance (Eq a, Show a) => Ord a where {}"
  {-}
        `shouldBe` Right
          ( DeclInstance
              (Just [Constraint "Eq" [TVar "a"], Constraint "Show" [TVar "a"]])
              "Ord"
              [TVar "a"]
              []
          )
  -}

  putStrLn $ "parses an instance with method"
  parseDecl "instance Eq Int where { (==) :: Int -> Int -> Bool }"

{-}
      `shouldBe` Right
        ( DeclInstance
            Nothing
            "Eq"
            [TCon "Int"]
            [DeclTypeSig "==" (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Bool")))]
        )
-}
