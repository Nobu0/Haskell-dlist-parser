=== Running: src/AST/Decl.hs ===
-- Raw Source --
module AST.Decl where

import AST.Expr
import AST.Pattern (Pattern)
import AST.Type (Constraint, Type)

data Decl
  = DeclFun Name [Pattern] Expr
  | DeclValue Pattern Expr
  | DeclTypeSig Name Type
  | DeclData Name [Name] [Constraint]
  | DeclNewtype Name [Name] Constraint
  | DeclImport Name
  | DeclModule Name
  | DeclClass String [String] [Decl]
  | DeclInstance (Maybe [Constraint]) String [Type] [Decl]
  | DeclTypeAlias String [String] Type
  deriving (Show, Eq)

-- data Constr = Constr Name [Type]
--  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Decl",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "DeclFun",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclValue",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclTypeSig",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclData",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclNewtype",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSpace 1,TokTypeIdent "Constraint",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclImport",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclModule",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclClass",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclInstance",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ")",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclTypeAlias",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Decl",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "DeclFun",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclValue",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclTypeSig",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclData",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclNewtype",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSpace 1,TokTypeIdent "Constraint",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclImport",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclModule",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclClass",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclInstance",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ")",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "DeclTypeAlias",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/AST/Expr.hs ===
-- Raw Source --
module AST.Expr where

import AST.Pattern (Pattern)
import AST.Type (Type)

type Name = String

-- Binding
type Binding = (Pattern, Expr)

-- CaseAlt
data CaseAlt
  = CaseAlt Pattern Expr
  | CaseAltGuard Pattern [(Expr, Expr)]
  deriving (Eq, Show)

-- Stmt
data Stmt
  = Bind Pattern Expr
  | ExprStmt Expr
  | LetStmt [(Pattern, Expr)]
  deriving (Eq, Show)

-- Qualifier
data Qualifier
  = QGenerator Pattern Expr
  | QLet [(Pattern, Expr)]
  | QGuard Expr
  deriving (Eq, Show)

-- Expr 本体
data Expr
  = EVar String
  | EVarType String
  | EInt Int
  | EString String
  | EBinOp BinOp Expr Expr
  | EBool Bool
  | ELet Pattern Expr Expr
  | ELetBlock [(Pattern, Expr)] Expr
  | EIf Expr Expr Expr
  | ELam Pattern Expr
  | EApp Expr Expr
  | ECase Expr [CaseAlt]
  | EList [Expr]
  | ETuple [Expr]
  | ERange Expr Expr
  | ERangeStep Expr Expr Expr
  | EListComp Expr [Qualifier]
  | EAnn Expr Type
  | EDo [Stmt]
  | ESeq [Expr]
  | EReturn Expr
  | ERecord [(String, Expr)]
  | ERecordUpdate Expr [(String, Expr)]
  | EOpSectionL String Expr
  | EOpSectionR Expr String
  | EPlaceholder
  | EWhere Expr [Binding]
  | ESQL String [Expr]
  deriving (Eq, Show)

data BinOp
  = Add
  | Sub
  | Mul
  | Div
  | And
  | Or
  | Eq
  | Neq
  | Lt
  | Gt
  | Le
  | Ge
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "CaseAlt",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "CaseAlt",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "CaseAltGuard",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Stmt",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "Bind",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ExprStmt",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "LetStmt",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Qualifier",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "QGenerator",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "QLet",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Expr",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "EVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EVarType",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EString",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EBinOp",TokSpace 1,TokTypeIdent "BinOp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EBool",TokSpace 1,TokTypeIdent "Bool",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELet",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELetBlock",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EIf",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELam",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EApp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ECase",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EList",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ETuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERange",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERangeStep",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EListComp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "Qualifier",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EAnn",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EDo",TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ESeq",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EReturn",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERecord",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERecordUpdate",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EOpSectionL",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EOpSectionR",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EPlaceholder",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EWhere",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ESQL",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "BinOp",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "Add",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Sub",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Mul",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Div",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "And",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Or",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Eq",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Neq",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Lt",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Gt",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Le",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Ge",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "CaseAlt",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "CaseAlt",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "CaseAltGuard",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Stmt",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "Bind",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ExprStmt",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "LetStmt",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Qualifier",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "QGenerator",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "QLet",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Expr",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "EVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EVarType",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EString",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EBinOp",TokSpace 1,TokTypeIdent "BinOp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EBool",TokSpace 1,TokTypeIdent "Bool",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELet",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELetBlock",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EIf",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ELam",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EApp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ECase",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EList",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ETuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERange",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERangeStep",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EListComp",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "Qualifier",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EAnn",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EDo",TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ESeq",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EReturn",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERecord",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ERecordUpdate",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EOpSectionL",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EOpSectionR",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EPlaceholder",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "EWhere",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "ESQL",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "BinOp",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "Add",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Sub",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Mul",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Div",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "And",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Or",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Eq",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Neq",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Lt",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Gt",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Le",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "Ge",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/AST/Module.hs ===
-- Raw Source --
module AST.Module where

import AST.Type
import AST.Decl (Decl)

type Name = String

data Module = Module
  { moduleName :: Name
  , moduleImports :: [Import]
  , moduleDecls :: [Decl]
  }
  deriving (Show, Eq)

data Import = Import
  { importName :: Name
  }
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol ")",TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Module",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Module",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "moduleName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "moduleImports",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Import",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "moduleDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Import",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Import",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "importName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol ")",TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Module",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Module",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "moduleName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "moduleImports",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Import",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "moduleDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Import",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Import",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "importName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/AST/Pattern.hs ===
-- Raw Source --
module AST.Pattern where

-- import AST.Type (Type)
-- import AST.Module (Name)
-- import AST.Pattern (Pattern)
-- import AST.Expr (Expr)

type Name = String

data Pattern
  = PVar Name
  | PInt Int
  | PWildcard
  | PCons Pattern Pattern
  | PList [Pattern]
  | PTuple [Pattern]
  | PConstr Name [Pattern]
  | PAs Name Pattern -- ← 追加！
  | PApp Pattern [Pattern] -- ★ 修正
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Pattern",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "PVar",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PWildcard",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PCons",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PList",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PConstr",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PAs",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PApp",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "String",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Pattern",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "PVar",TokSpace 1,TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PWildcard",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PCons",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PList",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PConstr",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PAs",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "PApp",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/AST/Program.hs ===
-- Raw Source --
module AST.Program where


data Program = Program
  { moduleDecl :: Maybe Decl
  , imports    :: [Decl]
  , decls      :: [Decl]
  }


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Program",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Program",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Program",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "moduleDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "Decl",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "imports",TokSpace 4,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "decls",TokSpace 6,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Program",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Program",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Program",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "moduleDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "Decl",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "imports",TokSpace 4,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "decls",TokSpace 6,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/AST/Type.hs ===
-- Raw Source --
module AST.Type where

-- import AST.Decl (Binding)

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  | TFun Type Type
  deriving (Eq, Show)

data Constraint = Constraint String [Type]
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TCon",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TList",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TUnit",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TFun",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TCon",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TList",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TUnit",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TFun",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/Decl/DeclParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParserCore where

import AST.Decl
import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- ★ ここが正しい

-- (keyword) -- , whereClause)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

-- decls :: Parser [Decl]
-- decls = many decl
{-}
decl :: Parser Decl
decl = do
  skipNewlines
  myTrace "<< decl parser called"
  declBody
-}
isEOF :: Parser Bool
isEOF = Parser $ \ts ->
  case ts of
    [] -> Just (True, [])
    _ -> Just (False, ts)

decl :: Parser Decl
decl = do
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< decl next token: " ++ show t)
  eof <- isEOF
  if eof
    then Parser $ \_ -> Nothing -- many decl に「もう終わり」と伝える
    else do
      myTrace "<< decl parser called"
      declBody

declBody :: Parser Decl
declBody = do
  declDispatch
  where
    declDispatch = do
      t <- lookAhead anyToken
      myTrace ("<< decl dispatch: " ++ show t)
      case t of
        TokKeyword "data" -> dataDecl
        TokKeyword "newType" -> newtypeDecl
        TokKeyword "import" -> importDecl
        TokKeyword "instance" -> instanceDecl
        TokKeyword "module" -> moduleDecl
        TokKeyword "class" -> classDecl
        TokKeyword "type" -> typeAliasDecl
        -- _ -> try funDecl <|> valueDecl
        TokIdent _ -> try typeSigDecl <|> try funDecl <|> valueDecl
        TokSymbol "(" -> try typeSigDecl <|> empty -- "unexpected symbol in declaration"

-- Haskell ファイル全体
program :: Parser [Decl]
program = many decl

{-}
-- 関数宣言
funDecl :: Parser Decl
funDecl = do
  name <- ident
  args <- many patternParser
  t <- lookAhead anyToken
  myTrace ("<< funcdecl 2: " ++ show t)
  symbol "="
  body <- expr
  return (DeclFun (PConstr name args) body)
-}

funDecl :: Parser Decl
funDecl = do
  myTrace "<< funDecl parser called"
  (name, args) <- funHead
  symbol "="
  body <- expr
  return (DeclFun name args body)

funHead :: Parser (Name, [Pattern])
funHead = do
  p <- pattern
  case p of
    PVar name -> do
      args <- many pattern
      return (name, args)
    PApp (PVar name) args -> do
      moreArgs <- many pattern
      return (name, args ++ moreArgs)
    _ -> do
      myTrace "Function definition must start with a variable name"
      empty

{-}
typeSigDecl :: Parser Decl
typeSigDecl = do
  name <- ident
  symbol "::"
  ty <- parseType
  myTrace ("<< parsed type signature: " ++ name ++ " :: " ++ show ty)
  let decl = DeclTypeSig name ty
  myTrace ("<< returning DeclTypeSig: " ++ show decl)
  return decl
-}
typeSigDecl :: Parser Decl
typeSigDecl = do
  name <- name -- operator <|> ident
  symbol "::"
  ty <- parseType
  myTrace ("<< parsed type signature: " ++ name ++ " :: " ++ show ty)
  let decl = DeclTypeSig name ty
  myTrace ("<< returning DeclTypeSig: " ++ show decl)
  return decl

-- 値宣言
valueDecl :: Parser Decl
valueDecl = do
  myTrace "<< valueDecl parser called"
  pat <- patternParser
  symbol "="
  body <- expr
  return (DeclValue pat body)

-- import 文
importDecl :: Parser Decl
importDecl = do
  myTrace "<< importDecl parser called"
  keyword "import"
  modName <- moduleName
  return (DeclImport modName)

moduleName :: Parser Name
moduleName = intercalate "." <$> sepBy1 ident (symbol ".")

-- data 宣言
dataDecl :: Parser Decl
dataDecl = do
  myTrace "<< dataDecl parser called"
  keyword "data"
  name <- typeIdent
  vars <- many typeIdent
  symbol "="
  constrs <- constr `sepBy1` symbol "|"
  return (DeclData name vars constrs)

-- コンストラクタ
constr :: Parser Constraint
constr = do
  myTrace "<< constr parser called"
  cname <- typeIdent
  tys <- many parseType
  return (Constraint cname tys)

-- newtype 宣言
newtypeDecl :: Parser Decl
newtypeDecl = do
  myTrace "<< newtypeDecl parser called"
  keyword "newtype"
  name <- typeIdent
  vars <- many typeIdent
  symbol "="
  c <- constr
  return (DeclNewtype name vars c)

moduleDecl :: Parser Decl
moduleDecl = do
  keyword "module"
  name <- typeIdent -- <|> token TokTypeIdent)
  keyword "where"
  return (DeclModule name)

instanceDecl :: Parser Decl
instanceDecl = do
  myTrace "<< instanceDecl parser called"
  keyword "instance"
  ctx <- optional (try (constraintList <* keyword "=>"))
  className <- typeIdent
  args <- some typeAtom
  keyword "where"
  methods <- bracedBlock decl
  return (DeclInstance ctx className args methods)

classDecl :: Parser Decl
classDecl = do
  myTrace "<< classDecl parser called"
  keyword "class"
  className <- typeIdent
  vars <- some ident
  keyword "where"
  t <- lookAhead anyToken
  methods <- bracedBlock decl
  return $ DeclClass className vars methods

typeAliasDecl :: Parser Decl
typeAliasDecl = do
  myTrace "<< typeAliasDecl parser called"
  keyword "type"
  name <- typeIdent
  vars <- many ident
  symbol "="
  body <- parseType
  return $ DeclTypeAlias name vars body


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "isEOF",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isEOF",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "decl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokSpace 1,TokIdent "eof",TokSymbol "{",TokKeyword "then",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "declBody",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "declDispatch",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "declDispatch",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "data",TokSpace 1,TokArrow,TokSpace 1,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "newType",TokSpace 1,TokArrow,TokSpace 1,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "import",TokSpace 1,TokArrow,TokSpace 1,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "instance",TokSpace 1,TokArrow,TokSpace 1,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "module",TokSpace 1,TokArrow,TokSpace 1,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "class",TokSpace 1,TokArrow,TokSpace 1,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "type",TokSpace 1,TokArrow,TokSpace 1,TokIdent "typeAliasDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "typeSigDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "funDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "valueDecl",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "(",TokSpace 1,TokArrow,TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "typeSigDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "program",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "decl",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "funDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "funDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< funDecl parser called",TokSymbol ";",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "funHead",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "args",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "funHead",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "p",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "PVar",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "moreArgs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "typeSigDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "::",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "decl",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "valueDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< valueDecl parser called",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "importDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "importDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< importDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "import",TokSymbol ";",TokIdent "modName",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "moduleName",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclImport",TokIdent "modName",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "moduleName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Name",TokNewline,TokIdent "moduleName",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "intercalate",TokSpace 1,TokString ".",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "ident",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ".",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "dataDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "dataDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< dataDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "data",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "constrs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constr",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclData",TokIdent "name",TokIdent "vars",TokIdent "constrs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "constr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "newtypeDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "newtype",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "c",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "moduleDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "moduleDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "module",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSpace 1,TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "instanceDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "instance",TokSymbol ";",TokIdent "ctx",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<",TokOperator "*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "methods",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bracedBlock",TokSpace 1,TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "classDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "class",TokSymbol ";",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bracedBlock",TokSpace 1,TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "DeclClass",TokSpace 1,TokIdent "className",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "methods",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeAliasDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "type",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "DeclTypeAlias",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "isEOF",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isEOF",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "decl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokSpace 1,TokIdent "eof",TokSymbol "{",TokKeyword "then",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "declBody",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "declDispatch",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "declDispatch",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "data",TokSpace 1,TokArrow,TokSpace 1,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "newType",TokSpace 1,TokArrow,TokSpace 1,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "import",TokSpace 1,TokArrow,TokSpace 1,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "instance",TokSpace 1,TokArrow,TokSpace 1,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "module",TokSpace 1,TokArrow,TokSpace 1,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "class",TokSpace 1,TokArrow,TokSpace 1,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "type",TokSpace 1,TokArrow,TokSpace 1,TokIdent "typeAliasDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "typeSigDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "funDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "valueDecl",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "(",TokSpace 1,TokArrow,TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "typeSigDecl",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "program",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "decl",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "funDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "funDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< funDecl parser called",TokSymbol ";",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "funHead",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "args",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "funHead",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "p",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "PVar",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "moreArgs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "typeSigDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "::",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "decl",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "valueDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< valueDecl parser called",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "importDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "importDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< importDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "import",TokSymbol ";",TokIdent "modName",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "moduleName",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclImport",TokIdent "modName",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "moduleName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Name",TokNewline,TokIdent "moduleName",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "intercalate",TokSpace 1,TokString ".",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "ident",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ".",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "dataDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "dataDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< dataDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "data",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "constrs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constr",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclData",TokIdent "name",TokIdent "vars",TokIdent "constrs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "constr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "newtypeDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "newtype",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "c",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "moduleDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "moduleDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "module",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSpace 1,TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "instanceDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "instance",TokSymbol ";",TokIdent "ctx",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<",TokOperator "*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "methods",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bracedBlock",TokSpace 1,TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "classDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "class",TokSymbol ";",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bracedBlock",TokSpace 1,TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "DeclClass",TokSpace 1,TokIdent "className",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "methods",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeAliasDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "myTrace",TokSpace 1,TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "type",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "DeclTypeAlias",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline])

=== Running: src/Layout/LayoutTransform.hs ===
-- Raw Source --
-- stack はインデントのリスト --

module Layout.LayoutTransform (layoutTransform) where

import Lexer.Token

layoutTransform :: [Token] -> [Token]
layoutTransform toks = go toks

go :: [Token] -> [Token]
go [] = []
go (TokVNewline (x, y) : rest)
  | x == 0 && x == y = TokNewline : go rest
  | x == y = TokSymbol ";" : go rest
  | x < y = TokSymbol "{" : go rest
  | x > y = closeBlocks (x, y) rest
go (t : rest) =
  t : go rest

closeBlocks :: (Int, Int) -> [Token] -> [Token]
closeBlocks (x, y) rest
  | x > y = TokSymbol "}" : closeBlocks (x - 1, y) rest
  | otherwise = TokNewline : go rest


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokSpace 1,TokSymbol "(",TokIdent "layoutTransform",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "layoutTransform",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutTransform",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "toks",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "&",TokSymbol "&",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString ";",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator "<",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "{",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "closeBlocks",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "}",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokSpace 1,TokSymbol "(",TokIdent "layoutTransform",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "layoutTransform",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutTransform",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "toks",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "&",TokSymbol "&",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString ";",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator "<",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "{",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "closeBlocks",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "x",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "y",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "}",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "closeBlocks",TokSpace 1,TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline])

=== Running: src/Lexer/LayoutLexer.hs ===
-- Raw Source --
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] 0 toks -- 追加: parenDepth = 0

go :: [Int] -> Int -> [Token] -> [Token]
go stack _ [] = []
-- 行頭のスペース（括弧外のみ処理）
go stack 0 (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack 0 rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
-- 行頭の改行（スペースなし）※括弧外のみ処理
go stack 0 (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' 0 rest
-- 括弧内の TokSpace や TokNewline はスキップ
go stack depth (TokSpace _ : rest)
  | depth > 0 = go stack depth rest
go stack depth (TokNewline : rest)
  | depth > 0 = go stack depth rest
-- 括弧のネスト制御
go stack depth (TokSymbol "(" : rest) =
  TokSymbol "(" : go stack (depth + 1) rest
go stack depth (TokSymbol ")" : rest) =
  TokSymbol ")" : go stack (max 0 (depth - 1)) rest
-- その他のトークン
go stack depth (t : rest) =
  t : go stack depth rest

{-}
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] toks

go :: [Int] -> [Token] -> [Token]
go stack [] = []
-- 行頭のスペース
go stack (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
-- 行頭の改行（スペースなし）
go stack (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' rest
-- 行頭以外のスペース（SimpleLexer が出さないなら無視でOK）
go stack (TokSpace _ : rest) =
  go stack rest
-- その他のトークン
go stack (t : rest) =
  t : go stack rest
-}

-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokSpace 1,TokSymbol "(",TokIdent "layoutLexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "layoutLexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutLexer",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "[",TokNumber 0,TokSymbol "]",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "toks",TokSpace 1,TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Int",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Int",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokTypeIdent "TokSpace",TokIdent "n",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "level",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "stack",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack'",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokOperator "<",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "dropWhile",TokSpace 1,TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokSpace 1,TokIdent "stack",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack'",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokNumber 0,TokSymbol "]",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSpace",TokSymbol "_",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "depth",TokSpace 1,TokOperator ">",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "depth",TokSpace 1,TokOperator ">",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString "(",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokSpace 1,TokSymbol "(",TokIdent "layoutLexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "layoutLexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutLexer",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "[",TokNumber 0,TokSymbol "]",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "toks",TokSpace 1,TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Int",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Int",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokTypeIdent "TokSpace",TokIdent "n",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "level",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokOperator ">",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "stack",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack'",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "|",TokSpace 1,TokIdent "n",TokSpace 1,TokOperator "<",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "dropWhile",TokSpace 1,TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokSpace 1,TokIdent "stack",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack'",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "stack'",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokNumber 0,TokSymbol "]",TokSymbol "{",TokIdent "prevLevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "stack",TokSpace 1,TokOperator "-",TokSpace 1,TokNumber 1,TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack'",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSpace",TokSymbol "_",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "depth",TokSpace 1,TokOperator ">",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokNewline",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "depth",TokSpace 1,TokOperator ">",TokSpace 1,TokNumber 0,TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString "(",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "stack",TokSpace 1,TokIdent "depth",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline])

=== Running: src/Lexer/Lexer.hs ===
-- Raw Source --
module Lexer.Lexer
  ( runLexer   -- ← 外部に公開する関数
  ) where

import Lexer.Token
import Lexer.SimpleLexer
import Lexer.LayoutLexer
import Layout.LayoutTransform

runLexer :: String -> [Token]
runLexer = layoutTransform . layoutLexer . slexer


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "{",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokSymbol "}",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokNewline,TokNewline,TokIdent "runLexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "runLexer",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "layoutTransform",TokSpace 1,TokDot,TokSpace 1,TokIdent "layoutLexer",TokSpace 1,TokDot,TokSpace 1,TokIdent "slexer",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "{",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokSymbol "}",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokNewline,TokNewline,TokIdent "runLexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "runLexer",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "layoutTransform",TokSpace 1,TokDot,TokSpace 1,TokIdent "layoutLexer",TokSpace 1,TokDot,TokSpace 1,TokIdent "slexer",TokNewline])

=== Running: src/Lexer/SimpleLexer.hs ===
-- Raw Source --
module Lexer.SimpleLexer (slexer) where

import Data.Char
import Data.Char (isLetter)
import Lexer.Token

slexer :: String -> [Token]
slexer = go
  where
    go [] = []
    ------------------------------------------------------------
    -- 改行
    ------------------------------------------------------------
    go ('\n' : rest) =
      TokNewline : go rest
    ------------------------------------------------------------
    -- 行コメント "-- ..."
    ------------------------------------------------------------
    go ('-' : '-' : rest) =
      let rest' = dropWhile (/= '\n') rest
       in go rest'
    ------------------------------------------------------------
    -- ブロックコメント "{- ... -}"
    ------------------------------------------------------------
    go ('{' : '-' : rest) =
      let rest' = skipBlockComment rest
       in go rest'
    ------------------------------------------------------------
    -- 空白（スペース）
    ------------------------------------------------------------
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    ------------------------------------------------------------
    -- 文字リテラル
    ------------------------------------------------------------
    go ('\'' : rest) =
      case rest of
        ('\\' : c : '\'' : rest') ->
          TokChar (escapeChar c) : go rest'
        (c : '\'' : rest') ->
          TokChar c : go rest'
        _ ->
          TokUnknown '\'' : go rest
    ------------------------------------------------------------
    -- 文字列リテラル
    ------------------------------------------------------------
    go ('"' : rest) =
      let (str, rest') = readString rest
       in TokString str : go rest'
    ------------------------------------------------------------
    -- 数字
    ------------------------------------------------------------
    go ('-' : c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    ------------------------------------------------------------
    -- 識別子
    ------------------------------------------------------------
    go (c : rest)
      | isLetter c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
    ------------------------------------------------------------
    -- 複数文字記号
    ------------------------------------------------------------
    go ('-' : '>' : rest) = TokArrow : go rest
    go ('=' : '>' : rest) = TokKeyword "=>" : go rest
    go (':' : ':' : rest) = TokSymbol "::" : go rest
    go ('+' : '+' : rest) = TokOperator "++" : go rest
    go ('=' : '=' : rest) = TokSymbol "==" : go rest
    go ('/' : '=' : rest) = TokSymbol "/=" : go rest
    go ('<' : '=' : rest) = TokSymbol "<=" : go rest
    go ('>' : '=' : rest) = TokSymbol ">=" : go rest
    go ('<' : '-' : rest) = TokSymbol "<-" : go rest
    go ('.' : '.' : '.' : rest) = TokEllipsis : go rest
    go ('.' : '.' : rest) = TokSymbol ".." : go rest
    go ('.' : rest) = TokDot : go rest
    go ('+' : rest) = TokOperator "+" : go rest
    go ('-' : rest) = TokOperator "-" : go rest
    go ('*' : rest) = TokOperator "*" : go rest
    go ('/' : rest) = TokOperator "/" : go rest
    -- go ('=' : rest) = TokOperator "=" : go rest
    go ('<' : rest) = TokOperator "<" : go rest
    go ('>' : rest) = TokOperator ">" : go rest
    ------------------------------------------------------------
    -- 単一記号
    ------------------------------------------------------------
    go (c : rest)
      | isSymbolChar c =
          TokSymbol [c] : go rest
    ------------------------------------------------------------
    -- 不明文字
    ------------------------------------------------------------
    go (c : rest) =
      TokUnknown c : go rest

    ------------------------------------------------------------
    -- 補助関数
    ------------------------------------------------------------

    -- isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    isIdentChar c = isLetter c || isDigit c || c == '_' || c == '\''

    -- isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&."
    isSymbolChar x = x `elem` "=(){}[]:;,\\'_|@&"

    classifyIdent "sql" = TokKeyword "sql"
    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "for" = TokKeyword "for"
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "import" = TokKeyword "import"
    classifyIdent "return" = TokKeyword "return"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "class" = TokKeyword "class"
    classifyIdent "type" = TokKeyword "type"
    classifyIdent "newtype" = TokKeyword "newtype"
    classifyIdent "instance" = TokKeyword "instance"
    classifyIdent "=>" = TokKeyword "=>"
    classifyIdent "->" = TokArrow
    -- classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name

    escapeChar 'n' = '\n'
    escapeChar 't' = '\t'
    escapeChar '\\' = '\\'
    escapeChar '\'' = '\''
    escapeChar c = c

    ------------------------------------------------------------
    -- ブロックコメントスキップ
    ------------------------------------------------------------
    skipBlockComment :: String -> String
    skipBlockComment [] = []
    skipBlockComment ('-' : '}' : rest) = rest
    skipBlockComment (_ : rest) = skipBlockComment rest

    ------------------------------------------------------------
    -- 文字列リテラル読み取り
    ------------------------------------------------------------
    readString :: String -> (String, String)
    readString [] = ("", [])
    readString ('"' : rest) = ("", rest)
    readString ('\\' : c : rest) =
      let (s, rest') = readString rest
       in (escapeChar c : s, rest')
    readString (c : rest) =
      let (s, rest') = readString rest
       in (c : s, rest')

{-}
module Lexer.SimpleLexer (runLexer) where

import Data.Char
import Lexer.Token (Token (..))

runLexer :: String -> [Token]
runLexer = go
  where
    go [] = []
    go ('\n' : rest) =
      TokNewline : go rest
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
      | isAlpha c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
      | isSymbolChar c =
          TokSymbol [c] : go rest
      | otherwise =
          TokUnknown c : go rest

    isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&"

    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "->" = TokArrow
    classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name
-}


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokSpace 1,TokSymbol "(",TokIdent "slexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isLetter",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "slexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "slexer",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '\n',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "rest'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "dropWhile",TokSpace 1,TokSymbol "(",TokSymbol "/=",TokChar '\n',TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '{',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "rest'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipBlockComment",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar ' ',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokSymbol "(",TokSymbol "==",TokChar ' ',TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokSpace",TokSpace 1,TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '\'',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "rest",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokChar '\\',TokSymbol ":",TokIdent "c",TokSymbol ":",TokChar '\'',TokSymbol ":",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokChar",TokSpace 1,TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokNewline,TokSymbol "(",TokIdent "c",TokSymbol ":",TokChar '\'',TokSymbol ":",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokUnknown",TokSpace 1,TokChar '\'',TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '"',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokString",TokSpace 1,TokIdent "str",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isLetter",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isIdentChar",TokSpace 1,TokIdent "rest",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "letters",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokIdent "classifyIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokArrow",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '=',TokSymbol ":",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar ':',TokSymbol ":",TokChar ':',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "::",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '+',TokSymbol ":",TokChar '+',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "++",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '=',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "==",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '/',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "/=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '>',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString ">=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<-",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokEllipsis",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "..",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokDot",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '+',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "+",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "-",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '*',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "*",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '/',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "/",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "<",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString ">",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isSymbolChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokSymbol "[",TokIdent "c",TokSymbol "]",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokUnknown",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "isIdentChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "isLetter",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "==",TokSpace 1,TokChar '_',TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "==",TokSpace 1,TokChar '\'',TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "isSymbolChar",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "x",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokString "=(){}[]:;,\\'_|@&",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "classifyIdent",TokSpace 1,TokString "sql",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "do",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "let",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "in",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "case",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "of",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "where",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "forall",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "for",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "if",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "then",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "else",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "module",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "import",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "return",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "data",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "class",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "type",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "newtype",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "instance",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "=>",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "->",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString ".",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "::",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "<-",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "==",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "<=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString ">=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "/=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokIdent "name",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isUpper",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokIdent",TokSpace 1,TokIdent "name",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "escapeChar",TokSpace 1,TokChar 'n',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar 't',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar '\\',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar '\'',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "c",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '}',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "(",TokSymbol "_",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipBlockComment",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "(",TokChar '"',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "(",TokChar '\\',TokSymbol ":",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokIdent "readString",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokSpace 1,TokSymbol "(",TokIdent "slexer",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isLetter",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokNewline,TokIdent "slexer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "slexer",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '\n',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokNewline",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "rest'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "dropWhile",TokSpace 1,TokSymbol "(",TokSymbol "/=",TokChar '\n',TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '{',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "rest'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipBlockComment",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar ' ',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokSymbol "(",TokSymbol "==",TokChar ' ',TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokSpace",TokSpace 1,TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '\'',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "rest",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokChar '\\',TokSymbol ":",TokIdent "c",TokSymbol ":",TokChar '\'',TokSymbol ":",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokChar",TokSpace 1,TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokNewline,TokSymbol "(",TokIdent "c",TokSymbol ":",TokChar '\'',TokSymbol ":",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TokUnknown",TokSpace 1,TokChar '\'',TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '"',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokString",TokSpace 1,TokIdent "str",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isLetter",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokIdent "isIdentChar",TokSpace 1,TokIdent "rest",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "letters",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokIdent "classifyIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest'",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokArrow",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '=',TokSymbol ":",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar ':',TokSymbol ":",TokChar ':',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "::",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '+',TokSymbol ":",TokChar '+',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "++",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '=',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "==",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '/',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "/=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '>',TokSymbol ":",TokChar '=',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString ">=",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<-",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokEllipsis",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "..",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '.',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokDot",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '+',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "+",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "-",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '*',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "*",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '/',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "/",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '<',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "<",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokChar '>',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString ">",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isSymbolChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokSymbol "[",TokIdent "c",TokSymbol "]",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TokUnknown",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol ":",TokSpace 1,TokIdent "go",TokSpace 1,TokIdent "rest",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "isIdentChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "isLetter",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "isDigit",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "==",TokSpace 1,TokChar '_',TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "==",TokSpace 1,TokChar '\'',TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "isSymbolChar",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "x",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokString "=(){}[]:;,\\'_|@&",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "classifyIdent",TokSpace 1,TokString "sql",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "do",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "let",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "in",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "case",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "of",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "where",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "forall",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "for",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "if",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "then",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "else",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "module",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "import",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "return",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "data",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "class",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "type",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "newtype",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "instance",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "=>",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "->",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString ".",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "::",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "<-",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "==",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "<=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString ">=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokString "/=",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokSpace 1,TokIdent "name",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "isUpper",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "name",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TokIdent",TokSpace 1,TokIdent "name",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "escapeChar",TokSpace 1,TokChar 'n',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar 't',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar '\\',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokChar '\'',TokSpace 1,TokSymbol "=",TokSpace 1,TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokSpace 1,TokIdent "c",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "c",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "(",TokChar '-',TokSymbol ":",TokChar '}',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSpace 1,TokSymbol "(",TokSymbol "_",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipBlockComment",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "(",TokChar '"',TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSpace 1,TokSymbol "(",TokChar '\\',TokSymbol ":",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokIdent "readString",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "readString",TokSpace 1,TokIdent "rest",TokSymbol "{",TokKeyword "in",TokSpace 1,TokSymbol "(",TokIdent "c",TokSymbol ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline])

=== Running: src/Lexer/Token.hs ===
-- Raw Source --
{-# LANGUAGE OverloadedStrings #-}

module Lexer.Token
  ( Token (..),
  )
where

{-}
import Control.Applicative
import Data.Char (isUpper)
import Data.Void
-- import Text.Megaparsec.Char (oneOf)
import Text.Megaparsec (ParseErrorBundle, Parsec, choice, eof, manyTill, oneOf, parse, satisfy, try, (<|>))
import Text.Megaparsec.Char (alphaNumChar, char, letterChar, space1, string)
import qualified Text.Megaparsec.Char.Lexer as L
-}

-- Parser type
-- type Parser = Parsec Void String

-- Token definition
data Token
  = TokKeyword String
  | TokIdent String
  | TokTypeIdent String
  | TokNumber Int
  | TokFloat Double
  | TokString String
  | TokSymbol String
  | TokOperator String
  | TokChar Char
  | TokForall
  | TokDot
  | TokEllipsis
  | TokArrow
  | TokLParen
  | TokRParen
  | TokNewline
  | TokInt Int
  | TokSpace Int
  | TokIndent
  | TokVLBrace
  | TokVRBrace
  | TokVSemicolon
  | TokVNewline (Int, Int)
  | TokUnknown Char
  deriving (Show, Eq, Ord)


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "{",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Token",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokIdent",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokTypeIdent",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokFloat",TokSpace 1,TokTypeIdent "Double",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokString",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokChar",TokSpace 1,TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokEllipsis",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokLParen",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokRParen",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokNewline",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokSpace",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokIndent",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVLBrace",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVRBrace",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVSemicolon",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokUnknown",TokSpace 1,TokTypeIdent "Char",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Ord",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "{",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Token",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TokKeyword",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokIdent",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokTypeIdent",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokNumber",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokFloat",TokSpace 1,TokTypeIdent "Double",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokString",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokSymbol",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokChar",TokSpace 1,TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokEllipsis",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokLParen",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokRParen",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokNewline",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokInt",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokSpace",TokSpace 1,TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokIndent",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVLBrace",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVRBrace",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVSemicolon",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokVNewline",TokSpace 1,TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TokUnknown",TokSpace 1,TokTypeIdent "Char",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Ord",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/main.hs ===
-- Raw Source --
module Main where

-- import Parser.Core.Parser (runParser)

-- (runLexer)
-- import Layout.LayoutTransform --
-- import Lexer.LayoutLexer

import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified Data.Text.IO as TIO
import Decl.DeclParserCore (program)
import Lexer.Lexer (runLexer)
import Lexer.Token (Token)
import Parser.Core.Combinator (Parser (..), runParser, try)
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO
import System.IO (readFile)
import Utils.MyTrace (setTrace)

main :: IO ()
main = do
  args <- getArgs
  case args of
    [file] -> processFile file
    _ -> putStrLn "Usage: myparser <filename>"

processFile :: FilePath -> IO ()
processFile file = do
  handle <- openFile file ReadMode
  hSetEncoding handle utf8 -- ★ ここでエンコーディングを明示！
  src <- TIO.hGetContents handle
  -- src <- T.readFile file

  putStrLn "-- Raw Source --"
  putStrLn (T.unpack src)

  let toks3 = runLexer (T.unpack src)
  putStrLn "\n-- Tokens from Lexer --"
  print toks3
  {-}
    let toks2 = layoutLexer toks1
    putStrLn "\n-- Tokens from LayoutLexer --"
    print toks2

    let toks3 = layoutTransform toks2
    putStrLn "\n-- Tokens after LayoutTransform --"
    print toks3
  -}
  putStrLn "\n-- Parsing --"
  let ast = runParser program toks3
  putStrLn "\n-- Parsed AST --"
  print ast


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Main",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "T",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "T",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TIO",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSpace 1,TokSymbol "(",TokIdent "program",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSpace 1,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "try",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "Environment",TokSpace 1,TokSymbol "(",TokIdent "getArgs",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "Exit",TokSpace 1,TokSymbol "(",TokIdent "exitFailure",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokIdent "readFile",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "setTrace",TokSymbol ")",TokNewline,TokNewline,TokIdent "main",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "main",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "getArgs",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "args",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "file",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "processFile",TokSpace 1,TokIdent "file",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "putStrLn",TokSpace 1,TokString "Usage: myparser <filename>",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "processFile",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "FilePath",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "processFile",TokSpace 1,TokIdent "file",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "handle",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "openFile",TokSpace 1,TokIdent "file",TokSpace 1,TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokSpace 1,TokIdent "handle",TokSpace 1,TokIdent "utf8",TokSpace 1,TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokSpace 1,TokIdent "handle",TokSymbol ";",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "putStrLn",TokSpace 1,TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "toks3",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runLexer",TokSpace 1,TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokSpace 1,TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "ast",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "program",TokSpace 1,TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokSpace 1,TokIdent "ast",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Main",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "T",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "T",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TIO",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSpace 1,TokSymbol "(",TokIdent "program",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSpace 1,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "try",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "Environment",TokSpace 1,TokSymbol "(",TokIdent "getArgs",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "Exit",TokSpace 1,TokSymbol "(",TokIdent "exitFailure",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokIdent "readFile",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "setTrace",TokSymbol ")",TokNewline,TokNewline,TokIdent "main",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "main",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "getArgs",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "args",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "file",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "processFile",TokSpace 1,TokIdent "file",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "putStrLn",TokSpace 1,TokString "Usage: myparser <filename>",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "processFile",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "FilePath",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "processFile",TokSpace 1,TokIdent "file",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "handle",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "openFile",TokSpace 1,TokIdent "file",TokSpace 1,TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokSpace 1,TokIdent "handle",TokSpace 1,TokIdent "utf8",TokSpace 1,TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokSpace 1,TokIdent "handle",TokSymbol ";",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "putStrLn",TokSpace 1,TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "toks3",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runLexer",TokSpace 1,TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokSpace 1,TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "ast",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "program",TokSpace 1,TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokSpace 1,TokIdent "ast",TokSymbol "}",TokNewline])

=== Running: src/Parser/Core/Combinator.hs ===
-- Raw Source --
{-# LANGUAGE InstanceSigs #-}

module Parser.Core.Combinator
  ( Parser (..),
    runParser,
    satisfy,
    satisfyMap,
    token,
    tokens,
    between,
    sepBy,
    sepBy1,
    sepEndBy,
    sepEndBy1,
    try,
    chainl1,
    many1,
    manyTill,
    choice,
    choice1,
    lookAhead,
  )
where

import Control.Applicative (Alternative (..), many)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))

-- import app.MyTrace (myTrace)

-- 差分リスト風パーサー
newtype Parser a = Parser {runParser :: [Token] -> Maybe (a, [Token])}

instance Functor Parser where
  fmap :: (a -> b) -> Parser a -> Parser b
  fmap f p = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> Just (f a, rest)
      Nothing -> Nothing

instance Applicative Parser where
  pure :: a -> Parser a
  pure a = Parser $ \input -> Just (a, input)
  (<*>) :: Parser (a -> b) -> Parser a -> Parser b
  pf <*> pa = Parser $ \input ->
    case runParser pf input of
      Just (f, rest1) ->
        case runParser pa rest1 of
          Just (a, rest2) -> Just (f a, rest2)
          Nothing -> Nothing
      Nothing -> Nothing

instance Monad Parser where
  (>>=) :: Parser a -> (a -> Parser b) -> Parser b
  p >>= f = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> runParser (f a) rest
      Nothing -> Nothing

instance Alternative Parser where
  empty :: Parser a
  empty = Parser $ const Nothing
  (<|>) :: Parser a -> Parser a -> Parser a
  p1 <|> p2 = Parser $ \input ->
    runParser p1 input <|> runParser p2 input

-- 補助関数
satisfy :: (Token -> Bool) -> Parser Token
satisfy f = Parser $ \tokens -> case tokens of
  (t : ts) | f t -> Just (t, ts)
  _ -> Nothing

satisfyMap :: (Token -> Maybe a) -> Parser a
satisfyMap f = Parser $ \tokens -> case tokens of
  (t : ts) -> case f t of
    Just x -> Just (x, ts)
    Nothing -> Nothing
  [] -> Nothing

token :: Token -> Parser Token
token t = satisfy (== t)

tokens :: [Token] -> Parser [Token]
tokens expected = Parser $ \input ->
  if expected `isPrefixOf` input
    then Just (expected, drop (length expected) input)
    else Nothing

between :: Parser open -> Parser close -> Parser a -> Parser a
between open close p = do
  _ <- open
  x <- p
  _ <- close
  return x

sepBy :: Parser a -> Parser sep -> Parser [a]
sepBy p sep =
  ( do
      x <- p
      xs <- many (sep *> p)
      return (x : xs)
  )
    <|> pure []

sepBy1 :: Parser a -> Parser sep -> Parser [a]
sepBy1 p sep = do
  first <- p
  rest <- (sep *> sepBy1 p sep) <|> pure []
  return (first : rest)

sepEndBy1 :: Parser a -> Parser sep -> Parser [a]
sepEndBy1 p sep = do
  x <- p
  ( do
      _ <- sep
      xs <- sepEndBy p sep
      return (x : xs)
    )
    <|> pure [x]

sepEndBy :: Parser a -> Parser sep -> Parser [a]
sepEndBy p sep = sepEndBy1 p sep <|> pure []

try :: Parser a -> Parser a
try p = Parser $ \tokens -> runParser p tokens

chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
chainl1 p op = do
  x <- p
  rest x
  where
    rest x =
      ( do
          f <- op
          y <- p
          rest (f x y)
      )
        <|> return x

many1 :: Parser a -> Parser [a]
many1 p = (:) <$> p <*> many p

manyTill :: Parser a -> Parser end -> Parser [a]
manyTill p end = go
  where
    go =
      end
        *> pure []
          <|> (:)
        <$> p
        <*> go

choice1 :: Parser a -> Parser a -> Parser a
choice1 p q = Parser $ \input ->
  case runParser p input of
    Just r -> Just r
    Nothing -> runParser q input

choice :: [Parser a] -> Parser a
choice [] = Parser $ \_ -> Nothing
choice (p : ps) = choice1 p (choice ps)

{-}
lookAhead :: Parser a -> Parser a
lookAhead p = Parser $ \input ->
  case runParser p input of
    Just (a, _) -> Just (a, input) -- 成功しても input を消費しない
    Nothing -> Nothing
-}

lookAhead :: Parser a -> Parser a
lookAhead (Parser p) = Parser $ \input ->
  case p input of
    Just (a, _) -> Just (a, input) -- 結果はそのまま、入力は消費しない
    Nothing -> Nothing

-- 依存：symbol は TokenParser 側で定義されるため、ここでは定義しない


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "{",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "satisfy",TokSymbol ",",TokIdent "satisfyMap",TokSymbol ",",TokIdent "token",TokSymbol ",",TokIdent "tokens",TokSymbol ",",TokIdent "between",TokSymbol ",",TokIdent "sepBy",TokSymbol ",",TokIdent "sepBy1",TokSymbol ",",TokIdent "sepEndBy",TokSymbol ",",TokIdent "sepEndBy1",TokSymbol ",",TokIdent "try",TokSymbol ",",TokIdent "chainl1",TokSymbol ",",TokIdent "many1",TokSymbol ",",TokIdent "manyTill",TokSymbol ",",TokIdent "choice",TokSymbol ",",TokIdent "choice1",TokSymbol ",",TokIdent "lookAhead",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokTypeIdent "Alternative",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "many",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "newtype",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "{",TokIdent "runParser",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Functor",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "fmap",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "fmap",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Applicative",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "pure",TokSpace 1,TokSymbol "::",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "pure",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<",TokOperator "*",TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "pf",TokSpace 1,TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "pa",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "pf",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "pa",TokSpace 1,TokIdent "rest1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Monad",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokSymbol "(",TokOperator ">",TokSymbol ">=",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "p",TokSpace 1,TokOperator ">",TokSymbol ">=",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Alternative",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "empty",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "empty",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "const",TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "p1",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "p2",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "runParser",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "input",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p2",TokSpace 1,TokIdent "input",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "satisfy",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "satisfyMap",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "satisfyMap",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "token",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "token",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokSymbol "(",TokSymbol "==",TokIdent "t",TokSymbol ")",TokNewline,TokNewline,TokIdent "tokens",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokSpace 1,TokIdent "expected",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "if",TokSpace 1,TokIdent "expected",TokSpace 1,TokUnknown '`',TokIdent "isPrefixOf",TokUnknown '`',TokSpace 1,TokIdent "input",TokSymbol "{",TokKeyword "then",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "between",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "open",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "close",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "between",TokSpace 1,TokIdent "open",TokSpace 1,TokIdent "close",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "open",TokSymbol ";",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "close",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*",TokOperator ">",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepBy1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "first",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokSymbol "(",TokIdent "sep",TokOperator "*",TokOperator ">",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "first",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepEndBy1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokSymbol "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepEndBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sepEndBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokNewline,TokIdent "try",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "try",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "tokens",TokNewline,TokNewline,TokIdent "chainl1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "chainl1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "op",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "rest",TokSpace 1,TokIdent "x",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "rest",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "many1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol ")",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "p",TokSpace 1,TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "manyTill",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "end",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "end",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "end",TokSymbol "{",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol ")",TokSymbol "}",TokNewline,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "p",TokSymbol ";",TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "go",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "choice1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "choice1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "q",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "r",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "q",TokSpace 1,TokIdent "input",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "choice1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "lookAhead",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "lookAhead",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSpace 1,TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "{",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "satisfy",TokSymbol ",",TokIdent "satisfyMap",TokSymbol ",",TokIdent "token",TokSymbol ",",TokIdent "tokens",TokSymbol ",",TokIdent "between",TokSymbol ",",TokIdent "sepBy",TokSymbol ",",TokIdent "sepBy1",TokSymbol ",",TokIdent "sepEndBy",TokSymbol ",",TokIdent "sepEndBy1",TokSymbol ",",TokIdent "try",TokSymbol ",",TokIdent "chainl1",TokSymbol ",",TokIdent "many1",TokSymbol ",",TokIdent "manyTill",TokSymbol ",",TokIdent "choice",TokSymbol ",",TokIdent "choice1",TokSymbol ",",TokIdent "lookAhead",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokTypeIdent "Alternative",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "many",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "newtype",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "{",TokIdent "runParser",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Functor",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "fmap",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "fmap",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Applicative",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "pure",TokSpace 1,TokSymbol "::",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "pure",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<",TokOperator "*",TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "pf",TokSpace 1,TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "pa",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "pf",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "pa",TokSpace 1,TokIdent "rest1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Monad",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokSymbol "(",TokOperator ">",TokSymbol ">=",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "b",TokSymbol ";",TokIdent "p",TokSpace 1,TokOperator ">",TokSymbol ">=",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokKeyword "instance",TokSpace 1,TokTypeIdent "Alternative",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokKeyword "where",TokSymbol "{",TokIdent "empty",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "empty",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "const",TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol ";",TokIdent "p1",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "p2",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "runParser",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "input",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p2",TokSpace 1,TokIdent "input",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "satisfy",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "satisfyMap",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "satisfyMap",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "token",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "token",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokSymbol "(",TokSymbol "==",TokIdent "t",TokSymbol ")",TokNewline,TokNewline,TokIdent "tokens",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokSpace 1,TokIdent "expected",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "if",TokSpace 1,TokIdent "expected",TokSpace 1,TokUnknown '`',TokIdent "isPrefixOf",TokUnknown '`',TokSpace 1,TokIdent "input",TokSymbol "{",TokKeyword "then",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "between",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "open",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "close",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "between",TokSpace 1,TokIdent "open",TokSpace 1,TokIdent "close",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "open",TokSymbol ";",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "close",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*",TokOperator ">",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepBy1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "first",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokSymbol "(",TokIdent "sep",TokOperator "*",TokOperator ">",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "first",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepEndBy1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokSymbol "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "sepEndBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "sep",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sepEndBy1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "sep",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokNewline,TokNewline,TokIdent "try",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "try",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "tokens",TokNewline,TokNewline,TokIdent "chainl1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "chainl1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "op",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "rest",TokSpace 1,TokIdent "x",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "rest",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "many1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol ")",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "p",TokSpace 1,TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "manyTill",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "end",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "end",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "end",TokSymbol "{",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol ")",TokSymbol "}",TokNewline,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "p",TokSymbol ";",TokOperator "<",TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "go",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "choice1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "choice1",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "q",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "r",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "q",TokSpace 1,TokIdent "input",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "choice1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "lookAhead",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "lookAhead",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSpace 1,TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline])

=== Running: src/Parser/Core/Parser.hs ===
-- Raw Source --
-- module Parser.Core.Parser (parseExpr, runToplevelTest, runExprTest, toplevel) where
module Parser.Core.Parser (parseExpr, toplevel) where

import AST.Expr
import Control.Applicative (many, (<|>))
import Lexer.Token (Token (..))
import Lexer.Lexer (runLexer)
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (expr, letExpr)
import Parser.Expr.PatternParser
-- import Parser.Type.TypeParser

-- === 実行関数 ===

toplevel :: Parser (String, Expr)
toplevel = do
  name <- ident
  symbol "="
  body <- exprCore
  return (name, body)
{-}
parseExpr :: [Token] -> IO (Maybe Expr)
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing
-}
parseExpr :: [Token] -> Maybe (Expr, [Token])
parseExpr toks = runParser expr toks

{-}
parseExpr :: [Token] -> Maybe Expr
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> Just result
  _ -> Nothing
-}

parseToplevel :: [Token] -> IO (Maybe (String, Expr))
parseToplevel toks = case runParser toplevel toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing

{-}
-- 式のテスト
runExprTest :: ([Char], [Char]) -> IO ()
runExprTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseExpr tokens
      case result of
        Nothing -> putStrLn "  Parser error!"
        Just ast ->
          compareAST (show ast) expected

-- トップレベル定義のテスト
runToplevelTest :: ([Char], [Char]) -> IO ()
runToplevelTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseToplevel tokens
      case result of
        Nothing -> putStrLn "  Parser error!\n"
        Just (_, ast) ->
          compareAST (show ast) expected
-}

-- 共通の比較処理
compareAST actualRaw expectedRaw = do
  let normalize = filter (not . (`elem` [' ', '\n', '\t']))
      actual = normalize actualRaw
      expected = normalize expectedRaw
  if actual == expected
    then putStrLn "  O Passed\n"
    else do
      putStrLn "  X Failed!"
      putStrLn $ "     Expected: " ++ expectedRaw
      putStrLn $ "     Got:      " ++ actualRaw ++ "\n"


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "parseExpr",TokSymbol ",",TokIdent "toplevel",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSpace 1,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "letExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "toplevel",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "toplevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "parseExpr",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "expr",TokSpace 1,TokIdent "toks",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parseToplevel",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ")",TokNewline,TokIdent "parseToplevel",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "toplevel",TokSpace 1,TokIdent "toks",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "result",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "null",TokSpace 1,TokIdent "rest",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Just",TokIdent "result",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "compareAST",TokSpace 1,TokIdent "actualRaw",TokSpace 1,TokIdent "expectedRaw",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "normalize",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "filter",TokSpace 1,TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokIdent "actual",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "normalize",TokSpace 1,TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "normalize",TokSpace 1,TokIdent "expectedRaw",TokSymbol "}",TokNewline,TokKeyword "if",TokSpace 1,TokIdent "actual",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "expected",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "putStrLn",TokSpace 1,TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "putStrLn",TokSpace 1,TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "     Expected: ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "     Got:      ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "actualRaw",TokSpace 1,TokOperator "++",TokSpace 1,TokString "\n",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokIdent "parseExpr",TokSymbol ",",TokIdent "toplevel",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSpace 1,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "letExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "toplevel",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "toplevel",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "parseExpr",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "expr",TokSpace 1,TokIdent "toks",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parseToplevel",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ")",TokNewline,TokIdent "parseToplevel",TokSpace 1,TokIdent "toks",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "toplevel",TokSpace 1,TokIdent "toks",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "result",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "null",TokSpace 1,TokIdent "rest",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Just",TokIdent "result",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "compareAST",TokSpace 1,TokIdent "actualRaw",TokSpace 1,TokIdent "expectedRaw",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "normalize",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "filter",TokSpace 1,TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokIdent "actual",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "normalize",TokSpace 1,TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "normalize",TokSpace 1,TokIdent "expectedRaw",TokSymbol "}",TokNewline,TokKeyword "if",TokSpace 1,TokIdent "actual",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "expected",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "putStrLn",TokSpace 1,TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "putStrLn",TokSpace 1,TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "     Expected: ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "     Got:      ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "actualRaw",TokSpace 1,TokOperator "++",TokSpace 1,TokString "\n",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/Parser/Core/TokenParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Core.TokenParser
  ( ident,
    int,
    keyword,
    symbol,
    tokenIs,
    parens,
    brackets,
    braces,
    notFollowedBy,
    (<?>),
    anyToken,
    stringLiteralExpr,
    skipNewlines,
    skipSeparators,
    name,
    operator,
    bracedBlock,
    anyToken,
    binOp,
  )
where

import AST.Expr
import Control.Applicative (empty, many, (<|>))
import qualified Data.Set as Set
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Utils.MyTrace (myTrace)

-- import Text.Megaparsec (token, (<?>))

(<?>) :: Parser a -> String -> Parser a
p <?> _ = p

braces :: Parser a -> Parser a
braces p = between (symbol "{") (symbol "}") p

-- parens :: Parser a -> Parser a
-- parens p = between (symbol "(") (symbol ")") p
parens :: Parser a -> Parser a
parens p = do
  symbol "("
  x <- p
  symbol ")"
  return x

brackets :: Parser a -> Parser a
brackets p = between (symbol "[") (symbol "]") p

ident :: Parser String
ident = tokenIs $ \case
  TokIdent s -> Just s
  _ -> Nothing

int :: Parser Int
int = do
  t <- satisfy isNumber
  case t of
    -- TokNumber n -> myTrace ("<< int: " ++ show n) >> pure n
    TokNumber n -> pure n
    -- TokNumber n -> pure n
    _ -> empty
  where
    isNumber (TokNumber _) = True
    isNumber _ = False

keyword :: String -> Parser ()
keyword kw = do
  t <- satisfy isKeyword
  case t of
    -- TokKeyword s | s == kw -> myTrace ("<< keyword: " ++ s) >> pure ()
    TokKeyword s | s == kw -> pure ()
    _ -> empty
  where
    isKeyword (TokKeyword _) = True
    isKeyword _ = False

symbol :: String -> Parser ()
symbol s = tokenIs $ \case
  TokSymbol s' | s' == s -> Just ()
  TokOperator s' | s' == s -> Just ()
  _ -> Nothing

tokenIs :: (Token -> Maybe a) -> Parser a
tokenIs f = Parser $ \case
  (t : ts) -> case f t of
    Just a -> Just (a, ts)
    Nothing -> Nothing
  [] -> Nothing

notFollowedBy :: Parser a -> Parser ()
notFollowedBy p = Parser $ \input ->
  case runParser p input of
    Nothing -> Just ((), input) -- p が失敗 → 成功
    Just _ -> Nothing -- p が成功 → 失敗

anyToken :: Parser Token
anyToken = Parser $ \input ->
  case input of
    (t : ts) -> Just (t, ts)
    [] -> Nothing

debugPeek :: Parser ()
debugPeek = do
  t <- peekToken
  Parser $ \tokens ->
    Just ((), tokens)

peekToken :: Parser Token
peekToken = Parser $ \tokens -> case tokens of
  [] -> Nothing
  (t : _) -> Just (t, tokens)

stringLiteralExpr :: Parser String
stringLiteralExpr =
  satisfyToken f
  where
    f (TokString s) = Just s
    f _ = Nothing

satisfyToken :: (Token -> Maybe a) -> Parser a
satisfyToken f = Parser $ \ts -> case ts of
  [] -> Nothing
  (t : ts') -> case f t of
    Just x -> Just (x, ts')
    Nothing -> Nothing

skipSeparators :: Parser ()
skipSeparators = do
  _ <- many (tokenIs isSep)
  return ()
  where
    isSep TokNewline = Just ()
    isSep (TokSymbol ";") = Just ()
    isSep _ = Nothing

skipNewlines :: Parser ()
skipNewlines = do
  _ <- many (tokenIs (\t -> if t == TokNewline then Just () else Nothing))
  return ()

binOp :: [String] -> Parser (Expr -> Expr -> Expr)
binOp ops = tokenIs $ \case
  TokOperator op | op `elem` ops ->
    case parseBinOp op of
      Just bop -> Just (EBinOp bop)
      Nothing -> Nothing
  _ -> Nothing

parseBinOp :: String -> Maybe BinOp
parseBinOp s = case s of
  "+" -> Just Add
  "-" -> Just Sub
  "*" -> Just Mul
  "/" -> Just Div
  "==" -> Just Eq
  "!=" -> Just Neq
  "<" -> Just Lt
  ">" -> Just Gt
  "<=" -> Just Le
  ">=" -> Just Ge
  "&&" -> Just And
  "||" -> Just Or
  _ -> Nothing

operator :: Parser String
operator = choice (map (\s -> symbol s >> return s) allOps)
  where
    allOps =
      [ "==",
        "/=",
        ">=",
        "<=",
        "+",
        "-",
        "*",
        "/",
        ">",
        "<"
      ]

{-}
operator :: Parser String
operator = do
  symbol "("
  op <- operatorTok
  symbol ")"
  return (op)
-}

-- 関数名や演算子名をパースする共通パーサー
-- 例: "f" や "==" や "(==)"
name :: Parser String
name = try parenOp <|> ident <|> symbolOp

-- 括弧付きオペレータ: (==)
parenOp :: Parser String
parenOp = do
  symbol "("
  op <- symbolOp
  symbol ")"
  return op

-- 括弧なしのオペレータ: ==
symbolOp :: Parser String
symbolOp = do
  tok <- satisfy isSymbol
  case tok of
    TokSymbol s -> return s
    _ -> empty -- ここには来ないはずだけど、安全のため

-- 文字列がオペレータかどうか
isSymbol :: Token -> Bool
isSymbol (TokSymbol _) = True
isSymbol _ = False

bracedBlock :: Parser a -> Parser [a]
bracedBlock p = do
  symbol "{"
  go 1 []
  where
    go 0 acc = return (reverse acc)
    go n acc = do
      t <- lookAhead anyToken
      case t of
        TokSymbol "{" -> symbol "{" >> go (n + 1) acc
        TokSymbol "}" -> symbol "}" >> go (n - 1) acc
        _ -> do
          x <- p
          go n (x : acc)


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "{",TokSymbol "(",TokIdent "ident",TokSymbol ",",TokIdent "int",TokSymbol ",",TokIdent "keyword",TokSymbol ",",TokIdent "symbol",TokSymbol ",",TokIdent "tokenIs",TokSymbol ",",TokIdent "parens",TokSymbol ",",TokIdent "brackets",TokSymbol ",",TokIdent "braces",TokSymbol ",",TokIdent "notFollowedBy",TokSymbol ",",TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "stringLiteralExpr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokIdent "skipSeparators",TokSymbol ",",TokIdent "name",TokSymbol ",",TokIdent "operator",TokSymbol ",",TokIdent "bracedBlock",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "binOp",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "Set",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "p",TokSpace 1,TokOperator "<",TokUnknown '?',TokOperator ">",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "braces",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "braces",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "between",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parens",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "parens",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokNewline,TokNewline,TokIdent "brackets",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "brackets",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "between",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "ident",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "ident",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokIdent",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "int",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "int",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokNumber",TokSpace 1,TokIdent "n",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokIdent "n",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "isNumber",TokSpace 1,TokSymbol "(",TokTypeIdent "TokNumber",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "keyword",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "keyword",TokSpace 1,TokIdent "kw",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "kw",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "isKeyword",TokSpace 1,TokSymbol "(",TokTypeIdent "TokKeyword",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "symbol",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "symbol",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokTypeIdent "TokOperator",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "tokenIs",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "tokenIs",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "notFollowedBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "notFollowedBy",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSpace 1,TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSpace 1,TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "anyToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "debugPeek",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "debugPeek",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "peekToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "stringLiteralExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "satisfyToken",TokSpace 1,TokIdent "f",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokIdent "f",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "satisfyToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "satisfyToken",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts'",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "skipSeparators",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipSeparators",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "isSep",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "skipNewlines",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "binOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokSpace 1,TokIdent "ops",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokOperator",TokSpace 1,TokIdent "op",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "op",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokIdent "ops",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "parseBinOp",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "bop",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseBinOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "s",TokSpace 1,TokKeyword "of",TokSymbol "{",TokString "+",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Add",TokSymbol ";",TokString "-",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Div",TokSymbol ";",TokString "==",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "And",TokSymbol ";",TokString "||",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Or",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "operator",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "operator",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "choice",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">",TokOperator ">",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "allOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokString "==",TokSymbol ",",TokSymbol "{",TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "name",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "name",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "parenOp",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "ident",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbolOp",TokNewline,TokNewline,TokNewline,TokIdent "parenOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "op",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "op",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "symbolOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tok",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "tok",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokNewline,TokIdent "bracedBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "go",TokSpace 1,TokNumber 1,TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "acc",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokSpace 1,TokIdent "n",TokSpace 1,TokIdent "acc",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString "{",TokSpace 1,TokArrow,TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "{",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "}",TokSpace 1,TokArrow,TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "}",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "acc",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "go",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "acc",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "{",TokSymbol "(",TokIdent "ident",TokSymbol ",",TokIdent "int",TokSymbol ",",TokIdent "keyword",TokSymbol ",",TokIdent "symbol",TokSymbol ",",TokIdent "tokenIs",TokSymbol ",",TokIdent "parens",TokSymbol ",",TokIdent "brackets",TokSymbol ",",TokIdent "braces",TokSymbol ",",TokIdent "notFollowedBy",TokSymbol ",",TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "stringLiteralExpr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokIdent "skipSeparators",TokSymbol ",",TokIdent "name",TokSymbol ",",TokIdent "operator",TokSymbol ",",TokIdent "bracedBlock",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "binOp",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "Set",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline,TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "p",TokSpace 1,TokOperator "<",TokUnknown '?',TokOperator ">",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "braces",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "braces",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "between",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parens",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "parens",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "x",TokSymbol "}",TokNewline,TokNewline,TokIdent "brackets",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "brackets",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "between",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "ident",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "ident",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokIdent",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "int",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "int",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokNumber",TokSpace 1,TokIdent "n",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokIdent "n",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "isNumber",TokSpace 1,TokSymbol "(",TokTypeIdent "TokNumber",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "keyword",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "keyword",TokSpace 1,TokIdent "kw",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "kw",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "isKeyword",TokSpace 1,TokSymbol "(",TokTypeIdent "TokKeyword",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "symbol",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "symbol",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokTypeIdent "TokOperator",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "tokenIs",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "tokenIs",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "notFollowedBy",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "notFollowedBy",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSpace 1,TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSpace 1,TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "anyToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "input",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "debugPeek",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "debugPeek",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "peekToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "tokens",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "tokens",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "stringLiteralExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "satisfyToken",TokSpace 1,TokIdent "f",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokIdent "f",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "satisfyToken",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokNewline,TokIdent "satisfyToken",TokSpace 1,TokIdent "f",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts'",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "skipSeparators",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipSeparators",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "isSep",TokSpace 1,TokTypeIdent "TokNewline",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "skipNewlines",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "binOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokSpace 1,TokIdent "ops",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokOperator",TokSpace 1,TokIdent "op",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "op",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokIdent "ops",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "parseBinOp",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "bop",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseBinOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "s",TokSpace 1,TokKeyword "of",TokSymbol "{",TokString "+",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Add",TokSymbol ";",TokString "-",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Div",TokSymbol ";",TokString "==",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "And",TokSymbol ";",TokString "||",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokTypeIdent "Or",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "operator",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "operator",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "choice",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">",TokOperator ">",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "allOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokString "==",TokSymbol ",",TokSymbol "{",TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "name",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "name",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "parenOp",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "ident",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbolOp",TokNewline,TokNewline,TokNewline,TokIdent "parenOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "op",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "op",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "symbolOp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tok",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "satisfy",TokSpace 1,TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "tok",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "(",TokTypeIdent "TokSymbol",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokNewline,TokIdent "bracedBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "go",TokSpace 1,TokNumber 1,TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokNumber 0,TokSpace 1,TokIdent "acc",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokSpace 1,TokIdent "n",TokSpace 1,TokIdent "acc",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokSymbol",TokSpace 1,TokString "{",TokSpace 1,TokArrow,TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "{",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "}",TokSpace 1,TokArrow,TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "}",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokSpace 1,TokIdent "acc",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "x",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "p",TokSymbol ";",TokIdent "go",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "acc",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/Parser/Expr/CaseParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.CaseParserCore (caseExprCore) where

import AST.Expr
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

caseExprCore :: Parser Expr -> Parser Expr
caseExprCore expr = do
  keyword "case"
  scrut <- expr
  keyword "of"
  alts <-
    braces (sepBy1 (caseAlt expr) caseSep)
      <|> sepBy1 (caseAlt expr) caseSep
  return (ECase scrut alts)

caseSep :: Parser ()
caseSep =
  symbol ";"
    <|> void (token TokNewline) -- newline
    <|> lookAhead patternStart

newline :: Parser ()
newline = void (token TokNewline)

caseAlt :: Parser Expr -> Parser CaseAlt
caseAlt expr = do
  skipNewlines
  pat <- pattern
  guards <- many (guardExpr expr)
  -- guards <- many (caseGuard expr)
  case guards of
    [] -> do
      token TokArrow
      body <- expr
      return (CaseAlt pat body)
    _ ->
      return (CaseAltGuard pat guards)

guardExpr :: Parser Expr -> Parser (Expr, Expr)
guardExpr expr = do
  skipNewlines
  symbol "|"
  cond <- expr
  token TokArrow
  body <- expr
  return (cond, body)

caseGuard :: Parser Expr -> Parser (Expr, Expr)
caseGuard expr = do
  -- optional (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< caseGuard next token: " ++ show t)
  symbol "|"
  cond <- expr
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  -- token TokArrow
  body <- expr
  -- optional (token TokNewline)
  return (cond, body)

caseAltSimple :: Parser Expr -> Parser CaseAlt
caseAltSimple expr = do
  t <- lookAhead anyToken
  myTrace ("<< caseAltSimple next token: " ++ show t)
  pat <- pattern
  token TokArrow
  body <- expr
  return (CaseAlt pat body)

unguarded :: Pattern -> Parser Expr -> Parser CaseAlt
unguarded pat expr = do
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- expr
  return (CaseAlt pat body)

guarded :: Pattern -> Parser Expr -> Parser CaseAlt
guarded pat expr = do
  guards <- many1 (try (guardExpr expr))
  return (CaseAltGuard pat guards)


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSpace 1,TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "caseExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "caseExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "case",TokSymbol ";",TokIdent "scrut",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "of",TokSymbol ";",TokIdent "alts",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "braces",TokSpace 1,TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "caseSep",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseSep",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "caseSep",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSpace 1,TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "patternStart",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokNewline,TokIdent "caseAlt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "guards",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "guards",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseGuard",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseAltSimple",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "unguarded",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guarded",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "guards",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many1",TokSpace 1,TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSpace 1,TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "caseExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "caseExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "case",TokSymbol ";",TokIdent "scrut",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "of",TokSymbol ";",TokIdent "alts",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "braces",TokSpace 1,TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "caseSep",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseSep",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "caseSep",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSpace 1,TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "patternStart",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokNewline,TokIdent "caseAlt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "guards",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "guards",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseGuard",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "caseAltSimple",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "unguarded",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guarded",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "guards",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many1",TokSpace 1,TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/Parser/Expr/DoParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.DoParserCore (doExprCore) where

import AST.Expr
import Control.Applicative (empty, many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

doExprCore :: Parser Expr -> Parser Expr
doExprCore expr = do
  keyword "do"
  symbol "{"
  many (token TokNewline)
  stmts <- doBlock expr
  many (token TokNewline)
  symbol "}"
  return (EDo stmts)

doBlock :: Parser Expr -> Parser [Stmt]
doBlock expr = do
  sepBy (doStmt expr) doSemi

doStmt :: Parser Expr -> Parser Stmt
doStmt expr = do
  many (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< doStmt next token: " ++ show t)
  try (bindStmt expr)
    <|> try (letStmt expr)
    <|> ExprStmt <$> expr

bindStmt :: Parser Expr -> Parser Stmt
bindStmt expr = do
  pat <- pattern
  symbol "<-"
  e <- expr
  return (Bind pat e)

letStmt :: Parser Expr -> Parser Stmt
letStmt expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ";")
  t <- lookAhead anyToken
  myTrace ("<< letStmt:binding next token: " ++ show t)
  case t of
    TokKeyword "in" -> empty
    _ -> return (LetStmt binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)

doSemi :: Parser ()
doSemi = do
  -- optional (token TokNewline)
  symbol ";"


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSpace 1,TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "doExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "doExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "do",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "stmts",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "doBlock",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "doBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sepBy",TokSpace 1,TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "doSemi",TokSymbol "}",TokNewline,TokNewline,TokIdent "doStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "ExprStmt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "bindStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "letStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "in",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "doSemi",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "doSemi",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSpace 1,TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "doExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "doExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "do",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "stmts",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "doBlock",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "doBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sepBy",TokSpace 1,TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "doSemi",TokSymbol "}",TokNewline,TokNewline,TokIdent "doStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "ExprStmt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "bindStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "letStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "in",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "doSemi",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "doSemi",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol "}",TokNewline])

=== Running: src/Parser/Expr/ExprCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprCore
  ( exprCore,
    exprLevel1Core,
    exprLevel2Core,
    exprLevel3Core,
    appExprCore,
    atomCore,
    atomBaseCore,
    parenExprCore,
    tupleExprCore,
    oPsectionCore,
    pRecordExpr,
    lambdaExpr,
  )
where

import AST.Expr
import AST.Expr (BinOp (..), Expr (..))
import Control.Applicative (empty, many, (<|>))
import Control.Monad (guard)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.PatternParser (pattern)
import Parser.SQL.SQLParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace

pRecordExpr :: Parser Expr
pRecordExpr = do
  symbol "{"
  fields <- sepBy1 field (symbol ",")
  symbol "}"
  return (ERecord fields)

field :: Parser (String, Expr)
field = do
  name <- ident
  symbol "="
  value <- exprCore
  return (name, value)

-- ============================================
--  lambdaExpr（ExprCore に戻す）
-- ============================================

lambdaExpr :: Parser Expr
lambdaExpr = do
  symbol "\\"
  arg <- pattern
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- exprCore
  return (ELam arg body)

-- ============================================
--  exprCore（純粋な式パーサー）
-- ============================================

exprCore :: Parser Expr
exprCore = do
  t <- lookAhead anyToken
  myTrace ("<< exprCore next token: " ++ show t)
  -- guard (t /= TokKeyword "let")
  try lambdaExpr
    -- <|> void (token TokEllipsis >> return EPlaceholder)
    <|> try binOpExprCore
    <|> try parseSQL
    <|> exprLevel1Core

-- ===== 演算子階層 =====

binOpExprCore :: Parser Expr
binOpExprCore = exprCmpCore

exprCmpCore :: Parser Expr
exprCmpCore = chainl1 exprLevel1Core (binOp [">", "<", ">=", "<=", "==", "/="])

exprLevel1Core :: Parser Expr
exprLevel1Core = chainl1 exprLevel2Core (binOp ["+", "-", "++"])

exprLevel2Core :: Parser Expr
exprLevel2Core = chainl1 exprLevel3Core (binOp ["*", "/"])

exprLevel3Core :: Parser Expr
exprLevel3Core =
  try lambdaExpr
    <|> appExprCore

-- ============================================
--  関数適用
-- ============================================

appExprCore :: Parser Expr
appExprCore = do
  f <- atomCore
  args <- many atomCore
  return (foldl EApp f args)

-- ============================================
--  atom
-- ============================================

atomCore :: Parser Expr
atomCore =
  parens parenExprCore
    <|> atomBaseCore

parenExprCore :: Parser Expr
parenExprCore =
  try tupleExprCore
    <|> try oPsectionCore
    <|> exprCore

tupleExprCore :: Parser Expr
tupleExprCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< tupleExprCore next token: " ++ show t)
  e1 <- exprCore
  symbol ","
  es <- exprCore `sepBy1` symbol ","
  return (ETuple (e1 : es))

oPsectionCore :: Parser Expr
oPsectionCore =
  try (EOpSectionL <$> operator <*> exprCore)
    <|> try (EOpSectionR <$> exprCore <*> operator)

atomBaseCore :: Parser Expr
atomBaseCore = do
  t <- lookAhead anyToken
  myTrace ("<< atomBaseCore next token: " ++ show t)
  --  case t of
  --    TokKeyword "let" -> empty
  --    _ ->
  EVar <$> ident
    <|> EVarType <$> typeIdent
    <|> (ellipsis >> return EPlaceholder)
    <|> EInt <$> int
    <|> EString <$> stringLiteralExpr
    <|> pRecordExpr

ellipsis :: Parser ()
ellipsis = tokenIs (\t -> if t == TokEllipsis then Just () else Nothing)


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "{",TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprLevel1Core",TokSymbol ",",TokIdent "exprLevel2Core",TokSymbol ",",TokIdent "exprLevel3Core",TokSymbol ",",TokIdent "appExprCore",TokSymbol ",",TokIdent "atomCore",TokSymbol ",",TokIdent "atomBaseCore",TokSymbol ",",TokIdent "parenExprCore",TokSymbol ",",TokIdent "tupleExprCore",TokSymbol ",",TokIdent "oPsectionCore",TokSymbol ",",TokIdent "pRecordExpr",TokSymbol ",",TokIdent "lambdaExpr",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "pRecordExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "pRecordExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "fields",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "field",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERecord",TokIdent "fields",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "field",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "field",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "value",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "value",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "lambdaExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "lambdaExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "\\",TokSymbol ";",TokIdent "arg",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "exprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokSpace 1,TokIdent "lambdaExpr",TokSymbol "{",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "parseSQL",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "exprLevel1Core",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "binOpExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "exprCmpCore",TokNewline,TokNewline,TokIdent "exprCmpCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "lambdaExpr",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "appExprCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "appExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "atomCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "parens",TokSpace 1,TokIdent "parenExprCore",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "atomBaseCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "parenExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "tupleExprCore",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "oPsectionCore",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "exprCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "tupleExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "es",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokSymbol ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "oPsectionCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "operator",TokOperator "<",TokOperator "*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "exprCore",TokOperator "<",TokOperator "*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "atomBaseCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "EVar",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "ident",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EVarType",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokIdent "ellipsis",TokOperator ">",TokOperator ">",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EInt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "int",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EString",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pRecordExpr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "ellipsis",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "ellipsis",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "{",TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprLevel1Core",TokSymbol ",",TokIdent "exprLevel2Core",TokSymbol ",",TokIdent "exprLevel3Core",TokSymbol ",",TokIdent "appExprCore",TokSymbol ",",TokIdent "atomCore",TokSymbol ",",TokIdent "atomBaseCore",TokSymbol ",",TokIdent "parenExprCore",TokSymbol ",",TokIdent "tupleExprCore",TokSymbol ",",TokIdent "oPsectionCore",TokSymbol ",",TokIdent "pRecordExpr",TokSymbol ",",TokIdent "lambdaExpr",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "pRecordExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "pRecordExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "{",TokSymbol ";",TokIdent "fields",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "field",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERecord",TokIdent "fields",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "field",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "field",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "value",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "value",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "lambdaExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "lambdaExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "\\",TokSymbol ";",TokIdent "arg",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "exprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokSpace 1,TokIdent "lambdaExpr",TokSymbol "{",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "parseSQL",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "exprLevel1Core",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "binOpExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "exprCmpCore",TokNewline,TokNewline,TokIdent "exprCmpCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "chainl1",TokSpace 1,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokNewline,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "lambdaExpr",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "appExprCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "appExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "atomCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "parens",TokSpace 1,TokIdent "parenExprCore",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "atomBaseCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "parenExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "tupleExprCore",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "oPsectionCore",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "exprCore",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "tupleExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "es",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokSymbol ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "oPsectionCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "operator",TokOperator "<",TokOperator "*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "exprCore",TokOperator "<",TokOperator "*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "atomBaseCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "EVar",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "ident",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EVarType",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokIdent "ellipsis",TokOperator ">",TokOperator ">",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EInt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "int",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokTypeIdent "EString",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pRecordExpr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "ellipsis",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "ellipsis",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline])

=== Running: src/Parser/Expr/ExprExtensions.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprExtensions
  ( expr,
    exprTop,
    exprSeq,
    exprSep,
    letExpr,
    ifExpr,
    returnExpr,
    forExpr,
    postfix,
    skipNewlines,
  )
where

-- import Expr.CaseParserCore (caseExpr)

-- import Expr.DoParserCore (doExpr)

-- import Expr.ListParserCore (listExpr)

import AST.Expr
-- import AST.Decl
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
-- (keyword) -- , whereClause)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.CaseParserCore (caseExprCore)
import Parser.Expr.DoParserCore (doExprCore)
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ListParserCore (listExprCore)
import Parser.Expr.PatternParser (pattern)
import Parser.SQL.SQLParser
import Utils.MyTrace

expr :: Parser Expr
expr = do
  e <- exprDispatch
  postfix e
  where
    -- すべての構文の入口
    exprDispatch = do
      t <- lookAhead anyToken
      myTrace ("<< expr dispatch: " ++ show t)
      case t of
        TokKeyword "do" -> doExprCore expr
        TokKeyword "case" -> caseExprCore expr
        -- TokKeyword "let" -> (try letExpr <|> pLetExpr)
        TokKeyword "let" -> letBlock
        TokKeyword "if" -> ifExpr
        TokKeyword "for" -> forExpr
        TokKeyword "return" -> returnExpr
        TokKeyword "sql" -> parseSQL
        TokSymbol "[" -> listExprCore expr
        _ -> exprCore

letBlock :: Parser Expr
letBlock = do
  t <- lookAhead anyToken
  myTrace ("<< letBlock next token: " ++ show t)
  try letExpr <|> pLetExpr

-- letBlock = try pLetExpr <|> letExpr

{-}
-- 後置構文（where など）
postfix :: Expr -> Parser Expr
postfix e =
  try
    ( do
        skipNewlines
        -- t <- lookAhead anyToken
        -- myTrace ("<< postfix next token: " ++ show t)
        binds <- whereClause
        postfix (EWhere e binds)
    )
    <|> return e
-}

postfix :: Expr -> Parser Expr
postfix e = do
  skipNewlines
  mbBinds <- whereClause
  case mbBinds of
    Just binds -> postfix (EWhere e binds)
    Nothing -> return e

whereClause :: Parser (Maybe [Binding])
whereClause =
  try (keyword "where" >> bindings >>= \bs -> return (Just bs))
    <|> return Nothing

{-}
bindings = do
  b <- binding
  bs <- many binding
  return (b : bs)
-}
bindings :: Parser [Binding]
bindings = do
  skipNewlines
  b <- binding
  bs <- many (skipSeparators >> binding)
  return (b : bs)

-- bindings :: Parser [Binding]
-- bindings = some binding

binding :: Parser Binding
binding = try valueBinding <|> funBinding

{-}
binding :: Parser Binding
binding = do
  pat <- pattern
  _ <- symbol "="   -- ここで '=' が無ければ binding は失敗する
  val <- expr
  return (pat, val)
-}
-- ============================================
--  exprTop / exprSeq
-- ============================================

exprTop :: Parser Expr
exprTop = try exprSeq <|> expr

exprSeq :: Parser Expr
exprSeq = do
  es <- sepEndBy1 (try expr) exprSep
  return $ if length es == 1 then head es else ESeq es

exprSep :: Parser ()
exprSep = skipMany1 (symbol ";" <|> newline)

newline :: Parser ()
newline = void (token TokNewline)

skipMany1 :: Parser a -> Parser ()
skipMany1 p = p *> skipMany p

skipMany :: Parser a -> Parser ()
skipMany p = Parser $ \ts ->
  case runParser p ts of
    Just (_, ts') -> runParser (skipMany p) ts'
    Nothing -> Just ((), ts)

-- ============================================
--  let / if / return / for
-- ============================================
def :: Parser (Pattern, Expr)
def = do
  p <- pattern
  symbol "="
  e <- expr
  return (p, e)

ifExpr :: Parser Expr
ifExpr = do
  keyword "if"
  cond <- expr
  keyword "then"
  th <- expr
  keyword "else"
  el <- expr
  return (EIf cond th el)

returnExpr :: Parser Expr
returnExpr = do
  keyword "return"
  e <- expr
  return (EReturn e)

forExpr :: Parser Expr
forExpr = do
  keyword "for"
  qs <- sepBy1 qualifier (symbol ",")
  token TokArrow
  body <- expr
  return (EListComp body qs)

qualifier :: Parser Qualifier
qualifier =
  try genQualifier
    <|> guardQualifier

genQualifier :: Parser Qualifier
genQualifier = do
  pat <- pattern
  keyword "in"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Qualifier
guardQualifier = QGuard <$> expr

{-}
funDecl :: Parser Decl
funDecl = do
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  return (FunDecl name args body)
-}

-- binding = try funBinding <|> valueBinding
{-}
funBinding :: Parser Binding
funBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (PApp (PVar name) args, body)
-}

funBinding :: Parser Binding
funBinding = do
  optional newline
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  -- 次のトークンが "=" なら funBinding ではない
  next <- lookAhead anyToken
  if next == TokOperator "="
    then empty -- ← guard の代わりに empty を使う
    else return ()
  args <- many pattern
  symbol "="
  body <- expr
  return (PApp (PVar name) args, body)

valueBinding :: Parser Binding
valueBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< valueBinding next token: " ++ show t)
  pat <- pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (pat, body)

{-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  -- myTrace ("<< letExpr")
  binds <- bindingsBlock
  optional (newline)
  mIn <- optional (keyword "in")
  optional (newline)
  case mIn of
    Just _ -> do
      body <- expr
      return (ELet binds body)
    Nothing ->
      return (ELet binds (EVar "__unit__"))
-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< letExpr next token: " ++ show t)
  binds <- bindingsBlock
  optional newline
  mIn <- optional (keyword "in")
  optional newline
  case mIn of
    Just _ -> do
      body <- expr
      return (ELetBlock binds body)
    Nothing ->
      if null binds
        then empty -- ← これが正しい
        else return (ELetBlock binds (EVar "__unit__"))

{-}
  case mIn of
    Just _ -> do
      body <- expr
      return (ELetBlock binds body)
    Nothing ->
      return (ELetBlock binds (EVar "__unit__"))
-}

pLetExpr :: Parser Expr
pLetExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< pLetExpr next token: " ++ show t)
  pat <- pattern
  symbol "="
  e1 <- expr
  keyword "in"
  e2 <- expr
  return (ELet pat e1 e2)

bindingsBlock :: Parser [Binding]
bindingsBlock = do
  -- optional (token TokNewline)
  braces (sepBy binding (symbol ";"))
    <|> sepBy binding (symbol ";")

{-}
whereClause :: Parser [Binding]
whereClause = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< whereClause next token: " ++ show t)
  keyword "where"
  bindingsBlock
-}


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "{",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokIdent "letExpr",TokSymbol ",",TokIdent "ifExpr",TokSymbol ",",TokIdent "returnExpr",TokSymbol ",",TokIdent "forExpr",TokSymbol ",",TokIdent "postfix",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSpace 1,TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSpace 1,TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSpace 1,TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "expr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokSymbol ";",TokIdent "exprDispatch",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "do",TokSpace 1,TokArrow,TokSpace 1,TokIdent "doExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "case",TokSpace 1,TokArrow,TokSpace 1,TokIdent "caseExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "let",TokSpace 1,TokArrow,TokSpace 1,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "if",TokSpace 1,TokArrow,TokSpace 1,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "for",TokSpace 1,TokArrow,TokSpace 1,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "return",TokSpace 1,TokArrow,TokSpace 1,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "sql",TokSpace 1,TokArrow,TokSpace 1,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "[",TokSpace 1,TokArrow,TokSpace 1,TokIdent "listExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "exprCore",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "letBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSpace 1,TokIdent "letExpr",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pLetExpr",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "postfix",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokSpace 1,TokIdent "e",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "mbBinds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "mbBinds",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "binds",TokSpace 1,TokArrow,TokSpace 1,TokIdent "postfix",TokSpace 1,TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "e",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "whereClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">",TokOperator ">",TokIdent "bindings",TokOperator ">",TokSymbol ">=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "bindings",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "b",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "skipSeparators",TokOperator ">",TokOperator ">",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "b",TokSymbol ":",TokIdent "bs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "binding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "valueBinding",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "funBinding",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "exprTop",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "exprSeq",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokIdent "exprSeq",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "es",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepEndBy1",TokSpace 1,TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "if",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "==",TokSpace 1,TokNumber 1,TokSpace 1,TokKeyword "then",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "es",TokSpace 1,TokKeyword "else",TokSpace 1,TokTypeIdent "ESeq",TokSpace 1,TokIdent "es",TokSymbol "}",TokNewline,TokNewline,TokIdent "exprSep",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "exprSep",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipMany1",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokIdent "newline",TokSymbol ")",TokNewline,TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokNewline,TokIdent "skipMany1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "p",TokSpace 1,TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "skipMany",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "skipMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokSpace 1,TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "def",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "ifExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "if",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "then",TokSymbol ";",TokIdent "th",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "else",TokSymbol ";",TokIdent "el",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "returnExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "return",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "forExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "for",TokSymbol ";",TokIdent "qs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "qualifier",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "genQualifier",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "guardQualifier",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "funBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokSpace 1,TokIdent "next",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "=",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "valueBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "letExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokIdent "mIn",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "mIn",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "if",TokSpace 1,TokIdent "null",TokSpace 1,TokIdent "binds",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "pLetExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "e2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "bindingsBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "braces",TokSpace 1,TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "sepBy",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "{",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokIdent "letExpr",TokSymbol ",",TokIdent "ifExpr",TokSymbol ",",TokIdent "returnExpr",TokSymbol ",",TokIdent "forExpr",TokSymbol ",",TokIdent "postfix",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSpace 1,TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSpace 1,TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSpace 1,TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "expr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokSymbol ";",TokIdent "exprDispatch",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "do",TokSpace 1,TokArrow,TokSpace 1,TokIdent "doExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "case",TokSpace 1,TokArrow,TokSpace 1,TokIdent "caseExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "let",TokSpace 1,TokArrow,TokSpace 1,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "if",TokSpace 1,TokArrow,TokSpace 1,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "for",TokSpace 1,TokArrow,TokSpace 1,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "return",TokSpace 1,TokArrow,TokSpace 1,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokSpace 1,TokString "sql",TokSpace 1,TokArrow,TokSpace 1,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokSpace 1,TokString "[",TokSpace 1,TokArrow,TokSpace 1,TokIdent "listExprCore",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "exprCore",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "letBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSpace 1,TokIdent "letExpr",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pLetExpr",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "postfix",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokSpace 1,TokIdent "e",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "mbBinds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "mbBinds",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "binds",TokSpace 1,TokArrow,TokSpace 1,TokIdent "postfix",TokSpace 1,TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "e",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "whereClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">",TokOperator ">",TokIdent "bindings",TokOperator ">",TokSymbol ">=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "bindings",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "skipNewlines",TokSymbol ";",TokIdent "b",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokSymbol "(",TokIdent "skipSeparators",TokOperator ">",TokOperator ">",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "b",TokSymbol ":",TokIdent "bs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "binding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "valueBinding",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "funBinding",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "exprTop",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "exprSeq",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokIdent "exprSeq",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "es",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepEndBy1",TokSpace 1,TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokSpace 1,TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "if",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "==",TokSpace 1,TokNumber 1,TokSpace 1,TokKeyword "then",TokSpace 1,TokIdent "head",TokSpace 1,TokIdent "es",TokSpace 1,TokKeyword "else",TokSpace 1,TokTypeIdent "ESeq",TokSpace 1,TokIdent "es",TokSymbol "}",TokNewline,TokNewline,TokIdent "exprSep",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "exprSep",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "skipMany1",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokIdent "newline",TokSymbol ")",TokNewline,TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokNewline,TokIdent "skipMany1",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany1",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "p",TokSpace 1,TokOperator "*",TokOperator ">",TokSpace 1,TokIdent "skipMany",TokSpace 1,TokIdent "p",TokNewline,TokNewline,TokIdent "skipMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "runParser",TokSpace 1,TokIdent "p",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokIdent "runParser",TokSpace 1,TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokSpace 1,TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "def",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "ifExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "if",TokSymbol ";",TokIdent "cond",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "then",TokSymbol ";",TokIdent "th",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "else",TokSymbol ";",TokIdent "el",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "returnExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "return",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "forExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "for",TokSymbol ";",TokIdent "qs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "qualifier",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokIdent "genQualifier",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "guardQualifier",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "funBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokSpace 1,TokIdent "next",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TokOperator",TokSpace 1,TokString "=",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "valueBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "letExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokIdent "mIn",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSpace 1,TokIdent "newline",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "mIn",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "if",TokSpace 1,TokIdent "null",TokSpace 1,TokIdent "binds",TokSymbol "{",TokKeyword "then",TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokKeyword "else",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "pLetExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokIdent "e2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "bindingsBlock",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokIdent "braces",TokSpace 1,TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "sepBy",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline])

=== Running: src/Parser/Expr/ExprParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprParser
  ( exprCore,
    exprTop,
    exprSeq,
    exprSep,
  )
where

import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (exprSep, exprSeq, exprTop)

-- import Parser.SQL.SQLParser

-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprParser",TokSymbol "{",TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "exprSep",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprTop",TokSymbol ")",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprParser",TokSymbol "{",TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSpace 1,TokSymbol "(",TokIdent "exprSep",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprTop",TokSymbol ")",TokNewline,TokNewline])

=== Running: src/Parser/Expr/ListParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ListParserCore (listExprCore) where

import AST.Expr
import Control.Applicative (many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser (pattern)
import Utils.MyTrace

listExprCore :: Parser Expr -> Parser Expr
listExprCore expr =
  brackets $
    try (listCompExpr expr) -- ★ 最優先
      <|> try (stepRangeExpr expr)
      <|> try (rangeExpr expr)
      <|> listLiteralExpr expr

-- [a, b .. c]
stepRangeExpr :: Parser Expr -> Parser Expr
stepRangeExpr expr = do
  start <- exprCore
  symbol ","
  step <- exprCore
  symbol ".."
  end <- exprCore
  return (ERangeStep start step end)

-- [a .. b]
rangeExpr :: Parser Expr -> Parser Expr
rangeExpr expr = do
  start <- exprCore
  symbol ".."
  end <- exprCore
  return (ERange start end)

-- [a, b, c]
listLiteralExpr :: Parser Expr -> Parser Expr
listLiteralExpr expr = do
  elems <- sepBy exprCore (symbol ",")
  optional (symbol ",")
  return (EList elems)

-- [x | ...]
listCompExpr :: Parser Expr -> Parser Expr
listCompExpr expr = do
  body <- exprCore
  symbol "|"
  qs <- sepBy1 (qualifier expr) (symbol ",")
  return (EListComp body qs)

qualifier :: Parser Expr -> Parser Qualifier
qualifier expr =
  try (genQualifier expr) -- ★ 最優先
    <|> try (letQualifier expr)
    <|> guardQualifier expr

genQualifier :: Parser Expr -> Parser Qualifier
genQualifier expr = do
  pat <- pattern
  symbol "<-"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Expr -> Parser Qualifier
guardQualifier expr = QGuard <$> expr

{-}
letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QGuard (ELet binds (EVar "__unit__")))
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)
-}

letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QLet binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSpace 1,TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "listExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "brackets",TokSpace 1,TokUnknown '$',TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "listLiteralExpr",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "stepRangeExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "start",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "step",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "..",TokSymbol ";",TokIdent "end",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "rangeExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "start",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "..",TokSymbol ";",TokIdent "end",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "listLiteralExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "elems",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy",TokSpace 1,TokIdent "exprCore",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "listCompExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "qs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "guardQualifier",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "letQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSpace 1,TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSpace 1,TokSymbol "(",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<",TokSymbol "|",TokOperator ">",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSpace 1,TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokIdent "listExprCore",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listExprCore",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "brackets",TokSpace 1,TokUnknown '$',TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "listLiteralExpr",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "stepRangeExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "start",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "step",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "..",TokSymbol ";",TokIdent "end",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "rangeExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "start",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "..",TokSymbol ";",TokIdent "end",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "listLiteralExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "elems",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy",TokSpace 1,TokIdent "exprCore",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "listCompExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol ";",TokIdent "qs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "qualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "guardQualifier",TokSpace 1,TokIdent "expr",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "genQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "<-",TokSymbol ";",TokIdent "src",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "guardQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "QGuard",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "expr",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "letQualifier",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokIdent "binds",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "binding",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "binding",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "=",TokSymbol ";",TokIdent "e",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/Parser/Expr/PatternParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.PatternParser
  ( pattern,
    patternParser,
    patternStart,
    pConstrOrVar,
    patternVar,
    constraintP,
    pParenOrTuple,
    pList,
    pWildcard,
    pInt,
  )
where

import AST.Pattern
import Control.Applicative
import Data.Char (isUpper)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace (myTrace)

patternParser :: Parser Pattern
patternParser = do
  p <- pAs <|> makeCons
  myTrace ("<< patternParser: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

pattern :: Parser Pattern
pattern = do
  p <- pAs <|> makeCons
  myTrace ("<< pattern1: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

patternStart :: Parser ()
patternStart =
  void (symbol "_")
    <|> void ident
    <|> void typeIdent
    <|> void int
    <|> void (symbol "(")

stopPattern :: Parser ()
stopPattern =
  lookAhead $
    symbol "|"
      <|> void (token TokArrow)
      <|> void (token TokNewline)
      <|> symbol ";"
      <|> symbol "}"
      <|> keyword "in"
      <|> keyword "for"
      <|> keyword "return"
      <|> keyword "case"
      <|> keyword "let"
      <|> keyword "if"
      <|> keyword "do"
      <|> eof

eof :: Parser ()
eof = Parser $ \ts ->
  case ts of
    [] -> Just ((), [])
    _ -> Nothing

makeCons :: Parser Pattern
makeCons = do
  p <- makeApp
  rest p
  where
    rest p =
      ( do
          symbol ":"
          p2 <- makeCons
          return (PCons p p2)
      )
        <|> return p

makeApp :: Parser Pattern
makeApp = do
  p <- pAtom
  ps <- many pAtom
  return (PApp p ps)

pAtom :: Parser Pattern
pAtom = do
  t <- lookAhead anyToken
  case t of
    TokKeyword _ -> empty -- ★ キーワードはパターンにならない
    _ -> pure ()
  pAs
    <|> pList
    <|> pParenOrTuple
    <|> pConstrOrVar
    <|> pInt
    <|> (symbol "_" >> return PWildcard)

pAs :: Parser Pattern
pAs = do
  name <- ident
  symbol "@"
  pat <- pAtom
  return (PAs name pat)

pConstrOrVar :: Parser Pattern
pConstrOrVar =
  do
    patternVar
    <|> constraintP

patternVar :: Parser Pattern
patternVar = tokenIs $ \case
  TokIdent name -> Just (PVar name)
  -- TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

constraintP :: Parser Pattern
constraintP = tokenIs $ \case
  -- TokIdent name -> Just (PVar name)
  TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

isKeyword :: String -> Bool
isKeyword s =
  s
    `elem` [ "case",
             "of",
             "let",
             "in",
             "if",
             "then",
             "else",
             "do",
             "return"
           ]

isIdentOnly :: Token -> Bool
isIdentOnly (TokIdent _) = True
isIdentOnly _ = False

pParenOrTuple :: Parser Pattern
pParenOrTuple = parens $ do
  pats <- pattern `sepBy1` symbol ","
  return $ case pats of
    [single] -> single
    _ -> PTuple pats

pList :: Parser Pattern
pList = PList <$> brackets (pattern `sepBy` symbol ",")

pWildcard :: Parser Pattern
pWildcard = symbol "_" >> return PWildcard

pInt :: Parser Pattern
pInt = PInt <$> int


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "{",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ",",TokIdent "patternStart",TokSymbol ",",TokIdent "pConstrOrVar",TokSymbol ",",TokIdent "patternVar",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "pParenOrTuple",TokSymbol ",",TokIdent "pList",TokSymbol ",",TokIdent "pWildcard",TokSymbol ",",TokIdent "pInt",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokNewline,TokIdent "patternParser",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "patternParser",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAs",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokNewline,TokNewline,TokIdent "pattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAs",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokNewline,TokNewline,TokIdent "patternStart",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "patternStart",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "ident",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "int",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "stopPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "stopPattern",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "lookAhead",TokSpace 1,TokUnknown '$',TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "for",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "return",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "case",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "if",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "do",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "eof",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "eof",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "eof",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "makeCons",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "rest",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "makeApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "pAtom",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "pAs",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pList",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pInt",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">",TokOperator ">",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "pAs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "@",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "pConstrOrVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "do",TokSymbol "{",TokIdent "patternVar",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "constraintP",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "patternVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "isKeyword",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "s",TokSymbol "{",TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokSymbol "[",TokSpace 1,TokString "case",TokSymbol ",",TokSymbol "{",TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "(",TokTypeIdent "TokIdent",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokNewline,TokIdent "pParenOrTuple",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "parens",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pats",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pats",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "single",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "single",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "PTuple",TokSpace 1,TokIdent "pats",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "pList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "PList",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "brackets",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy",TokUnknown '`',TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokNewline,TokIdent "pWildcard",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "_",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "PWildcard",TokNewline,TokNewline,TokIdent "pInt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "PInt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "int",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "{",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ",",TokIdent "patternStart",TokSymbol ",",TokIdent "pConstrOrVar",TokSymbol ",",TokIdent "patternVar",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "pParenOrTuple",TokSymbol ",",TokIdent "pList",TokSymbol ",",TokIdent "pWildcard",TokSymbol ",",TokIdent "pInt",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSpace 1,TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSpace 1,TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokNewline,TokIdent "patternParser",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "patternParser",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAs",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokNewline,TokNewline,TokIdent "pattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAs",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokNewline,TokNewline,TokIdent "patternStart",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "patternStart",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "ident",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokIdent "int",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "stopPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "stopPattern",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "lookAhead",TokSpace 1,TokUnknown '$',TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "|",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "void",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ";",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "}",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "in",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "for",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "return",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "case",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "let",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "if",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "do",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "eof",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "eof",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "eof",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "makeCons",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "rest",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "p",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "makeApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "p",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "pAtom",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSpace 1,TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "pAs",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pList",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "pInt",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">",TokOperator ">",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "pAs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "name",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString "@",TokSymbol ";",TokIdent "pat",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "pConstrOrVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "do",TokSymbol "{",TokIdent "patternVar",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "constraintP",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "patternVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "tokenIs",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokSymbol ";",TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "name",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "isKeyword",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "s",TokSymbol "{",TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokSymbol "[",TokSpace 1,TokString "case",TokSymbol ",",TokSymbol "{",TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Token",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "(",TokTypeIdent "TokIdent",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokNewline,TokIdent "pParenOrTuple",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "parens",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "pats",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "pattern",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pats",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "single",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "single",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "PTuple",TokSpace 1,TokIdent "pats",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "pList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "PList",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "brackets",TokSpace 1,TokSymbol "(",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy",TokUnknown '`',TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokNewline,TokIdent "pWildcard",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "symbol",TokSpace 1,TokString "_",TokSpace 1,TokOperator ">",TokOperator ">",TokSpace 1,TokKeyword "return",TokSpace 1,TokTypeIdent "PWildcard",TokNewline,TokNewline,TokIdent "pInt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "PInt",TokSpace 1,TokOperator "<",TokUnknown '$',TokOperator ">",TokSpace 1,TokIdent "int",TokNewline])

=== Running: src/Parser/SQL/SQLParser.hs ===
-- Raw Source --
module Parser.SQL.SQLParser (parseSQL) where

import AST.Expr -- (Expr (..))

-- {var} 抽出用（後で作る）
import Parser.Core.Combinator
import Parser.Core.TokenParser
-- import Parser.Expr.ExprCore
import Utils.SQLUtils

parseSQL :: Parser Expr
parseSQL = do
  _ <- keyword "sql"
  sqlText <- stringLiteralExpr
  let (sqlBody, vars) = extractSQLVars sqlText
  return (ESQL sqlBody (map EVar vars))


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokSpace 1,TokSymbol "(",TokIdent "parseSQL",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokNewline,TokNewline,TokIdent "parseSQL",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "parseSQL",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "sql",TokSymbol ";",TokIdent "sqlText",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "stringLiteralExpr",TokSymbol ";",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "sqlBody",TokSymbol ",",TokIdent "vars",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extractSQLVars",TokSpace 1,TokIdent "sqlText",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ESQL",TokIdent "sqlBody",TokSymbol "(",TokIdent "map",TokTypeIdent "EVar",TokIdent "vars",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokSpace 1,TokSymbol "(",TokIdent "parseSQL",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokNewline,TokNewline,TokIdent "parseSQL",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Expr",TokNewline,TokIdent "parseSQL",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "keyword",TokSpace 1,TokString "sql",TokSymbol ";",TokIdent "sqlText",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "stringLiteralExpr",TokSymbol ";",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "sqlBody",TokSymbol ",",TokIdent "vars",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extractSQLVars",TokSpace 1,TokIdent "sqlText",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "ESQL",TokIdent "sqlBody",TokSymbol "(",TokIdent "map",TokTypeIdent "EVar",TokIdent "vars",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/Parser/Type/TypeParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Type.TypeParser
  ( parseType,
    parseForall,
    arrowType,
    typeApp,
    typeAtom,
    typeIdent,
    constraintP,
    constraintList,
    typeP,
  )
where

import AST.Decl
import AST.Expr
import AST.Type
import Control.Applicative
import Data.Char (isUpper)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Utils.MyTrace

{-}
parseType :: Parser Type
parseType = try constrainedType <|> parseForall <|> arrowType
-}

parseType :: Parser Type
parseType = do
  t1 <- arrowType
  rest <-
    optional
      ( do
          token (TokKeyword "=>")
          t2 <- parseType
          return (t1, t2)
      )
  case rest of
    Just (TApp (TCon cls) arg, body) ->
      return $ TConstraint [Constraint cls [arg]] body
    Just (TCon cls, body) ->
      return $ TConstraint [Constraint cls []] body
    Just (TTuple cs, body) ->
      return $ TConstraint (map toConstraint cs) body
    Nothing -> return t1
    _ -> empty

arrowType :: Parser Type
arrowType = do
  t <- lookAhead anyToken
  myTrace ("<< arrowType: next token " ++ show t)
  t1 <- typeApp
  rest <- optional (token TokArrow *> arrowType)
  return $ maybe t1 (TFun t1) rest

parensWithConstraints :: Parser Type
parensWithConstraints = do
  symbol "("
  ts <- parseType `sepBy1` symbol ","
  next <- lookAhead anyToken
  myTrace ("<< parensWithConstraints: parsed " ++ show ts ++ ", lookAhead: " ++ show next)
  case next of
    TokKeyword "=>" -> do
      token (TokKeyword "=>")
      ty <- parseType
      symbol ")" -- ← ここで閉じる！
      let constraints = map toConstraint ts
      return $ TConstraint constraints ty
    _ -> do
      symbol ")" -- ← 通常の型やタプルとして閉じる
      return $ case ts of
        [t] -> t
        _ -> TTuple ts

toConstraint :: Type -> Constraint
toConstraint (TApp (TCon cls) arg) = (Constraint cls [arg])
toConstraint (TCon cls) = (Constraint cls [])
toConstraint other = error $ "Invalid constraint form: " ++ show other

typeApp :: Parser Type
typeApp = do
  f <- typeAtom
  args <- many typeAtom
  return $ foldl TApp f args

typeAtom :: Parser Type
typeAtom = do
  (TCon <$> typeIdent)
    <|> (TVar <$> ident)
    <|> brackets (TList <$> parseType)
    <|> parensWithConstraints

{-}
-- <|> parens typeInParens

typeInParens :: Parser Type
typeInParens = do
  myTrace ("<< typeInParens:")
  ts <- parseType `sepBy1` symbol ","
  return $ case ts of
    [t] -> t
    _ -> TTuple ts
-}

constrainedType :: Parser Type
constrainedType = do
  symbol "("
  cs <- sepBy1 constraint (symbol ",")
  symbol ")"
  keyword "=>"
  ty <- arrowType
  return (TConstraint cs ty)

parseForall :: Parser Type
parseForall = do
  token TokForall
  vars <- some ident
  token TokDot
  body <- parseType
  return $ TForall vars body

typeIdent :: Parser String
typeIdent = satisfyMap $ \case
  TokTypeIdent s -> Just s
  _ -> Nothing

constraint :: Parser Constraint
constraint = do
  cls <- ident
  ty <- typeApp
  return (Constraint cls [ty])

constraintP :: Parser Constraint
constraintP = do
  className <- typeIdent
  args <- some typeAtom
  return $ Constraint className args

constraintList :: Parser [Constraint]
constraintList = do
  try (parens (constraintP `sepBy1` symbol ","))
    <|> fmap (: []) constraintP

typeP :: Parser Type
typeP = try forallType <|> typeAtom

forallType :: Parser Type
forallType = do
  token TokForall
  vars <- some ident
  token TokDot
  t <- constrainedType
  return (TForall vars t)

{-}
parseType :: Parser Type
parseType =
  try constrainedType
    <|> parseForall
    <|> arrowType

parseForall :: Parser Type
parseForall = do
  token TokForall
  vars <- some ident
  token TokDot
  body <- parseType
  return $ TForall vars body

arrowType :: Parser Type
arrowType = do
  t1 <- typeP
  rest <- optional (token TokArrow *> arrowType)
  return $ maybe t1 (TArrow t1) rest

typeApp :: Parser Type
typeApp = do
  f <- typeAtom
  args <- many typeAtom
  return $ foldl TApp f args

typeAtom :: Parser Type
typeAtom =
  (TCon <$> typeIdent)
    <|> (TVar <$> ident)
    <|> brackets (TList <$> typeP)
    <|> parens typeP

-- tupleOrParens

-- <|> constrainedType

tupleOrParens :: Parser Type
tupleOrParens = do
  ts <- typeAtom `sepBy1` symbol ","
  return $ case ts of
    [t] -> t
    _ -> TTuple ts

constrainedType :: Parser Type
constrainedType = do
  symbol "("
  cs <- sepBy1 constraint (symbol ",")
  symbol ")"
  symbol "=>"
  ty <- arrowType
  return (TConstraint cs ty)

-}
{-}
constrainedType :: Parser Type
constrainedType = do
  constraints <- optional $ try $ do
    cs <- constraintList
    keyword "=>"
    return cs
  t <- arrowType
  return $ maybe t (`TConstraint` t) constraints
-}


-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "{",TokSymbol "(",TokIdent "parseType",TokSymbol ",",TokIdent "parseForall",TokSymbol ",",TokIdent "arrowType",TokSymbol ",",TokIdent "typeApp",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "constraintList",TokSymbol ",",TokIdent "typeP",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parseType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parseType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "arrowType",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "optional",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokIdent "t2",TokSymbol "<-",TokIdent "parseType",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "case",TokSpace 1,TokIdent "rest",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "]",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "t1",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "arrowType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< arrowType: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "t1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeApp",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokOperator "*",TokOperator ">",TokIdent "arrowType",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "maybe",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "parensWithConstraints",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parensWithConstraints",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "ts",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "next",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< parensWithConstraints: parsed ",TokOperator "++",TokIdent "show",TokIdent "ts",TokOperator "++",TokString ", lookAhead: ",TokOperator "++",TokIdent "show",TokIdent "next",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "next",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "constraints",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "toConstraint",TokSpace 1,TokIdent "ts",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokIdent "constraints",TokSpace 1,TokIdent "ty",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "t",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "t",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSpace 1,TokIdent "other",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "error",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "Invalid constraint form: ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "show",TokSpace 1,TokIdent "other",TokNewline,TokNewline,TokIdent "typeApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "foldl",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "args",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeAtom",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "typeIdent",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "brackets",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "parseType",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "parensWithConstraints",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "constrainedType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "cs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "constraint",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "=>",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseForall",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeIdent",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "satisfyMap",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "cls",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokIdent "className",TokSpace 1,TokIdent "args",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "fmap",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSpace 1,TokIdent "constraintP",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "forallType",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "typeAtom",TokNewline,TokNewline,TokIdent "forallType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "{",TokSymbol "(",TokIdent "parseType",TokSymbol ",",TokIdent "parseForall",TokSymbol ",",TokIdent "arrowType",TokSymbol ",",TokIdent "typeApp",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "constraintList",TokSymbol ",",TokIdent "typeP",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSpace 1,TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSpace 1,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "parseType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parseType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "arrowType",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "optional",TokSymbol "{",TokSymbol "(",TokKeyword "do",TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokIdent "t2",TokSymbol "<-",TokIdent "parseType",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "case",TokSpace 1,TokIdent "rest",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol "]",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Just",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "t1",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "empty",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "arrowType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< arrowType: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "t1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeApp",TokSymbol ";",TokIdent "rest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "optional",TokSpace 1,TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokOperator "*",TokOperator ">",TokIdent "arrowType",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "maybe",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokNewline,TokIdent "parensWithConstraints",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parensWithConstraints",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "ts",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSpace 1,TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokSpace 1,TokIdent "symbol",TokSpace 1,TokString ",",TokSymbol ";",TokIdent "next",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "lookAhead",TokSpace 1,TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSpace 1,TokSymbol "(",TokString "<< parensWithConstraints: parsed ",TokOperator "++",TokIdent "show",TokIdent "ts",TokOperator "++",TokString ", lookAhead: ",TokOperator "++",TokIdent "show",TokIdent "next",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "next",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TokKeyword",TokSpace 1,TokString "=>",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "constraints",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "toConstraint",TokSpace 1,TokIdent "ts",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokIdent "constraints",TokSpace 1,TokIdent "ty",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString ")",TokSpace 1,TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokIdent "t",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "t",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSpace 1,TokIdent "other",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "error",TokSpace 1,TokUnknown '$',TokSpace 1,TokString "Invalid constraint form: ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "show",TokSpace 1,TokIdent "other",TokNewline,TokNewline,TokIdent "typeApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "f",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "many",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokIdent "foldl",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokIdent "f",TokSpace 1,TokIdent "args",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeAtom",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "typeIdent",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "brackets",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokOperator "<",TokUnknown '$',TokOperator ">",TokIdent "parseType",TokSymbol ")",TokSymbol ";",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "parensWithConstraints",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "constrainedType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "symbol",TokSpace 1,TokString "(",TokSymbol ";",TokIdent "cs",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "sepBy1",TokSpace 1,TokIdent "constraint",TokSpace 1,TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokSpace 1,TokString ")",TokSymbol ";",TokIdent "keyword",TokSpace 1,TokString "=>",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "parseForall",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeIdent",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "satisfyMap",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokKeyword "case",TokSymbol "{",TokTypeIdent "TokTypeIdent",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Just",TokSpace 1,TokIdent "s",TokSymbol ";",TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Nothing",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "cls",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "className",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSpace 1,TokUnknown '$',TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokIdent "className",TokSpace 1,TokIdent "args",TokSymbol "}",TokNewline,TokNewline,TokIdent "constraintList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "try",TokSpace 1,TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokUnknown '`',TokIdent "sepBy1",TokUnknown '`',TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokSymbol "{",TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "fmap",TokSpace 1,TokSymbol "(",TokSymbol ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSpace 1,TokIdent "constraintP",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "typeP",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "try",TokSpace 1,TokIdent "forallType",TokSpace 1,TokOperator "<",TokSymbol "|",TokOperator ">",TokSpace 1,TokIdent "typeAtom",TokNewline,TokNewline,TokIdent "forallType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "token",TokSpace 1,TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "some",TokSpace 1,TokIdent "ident",TokSymbol ";",TokIdent "token",TokSpace 1,TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Error.hs ===
-- Raw Source --
module TypeInference.Error where

import AST.Type (Type (..))
import TypeInference.Unify (UnifyError)

-- 型推論全体で使うエラー型
data InferError
  = InferUnboundVariable String
  | InferMismatch Type Type
  | InferUnifyError UnifyError
  | InferOther String
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "InferError",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "InferUnboundVariable",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferMismatch",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferUnifyError",TokSpace 1,TokTypeIdent "UnifyError",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferOther",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "InferError",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "InferUnboundVariable",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferMismatch",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferUnifyError",TokSpace 1,TokTypeIdent "UnifyError",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "InferOther",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Core - 繧ｳ繝斐ｼ.hs ===
-- Raw Source --
module TypeInference.Infer
  ( InferError (..),
    inferExpr,
    inferDecl,
    inferProgram,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    applyEnv,
    emptyEnv,
    extendEnv,
    freeTypeVars,
    freeTypeVarsEnv,
    generalize,
    instantiate,
    lookupEnv,
  )
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr の返り値：型と代入
type InferResult = (Subst, Type)

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

inferBindings :: TypeEnv -> [(Pattern, Expr)] -> Either InferError (Subst, TypeEnv)
inferBindings env [] = Right (emptySubst, emptyEnv)
inferBindings env ((pat, expr) : rest) = do
  -- パターン推論
  (sPat, envPat, tPat) <- inferPattern pat

  -- 右辺の推論
  (sExpr, tExpr) <- inferExpr (applyEnv sPat env) expr

  -- パターン型と右辺型を unify（エラー型を変換）
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su

  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat

  -- 残りの束縛
  (sRest, envRest) <- inferBindings (applyEnv s env) rest

  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest

  Right (sFinal, envFinal)

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s

    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

-- 式の型推論（まだ中身は空）
-- inferExpr :: TypeEnv -> Expr -> Either InferError InferResult
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (ELetBlock binds body) = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

-- SQL
inferExpr env (ESQL _ params) = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, tParam) <- inferExpr envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)

-- 1. 変数
inferExpr env (EVar x) =
  case lookupEnv env x of
    Nothing -> Left (InferUnboundVariable x)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- 2. 整数リテラル
inferExpr env (EInt _) =
  Right (emptySubst, TCon "Int")
-- 3. ブールリテラル
inferExpr env (EBool _) =
  Right (emptySubst, TCon "Bool")
-- 4. 文字列リテラル
inferExpr env (EString _) =
  Right (emptySubst, TCon "String")
-- 5. 関数適用（HM 型推論の核）
inferExpr env (EApp e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ ->
      Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)
-- 6. ラムダ式
inferExpr env (ELam pat body) = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-- 7. let 式
inferExpr env (ELet pat e1 e2) = do
  -- パターン推論
  (sPat, envPat, tPat) <- inferPattern pat
  -- e1 の推論
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  -- パターン型と e1 の型を unify
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  -- ここまでの置換をまとめる
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  -- パターンから得た環境を適用
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  -- e2 の推論
  (s3, t2) <- inferExpr env' e2
  -- 全体の置換
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)
-- 8. if 式
inferExpr env (EIf cond eThen eElse) = do
  (s1, tCond) <- inferExpr env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExpr env1 eThen
  (s3, tElse) <- inferExpr (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-- 9. case 式
inferExpr env (ECase scrut branches) = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results
-- 10. タプル
inferExpr env (ETuple es) = do
  inferred <- mapM (inferExpr env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))
-- 11. リスト
inferExpr env (EList es) = do
  inferred <- mapM (inferExpr env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))
-- Where
inferExpr env (EWhere e binds) = do
  -- 本体を推論
  (s1, t1) <- inferExpr env e
  -- 本体のスコープを使って where の定義を推論
  env' <- foldM inferBinding (applyEnv s1 env) binds
  -- where の定義はスコープに影響しないので、型は t1 のまま返す
  return (s1, t1)
-- do
inferExpr env (EDo stmts) = inferDo env stmts
inferExpr env (EBinOp op e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)

inferDo :: TypeEnv -> [Stmt] -> Either InferError (Subst, Type)
inferDo env [] =
  Left (InferOther "Empty do block")
inferDo env [ExprStmt e] =
  inferExpr env e -- 最後の式の型が do の型
inferDo env (stmt : rest) = do
  (s1, env1) <- inferStmt env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt :: TypeEnv -> Stmt -> Either InferError (Subst, TypeEnv)
inferStmt env (ExprStmt e) = do
  (s, _) <- inferExpr env e
  return (s, env)
inferStmt env (LetStmt binds) =
  inferBindings env binds
inferStmt env (Bind pat e) = do
  -- 式の型を推論
  (s1, t1) <- inferExpr env e

  -- パターンの型を推論
  (s2, env2, tPat) <- inferPattern pat

  -- unify のエラーを InferError に変換
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- 置換を合成
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- 環境に適用
  let env' = applyEnv s env2

  return (s, env')

inferBinding :: TypeEnv -> (Pattern, Expr) -> Either InferError TypeEnv
inferBinding env (pat, expr) = do
  -- 式の型を推論
  (s1, t1) <- inferExpr env expr

  -- パターンの型を推論
  (s2, env2, tPat) <- inferPattern pat

  -- unify のエラーを InferError に変換
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- 置換を合成
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- 環境に置換を適用
  let env' = applyEnv s env2

  return env'

-- 宣言の型推論（まだ骨格だけ）
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats body -> do
    -- パターンごとに型推論
    (sPats, envPats, argTypes) <- inferPatterns pats

    -- パターンで拡張した環境で body を推論
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body

    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)

    Right (extendEnv env name scheme, s)
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)

inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- 仮の型を環境に入れる（再帰対応）
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)

  -- 各 clause の型を推論
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]

  -- unify して 1 つの型にまとめる
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)

  -- generalize
  let scheme = generalizeInfer env finalType

  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats

  -- ★ 関数型をここで作る
  let funType = foldr TArrow tBody argTypes

  Right (s, funType)

freshVar :: Int -> Type
freshVar n = TVar ("t" ++ show n)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- 変数パターン
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- 単一変数の PApp パターン（あなたのパーサーが生成する形）
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- ★ 追加：PApp の一般形（引数なし）
  PApp p [] -> inferPattern p
  {-}
  -- 変数パターン
  PVar v ->
    let t = TVar ("t_" ++ v)
        env = extendEnv emptyEnv v (Forall [] t)
     in Right (emptySubst, env, t)
     -}
  -- 整数リテラル
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ワイルドカード
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- リストパターン [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- 全要素の型を t0 と unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- タプルパターン (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- コンストラクタパターン Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons パターン (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As パターン x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokSymbol "{",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "InferResult",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "{",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSymbol "{",TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBindings",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "tExpr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sExpr",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "envPat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "envRest",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBranch",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "CaseAlt",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "tScrut",TokSpace 1,TokIdent "sScrut",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSpace 1,TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "envBinds",TokSpace 1,TokIdent "env",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env''",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sBinds",TokSpace 1,TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokSpace 1,TokIdent "env''",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "params",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokSpace 1,TokIdent "param",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "envAcc",TokSpace 1,TokIdent "param",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sParam",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sNew",TokSpace 1,TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "x",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EInt",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EBool",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EString",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "t1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "tCond",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "env1",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokSpace 1,TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokIdent "tElse",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s4",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokSpace 1,TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokSpace 1,TokIdent "results",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "substs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "fst",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "types",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "snd",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldl",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "emptySubst",TokSpace 1,TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "inferred",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sRest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyList",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "inferBinding",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "opType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinEnv",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tOp",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokSpace 1,TokIdent "opType",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferDo",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokTypeIdent "ExprStmt",TokSpace 1,TokIdent "e",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "stmt",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Stmt",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "return",TokSpace 1,TokIdent "env'",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "decl",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokIdent "ty",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "DeclFun",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "pats",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "DeclValue",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferProgram",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "groups",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokSpace 1,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferGroup",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "tempType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envTemp",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokSpace 1,TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funTypes",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "|",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferred",TokSymbol "]",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "finalType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "finalType",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freshVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Int",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "PVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_wild",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PList",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "tElem",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s'",TokSpace 1,TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PTuple",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PConstr",TokSpace 1,TokIdent "con",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinPatternEnv",TokSpace 1,TokIdent "con",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "scheme",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tCon",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokIdent "args",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PCons",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "p2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p2",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol "{",TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PAs",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "p",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env2",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "alpha",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_app",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s2",TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "groupDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSpace 1,TokSymbol "(",TokOperator "++",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "decls",TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokSymbol "{",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "InferResult",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "{",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSymbol "{",TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBindings",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "tExpr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sExpr",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "envPat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "envRest",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBranch",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "CaseAlt",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "tScrut",TokSpace 1,TokIdent "sScrut",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSpace 1,TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "envBinds",TokSpace 1,TokIdent "env",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env''",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sBinds",TokSpace 1,TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokSpace 1,TokIdent "env''",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "params",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokSpace 1,TokIdent "param",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "envAcc",TokSpace 1,TokIdent "param",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sParam",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sNew",TokSpace 1,TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "x",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EInt",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EBool",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EString",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "t1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "tCond",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "env1",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokSpace 1,TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokIdent "tElse",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s4",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokSpace 1,TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokSpace 1,TokIdent "results",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "substs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "fst",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "types",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "snd",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldl",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "emptySubst",TokSpace 1,TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "inferred",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sRest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyList",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "inferBinding",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "opType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinEnv",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tOp",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokSpace 1,TokIdent "opType",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferDo",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokTypeIdent "ExprStmt",TokSpace 1,TokIdent "e",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "stmt",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferStmt",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Stmt",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferBindings",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBinding",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "return",TokSpace 1,TokIdent "env'",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "decl",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokIdent "ty",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "DeclFun",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "pats",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "DeclValue",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferProgram",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "groups",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokSpace 1,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferGroup",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "tempType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envTemp",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokSpace 1,TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funTypes",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "|",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferred",TokSymbol "]",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokIdent "s",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "finalType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "finalType",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol "}",TokNewline,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freshVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Int",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokSpace 1,TokIdent "n",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "PVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_wild",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PList",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "tElem",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s'",TokSpace 1,TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PTuple",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PConstr",TokSpace 1,TokIdent "con",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinPatternEnv",TokSpace 1,TokIdent "con",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "scheme",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tCon",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokIdent "args",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PCons",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "p2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p2",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol "{",TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PAs",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "p",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env2",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "alpha",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_app",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s2",TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "groupDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSpace 1,TokSymbol "(",TokOperator "++",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "decls",TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Core.hs ===
-- Raw Source --
module TypeInference.Infer.Core
  ( counter,
    builtinPatternEnv,
    builtinOps,
    builtinEnv,
    generalizeInfer,
    groupDecls,
    unifyMany,
    mergeEnvs,
    freshTypeVar,
    InferResult,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr の返り値：型と代入
type InferResult = (Subst, Type)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokSymbol "{",TokSymbol "(",TokIdent "counter",TokSymbol ",",TokIdent "builtinPatternEnv",TokSymbol ",",TokIdent "builtinOps",TokSymbol ",",TokIdent "builtinEnv",TokSymbol ",",TokIdent "generalizeInfer",TokSymbol ",",TokIdent "groupDecls",TokSymbol ",",TokIdent "unifyMany",TokSymbol ",",TokIdent "mergeEnvs",TokSymbol ",",TokIdent "freshTypeVar",TokSymbol ",",TokTypeIdent "InferResult",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "InferResult",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSymbol "{",TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "{",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "groupDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSpace 1,TokSymbol "(",TokOperator "++",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "decls",TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokSymbol "{",TokSymbol "(",TokIdent "counter",TokSymbol ",",TokIdent "builtinPatternEnv",TokSymbol ",",TokIdent "builtinOps",TokSymbol ",",TokIdent "builtinEnv",TokSymbol ",",TokIdent "generalizeInfer",TokSymbol ",",TokIdent "groupDecls",TokSymbol ",",TokIdent "unifyMany",TokSymbol ",",TokIdent "mergeEnvs",TokSymbol ",",TokIdent "freshTypeVar",TokSymbol ",",TokTypeIdent "InferResult",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "InferResult",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSymbol "{",TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "[",TokSpace 1,TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "{",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "groupDecls",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "Name",TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSpace 1,TokSymbol "(",TokOperator "++",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "decls",TokSymbol "]",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprApp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprApp (inferApp) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferApp inferExprFn env e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  tv <- freshTypeVar
  s3 <- case unify (apply s2 t1) (TFun t2 tv) of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s tv)

{-}
-- TypeInference/Infer/Expr/ExprApp.hs
module TypeInference.Infer.Expr.ExprApp
  ( inferApp,
    inferLam,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp :: TypeEnv -> Expr -> Expr -> Either InferError (Subst, Type)
inferApp env e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ -> Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)

inferLam :: TypeEnv -> Pattern -> Expr -> Either InferError (Subst, Type)
inferLam env pat body = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSpace 1,TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferApp",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferApp",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSpace 1,TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferApp",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferApp",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprBinOp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprBinOp (inferBinOp) where

import AST.Expr (BinOp (..), Expr (..))
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  BinOp ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferBinOp inferExprFn env op e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  let s12 = s2 `composeSubst` s1
  (arg1, arg2, result) <- case op of
    Add -> pure (TCon "Int", TCon "Int", TCon "Int")
    Sub -> pure (TCon "Int", TCon "Int", TCon "Int")
    Mul -> pure (TCon "Int", TCon "Int", TCon "Int")
    Div -> pure (TCon "Int", TCon "Int", TCon "Int")
    And -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Or -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Eq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Neq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Lt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Gt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Le -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Ge -> pure (TCon "Int", TCon "Int", TCon "Bool")
  s3 <- case unify (apply s12 t1) arg1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right sA -> case unify (apply sA (apply s12 t2)) (apply sA arg2) of
      Left uerr -> Left (InferUnifyError uerr)
      Right sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)

{-}
  s3 <-
    unify (apply s12 t1) arg1
      >>= \sA ->
        unify (apply sA (apply s12 t2)) (apply sA arg2)
          >>= \sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)
-}
{-}
-- TypeInference/Infer/Expr/ExprBinOp.hs
module TypeInference.Infer.Expr.ExprBinOp
  ( inferBinOp,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp :: TypeEnv -> String -> Expr -> Expr -> Either InferError (Subst, Type)
inferBinOp inferExpr env op e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSpace 1,TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferBinOp",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "BinOp",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBinOp",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s12",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Add",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSpace 1,TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Neq",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSpace 1,TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Lt",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokSpace 1,TokIdent "arg1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "sA",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "sB",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sB",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "sA",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSpace 1,TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferBinOp",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "BinOp",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBinOp",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e2",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s12",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "op",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Add",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSpace 1,TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Neq",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSpace 1,TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "Lt",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokSpace 1,TokArrow,TokSpace 1,TokIdent "pure",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokSpace 1,TokIdent "arg1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "sA",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "sB",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sB",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "sA",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprCase.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprCase (inferCase) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [CaseAlt] ->
  Either InferError (Subst, Type)
inferCase inferExprFn env scrut branches = do
  (sScrut, tScrut) <- inferExprFn env scrut
  results <- mapM (inferBranch inferExprFn env tScrut sScrut) branches
  unifyManyExpr results

inferBranch ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Type ->
  Subst ->
  CaseAlt ->
  Either InferError (Subst, Type)
inferBranch inferExprFn env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = sUnify `composeSubst` sPat `composeSubst` sScrut
  inferExprFn (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right su -> Right su
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)

{-}
-- TypeInference/Infer/Expr/ExprCase.hs
module TypeInference.Infer.Expr.ExprCase
  ( inferCase,
    inferBranch,
    unifyManyExpr,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase :: TypeEnv -> Expr -> [CaseAlt] -> Either InferError (Subst, Type)
inferCase inferExpr env scrut branches = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s
    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSpace 1,TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferCase",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferCase",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "branches",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokSpace 1,TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokSpace 1,TokIdent "results",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBranch",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Type",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "CaseAlt",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBranch",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "tScrut",TokSpace 1,TokIdent "sScrut",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "xs",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sU",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sU",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sNext",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSpace 1,TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferCase",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferCase",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "branches",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokSpace 1,TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokSpace 1,TokIdent "results",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBranch",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Type",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "CaseAlt",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBranch",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "tScrut",TokSpace 1,TokIdent "sScrut",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "xs",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sU",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sU",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sNext",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDispatch.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDispatch (inferExpr) where

import AST.Expr
import AST.Type
import AST.Type (Type (..)) -- これで TFun などのコンストラクタが使えるようになる
import TypeInference.Error
import TypeInference.Infer.Expr.ExprApp (inferApp)
import TypeInference.Infer.Expr.ExprBinOp (inferBinOp)
import TypeInference.Infer.Expr.ExprCase (inferCase)
import TypeInference.Infer.Expr.ExprDo (inferDo)
import TypeInference.Infer.Expr.ExprIf (inferIf)
import TypeInference.Infer.Expr.ExprLet (inferLet, inferLetBlock, inferWhere)
import TypeInference.Infer.Expr.ExprLiteral (inferBool, inferInt, inferList, inferString, inferTuple)
import TypeInference.Infer.Expr.ExprSQL (inferSQL)
import TypeInference.Subst
import TypeInference.TypeEnv

-- 他の構文モジュールもここに import
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (EVar name) =
  case lookupEnv env name of
    Nothing -> Left (InferUnboundVariable name)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- AST で定義された型で分岐 ここが欠損すると型推論ができなくなる
inferExpr env expr = case expr of
  ELet pat e1 e2 -> inferLet inferExpr env pat e1 e2
  ELetBlock binds body -> inferLetBlock inferExpr env binds body
  EWhere e binds -> inferWhere inferExpr env e binds
  EIf c t f -> inferIf inferExpr env c t f
  EDo stmts -> inferDo inferExpr env stmts
  ECase scrut alts -> inferCase inferExpr env scrut alts
  EApp e1 e2 -> inferApp inferExpr env e1 e2
  EBinOp op e1 e2 -> inferBinOp inferExpr env op e1 e2
  -- リテラル
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple inferExpr env es
  EList es -> inferList inferExpr env es
  -- 拡張タイプ SQL
  ESQL _ params -> inferSQL inferExpr env params

{-}
  ELetBlock binds body -> inferLetBlock env binds body
  ELet pat e1 e2 -> inferLet env pat e1 e2
  EWhere e binds -> inferWhere env e binds
  ECase scrut alts -> inferCase env scrut alts
  EApp e1 e2 -> inferApp env e1 e2
  ELam pat body -> inferLam env pat body
  EDo stmts -> inferDo env stmts
  EBinOp op e1 e2 -> inferBinOp env op e1 e2
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple env es
  EList es -> inferList env es
  ESQL _ params -> inferSQL env params
-}


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokSpace 1,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSpace 1,TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSpace 1,TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSpace 1,TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSpace 1,TokSymbol "(",TokIdent "inferDo",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSpace 1,TokSymbol "(",TokIdent "inferIf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSpace 1,TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSpace 1,TokSymbol "(",TokIdent "inferBool",TokSymbol ",",TokIdent "inferInt",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSpace 1,TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "name",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "expr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "ELet",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferLet",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferLetBlock",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferWhere",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokSpace 1,TokIdent "c",TokSpace 1,TokIdent "t",TokSpace 1,TokIdent "f",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferIf",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "c",TokSpace 1,TokIdent "t",TokSpace 1,TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokSpace 1,TokIdent "stmts",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "alts",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferCase",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferApp",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferBinOp",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokSpace 1,TokIdent "es",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferTuple",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokSpace 1,TokIdent "es",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferList",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokSpace 1,TokSymbol "_",TokSpace 1,TokIdent "params",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferSQL",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "params",TokSymbol "}",TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokSpace 1,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSpace 1,TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSpace 1,TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSpace 1,TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSpace 1,TokSymbol "(",TokIdent "inferDo",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSpace 1,TokSymbol "(",TokIdent "inferIf",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSpace 1,TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSpace 1,TokSymbol "(",TokIdent "inferBool",TokSymbol ",",TokIdent "inferInt",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSpace 1,TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "name",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "sigma",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "t",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "expr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "ELet",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferLet",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferLetBlock",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferWhere",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokSpace 1,TokIdent "c",TokSpace 1,TokIdent "t",TokSpace 1,TokIdent "f",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferIf",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "c",TokSpace 1,TokIdent "t",TokSpace 1,TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokSpace 1,TokIdent "stmts",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "alts",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferCase",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "scrut",TokSpace 1,TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferApp",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferBinOp",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "op",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokSpace 1,TokIdent "es",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferTuple",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokSpace 1,TokIdent "es",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferList",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokSpace 1,TokSymbol "_",TokSpace 1,TokIdent "params",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferSQL",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "params",TokSymbol "}",TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDo.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDo (inferDo, inferStmt) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprLet (inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferDo ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Stmt] ->
  Either InferError (Subst, Type)
inferDo inferExprFn env [] =
  Left (InferOther "Empty do block")
inferDo inferExprFn env [ExprStmt e] =
  inferExprFn env e
inferDo inferExprFn env (stmt : rest) = do
  (s1, env1) <- inferStmt inferExprFn env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo inferExprFn env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Stmt ->
  Either InferError (Subst, TypeEnv)
inferStmt inferExprFn env (ExprStmt e) = do
  (s, _) <- inferExprFn env e
  return (s, env)
inferStmt inferExprFn env (LetStmt binds) =
  inferBindings inferExprFn env binds
inferStmt inferExprFn env (Bind pat e) = do
  (s1, t1) <- inferExprFn env e
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return (s, env')


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSpace 1,TokSymbol "(",TokIdent "inferDo",TokSymbol ",",TokIdent "inferStmt",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSpace 1,TokSymbol "(",TokIdent "inferBindings",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferDo",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokTypeIdent "ExprStmt",TokSpace 1,TokIdent "e",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "stmt",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferStmt",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Stmt",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSpace 1,TokSymbol "(",TokIdent "inferDo",TokSymbol ",",TokIdent "inferStmt",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSpace 1,TokSymbol "(",TokIdent "inferBindings",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferDo",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokTypeIdent "ExprStmt",TokSpace 1,TokIdent "e",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol "}",TokNewline,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "stmt",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferDo",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferStmt",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Stmt",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol "}",TokNewline,TokIdent "inferStmt",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprIf.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprIf
  ( inferIf,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferIf ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)

{-}
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSymbol "{",TokSymbol "(",TokIdent "inferIf",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferIf",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferIf",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSpace 1,TokIdent "eThen",TokSpace 1,TokIdent "eElse",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "tCond",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "env1",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokSpace 1,TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokIdent "tElse",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s4",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSymbol "{",TokSymbol "(",TokIdent "inferIf",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferIf",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferIf",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSpace 1,TokIdent "eThen",TokSpace 1,TokIdent "eElse",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "tCond",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "env1",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokSpace 1,TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokSpace 1,TokIdent "tElse",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s4",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLet.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLet
  ( inferLet,
    inferLetBlock,
    inferWhere,
    inferBindings,
    inferBinding,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import qualified Data.Map as M
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferLet ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Pattern ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferLet inferExprFn env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExprFn (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExprFn env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferBindings ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, TypeEnv)
inferBindings inferExprFn env [] = Right (emptySubst, emptyEnv)
inferBindings inferExprFn env ((pat, expr) : rest) = do
  (sPat, envPat, tPat) <- inferPattern pat
  (sExpr, tExpr) <- inferExprFn (applyEnv sPat env) expr
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat
  (sRest, envRest) <- inferBindings inferExprFn (applyEnv s env) rest
  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest
  Right (sFinal, envFinal)

inferLetBlock ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Expr ->
  Either InferError (Subst, Type)
inferLetBlock inferExprFn env binds body = do
  (sBinds, envBinds) <- inferBindings inferExprFn env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExprFn env'' body

inferWhere ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, Type)
inferWhere inferExprFn env e binds = do
  (s1, t1) <- inferExprFn env e
  _ <- foldM (inferBinding inferExprFn) (applyEnv s1 env) binds
  return (s1, t1)

inferBinding ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  (Pattern, Expr) ->
  Either InferError TypeEnv
inferBinding inferExprFn env (pat, expr) = do
  (s1, t1) <- inferExprFn env expr
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return env'

-- 同様に inferLetBlock, inferWhere, inferBindings, inferBinding も inferExprFn を引数に取るように変更
{-}
inferLet :: TypeEnv -> Pattern -> Expr -> Expr -> Either InferError (Subst, Type)
inferLet inferExpr env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExpr env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferLetBlock :: TypeEnv -> [(Pattern, Expr)] -> Expr -> Either InferError (Subst, Type)
inferLetBlock inferBindings env binds body = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

inferWhere :: TypeEnv -> Expr -> [(Pattern, Expr)] -> Either InferError (Subst, Type)
inferWhere inferExpr inferBinding env e binds = do
  (s1, t1) <- inferExpr env e
  _ <- foldM inferBinding (applyEnv s1 env) binds
  return (s1, t1)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "{",TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ",",TokIdent "inferBindings",TokSymbol ",",TokIdent "inferBinding",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferLet",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferLet",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "t1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "e2",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBindings",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "tExpr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sExpr",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferLetBlock",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferLetBlock",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "envBinds",TokSpace 1,TokIdent "env",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env''",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sBinds",TokSpace 1,TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokSpace 1,TokIdent "env''",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferWhere",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferWhere",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBinding",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokSymbol "}",TokNewline,TokIdent "inferBinding",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "env'",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "{",TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ",",TokIdent "inferBindings",TokSymbol ",",TokIdent "inferBinding",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferLet",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferLet",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "e1",TokSpace 1,TokIdent "e2",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "t1",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "e2",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBindings",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokIdent "tExpr",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sUnify",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sExpr",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envFinal",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env'",TokSpace 1,TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferLetBlock",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferLetBlock",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSpace 1,TokIdent "body",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferBindings",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "envBinds",TokSpace 1,TokIdent "env",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env''",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sBinds",TokSpace 1,TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokSpace 1,TokIdent "env''",TokSpace 1,TokIdent "body",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferWhere",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferWhere",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSpace 1,TokIdent "binds",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "e",TokSymbol ";",TokSymbol "_",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferBinding",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokSymbol "}",TokNewline,TokIdent "inferBinding",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "tPat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "s",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "s3",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSpace 1,TokIdent "env'",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLiteral.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLiteral
  ( inferInt,
    inferBool,
    inferString,
    inferTuple,
    inferList,
  )
where

import AST.Expr
import AST.Type
import Control.Monad (mapM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferInt = Right (emptySubst, TCon "Int")

inferBool = Right (emptySubst, TCon "Bool")

inferString = Right (emptySubst, TCon "String")

inferTuple ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferTuple inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))

inferList ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferList inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))

unifyList :: Type -> [(Subst, Type)] -> Either InferError Subst
unifyList t [] = Right emptySubst
unifyList t ((s, tElem) : rest) = do
  sU <- case unify (apply s t) tElem of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s' = sU `composeSubst` s
  unifyList (apply s' t) rest


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSymbol "{",TokSymbol "(",TokIdent "inferInt",TokSymbol ",",TokIdent "inferBool",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "mapM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferInt",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferBool",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferString",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferTuple",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferTuple",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "substs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "fst",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "types",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "snd",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldl",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "emptySubst",TokSpace 1,TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferList",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferList",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "inferred",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sRest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyList",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyList",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyList",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sU",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "tElem",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sU",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSymbol "{",TokSymbol "(",TokIdent "inferInt",TokSymbol ",",TokIdent "inferBool",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "mapM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferInt",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferBool",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferString",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferTuple",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferTuple",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "substs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "fst",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "types",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "snd",TokSpace 1,TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldl",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "emptySubst",TokSpace 1,TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferList",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferList",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "es",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "es",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "inferred",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sRest",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyList",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "rest",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sRest",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "unifyList",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyList",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyList",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokSymbol ":",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "sU",TokSpace 1,TokSymbol "<-",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "tElem",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokIdent "uerr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "su",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sU",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokSpace 1,TokIdent "rest",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprSQL.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprSQL (inferSQL) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv

inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env params = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, _) <- inferExprFn envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSpace 1,TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokIdent "inferSQL",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferSQL",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "params",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "params",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokSpace 1,TokIdent "param",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "envAcc",TokSpace 1,TokIdent "param",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sParam",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sNew",TokSpace 1,TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSpace 1,TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokIdent "inferSQL",TokSpace 1,TokSymbol "::",TokSymbol "{",TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSymbol ";",TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferSQL",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "params",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "foldM",TokSpace 1,TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "params",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokSymbol "{",TokIdent "step",TokSpace 1,TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokSpace 1,TokIdent "param",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExprFn",TokSpace 1,TokIdent "envAcc",TokSpace 1,TokIdent "param",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "sNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "sParam",TokSpace 1,TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokSpace 1,TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envNew",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "applyEnv",TokSpace 1,TokIdent "sNew",TokSpace 1,TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Expr.hs ===
-- Raw Source --
module TypeInference.Infer.Expr
  ( inferExpr,
    inferProgram,
    inferDecl,
  )
where

import AST.Decl (Decl (..))
import AST.Expr
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprDispatch (inferExpr)
import TypeInference.Infer.Expr.ExprSQL
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

-- declsはAST
inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- 仮の型を環境に入れる（再帰対応）
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)
  -- 各 clause の型を推論
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]
  -- unify して 1 つの型にまとめる
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)
  -- generalize
  let scheme = generalizeInfer env finalType
  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats
  -- ★ 関数型をここで作る
  let funType = foldr TArrow tBody argTypes
  Right (s, funType)

-- 宣言の型推論（まだ骨格だけ）
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats body -> do
    -- パターンごとに型推論
    (sPats, envPats, argTypes) <- inferPatterns pats
    -- パターンで拡張した環境で body を推論
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body
    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)
    Right (extendEnv env name scheme, s)
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSymbol "{",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "inferProgram",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "groups",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokSpace 1,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferGroup",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "tempType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envTemp",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokSpace 1,TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funTypes",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "|",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "finalType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "decl",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokIdent "ty",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "DeclFun",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "pats",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "DeclValue",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSymbol "{",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokIdent "inferProgram",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decls",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "groups",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "groupDecls",TokSpace 1,TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokSpace 1,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferGroup",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "tempType",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "envTemp",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "mapM",TokSpace 1,TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokSpace 1,TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funTypes",TokSpace 1,TokSymbol "=",TokSpace 1,TokSymbol "[",TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "|",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "finalType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferClause",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "inferDecl",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Decl",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "decl",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "decl",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "DeclTypeSig",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "ty",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokIdent "ty",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "DeclFun",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "pats",TokSpace 1,TokIdent "body",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferExpr",TokSpace 1,TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokSpace 1,TokIdent "body",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "funType",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokIdent "tBody",TokSpace 1,TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "sBody",TokSpace 1,TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "generalizeInfer",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "DeclValue",TokSpace 1,TokIdent "pat",TokSpace 1,TokIdent "expr",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer/Pattern.hs ===
-- Raw Source --
module TypeInference.Infer.Pattern
  ( inferPattern,
    inferPatterns,
    inferPatternApp,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.Infer.Core
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- 変数パターン
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- 単一変数の PApp パターン（あなたのパーサーが生成する形）
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- ★ 追加：PApp の一般形（引数なし）
  PApp p [] -> inferPattern p
  -- 整数リテラル
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ワイルドカード
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- リストパターン [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- 全要素の型を t0 と unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- タプルパターン (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- コンストラクタパターン Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons パターン (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As パターン x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokSymbol "{",TokSymbol "(",TokIdent "inferPattern",TokSymbol ",",TokIdent "inferPatterns",TokSymbol ",",TokIdent "inferPatternApp",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "PVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_wild",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PList",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "tElem",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s'",TokSpace 1,TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PTuple",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PConstr",TokSpace 1,TokIdent "con",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinPatternEnv",TokSpace 1,TokIdent "con",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "scheme",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tCon",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokIdent "args",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PCons",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "p2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p2",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol "{",TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PAs",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "p",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env2",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "alpha",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_app",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s2",TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokSymbol "{",TokSymbol "(",TokIdent "inferPattern",TokSymbol ",",TokIdent "inferPatterns",TokSymbol ",",TokIdent "inferPatternApp",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokNewline,TokIdent "inferPattern",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Pattern",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSpace 1,TokIdent "pat",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "pat",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol ";",TokTypeIdent "PVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tv",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "emptyEnv",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSpace 1,TokIdent "p",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_wild",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol ";",TokTypeIdent "PList",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "ts",TokSpace 1,TokKeyword "of",TokSymbol "{",TokSymbol "[",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokSymbol ":",TokSymbol "_",TokSymbol ")",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSpace 1,TokSymbol "<-",TokSymbol "{",TokIdent "foldM",TokSymbol "{",TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokSymbol "}",TokSymbol "}",TokNewline,TokKeyword "let",TokSpace 1,TokIdent "tElem",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "s'",TokSpace 1,TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PTuple",TokSpace 1,TokIdent "ps",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PConstr",TokSpace 1,TokIdent "con",TokSpace 1,TokIdent "args",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokKeyword "case",TokSpace 1,TokIdent "lookupEnv",TokSpace 1,TokIdent "builtinPatternEnv",TokSpace 1,TokIdent "con",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSpace 1,TokIdent "scheme",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "tCon",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "instantiate",TokSpace 1,TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokIdent "args",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PCons",TokSpace 1,TokIdent "p1",TokSpace 1,TokIdent "p2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p2",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s3",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol "{",TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokSymbol ";",TokTypeIdent "PAs",TokSpace 1,TokIdent "name",TokSpace 1,TokIdent "p",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env2",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "extendEnv",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "name",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "inferPatternApp",TokSpace 1,TokIdent "tCon",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "alpha",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokString "t_app",TokSymbol ";",TokKeyword "case",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokIdent "s2",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatternApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s3",TokSpace 1,TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSpace 1,TokSymbol "(",TokIdent "p",TokSymbol ":",TokIdent "ps",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPattern",TokSpace 1,TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "inferPatterns",TokSpace 1,TokIdent "ps",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "composeSubst",TokSpace 1,TokIdent "s2",TokSpace 1,TokIdent "s1",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "env",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "mergeEnvs",TokSpace 1,TokIdent "env1",TokSpace 1,TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokSymbol ":",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Infer.hs ===
-- Raw Source --
module TypeInference.Infer
  ( inferExpr,
    inferProgram,
    -- inferProgramPattern
  )
where

import TypeInference.Infer.Expr (inferExpr, inferProgram)

-- import TypeInference.Infer.Pattern
-- import TypeInference.Infer.Core


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokSymbol "{",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokSymbol "{",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ")",TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Pretty.hs ===
-- Raw Source --
module TypeInference.Pretty (prettyType) where

-- import TypeInference.Subst
-- import TypeInference.Type (Type(..))
-- import qualified TypeInference.Type as TI

import AST.Type (Type(..))
import qualified AST.Type as TI

prettyType :: TI.Type -> String
prettyType ty = case ty of
  TVar v        -> v
  TCon c        -> c
  TUnit         -> "Unit"
  TArrow a b    -> "(" ++ prettyType a ++ " -> " ++ prettyType b ++ ")"
  TList t       -> "[" ++ prettyType t ++ "]"
  TApp a b      -> prettyType a ++ " " ++ prettyType b
  TForall vs t  -> "forall " ++ unwords vs ++ ". " ++ prettyType t
  TTuple ts     -> "(" ++ commaList (map prettyType ts) ++ ")"
  TConstraint cs t ->
      "(" ++ commaList (map show cs) ++ ") => " ++ prettyType t
  where
    commaList = foldr1 (\a b -> a ++ ", " ++ b)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Pretty",TokSpace 1,TokSymbol "(",TokIdent "prettyType",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TI",TokNewline,TokNewline,TokIdent "prettyType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TI",TokDot,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokSpace 1,TokIdent "ty",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ty",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 8,TokArrow,TokSpace 1,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSpace 8,TokArrow,TokSpace 1,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokSpace 9,TokArrow,TokSpace 1,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokSpace 4,TokArrow,TokSpace 1,TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "a",TokSpace 1,TokOperator "++",TokSpace 1,TokString " -> ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "b",TokSpace 1,TokOperator "++",TokSpace 1,TokString ")",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t",TokSpace 7,TokArrow,TokSpace 1,TokString "[",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSpace 1,TokOperator "++",TokSpace 1,TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokSpace 6,TokArrow,TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "a",TokSpace 1,TokOperator "++",TokSpace 1,TokString " ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t",TokSpace 2,TokArrow,TokSpace 1,TokString "forall ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "unwords",TokSpace 1,TokIdent "vs",TokSpace 1,TokOperator "++",TokSpace 1,TokString ". ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSpace 5,TokArrow,TokSpace 1,TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "commaList",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokSpace 1,TokOperator "++",TokSpace 1,TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t",TokSpace 1,TokArrow,TokSymbol "{",TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "commaList",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokSpace 1,TokOperator "++",TokSpace 1,TokString ") => ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "commaList",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr1",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Pretty",TokSpace 1,TokSymbol "(",TokIdent "prettyType",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "TI",TokNewline,TokNewline,TokIdent "prettyType",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TI",TokDot,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokSpace 1,TokIdent "ty",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "ty",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 8,TokArrow,TokSpace 1,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSpace 8,TokArrow,TokSpace 1,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokSpace 9,TokArrow,TokSpace 1,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokSpace 4,TokArrow,TokSpace 1,TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "a",TokSpace 1,TokOperator "++",TokSpace 1,TokString " -> ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "b",TokSpace 1,TokOperator "++",TokSpace 1,TokString ")",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t",TokSpace 7,TokArrow,TokSpace 1,TokString "[",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSpace 1,TokOperator "++",TokSpace 1,TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokSpace 6,TokArrow,TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "a",TokSpace 1,TokOperator "++",TokSpace 1,TokString " ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t",TokSpace 2,TokArrow,TokSpace 1,TokString "forall ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "unwords",TokSpace 1,TokIdent "vs",TokSpace 1,TokOperator "++",TokSpace 1,TokString ". ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSpace 5,TokArrow,TokSpace 1,TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "commaList",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokSpace 1,TokOperator "++",TokSpace 1,TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t",TokSpace 1,TokArrow,TokSymbol "{",TokString "(",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "commaList",TokSpace 1,TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokSpace 1,TokOperator "++",TokSpace 1,TokString ") => ",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "prettyType",TokSpace 1,TokIdent "t",TokSymbol "}",TokNewline,TokKeyword "where",TokSymbol "{",TokIdent "commaList",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr1",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/SQLInfer.hs ===
-- Raw Source --
module TypeInference.SQLInfer where

import AST.Decl (Decl (..))
import AST.Expr (CaseAlt (..), Expr (..), Name)
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import TypeInference.Error (InferError (..))
import TypeInference.Subst
import TypeInference.TypeEnv

data SQLInfo = SQLInfo
  { sqlText  :: String
  , sqlVars  :: [String]
  , sqlExprs :: [Expr]
  }

inferSQL :: String -> [Expr] -> SQLInfo
inferSQL sql args =
  SQLInfo
    { sqlText  = sql
    , sqlVars  = map getVarName args
    , sqlExprs = args
    }

getVarName :: Expr -> String
getVarName (EVar name) = name
getVarName _ = error "SQL arguments must be variables"

{-}
inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  String ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env sql args = do
  inferred <- mapM (inferExprFn env) args
  return (emptySubst, TUnit)
-}

{-}
inferSQL :: TypeEnv -> String -> [Expr] -> Either InferError (Subst, Type)
inferSQL env sql args = do
  -- args の型を推論
  argTypes <- mapM (inferExpr env) args

  -- SQLParam 型クラスに属するかチェック（任意）
  mapM_ ensureSQLParam (map snd argTypes)

  -- SQL 文自体の型は Unit でよい
  return (emptySubst, TUnit)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "SQLInfo",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "SQLInfo",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "sqlText",TokSpace 2,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlVars",TokSpace 2,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlExprs",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferSQL",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "SQLInfo",TokNewline,TokIdent "inferSQL",TokSpace 1,TokKeyword "sql",TokSpace 1,TokIdent "args",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "SQLInfo",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "sqlText",TokSpace 2,TokSymbol "=",TokSpace 1,TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlVars",TokSpace 2,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "getVarName",TokSpace 1,TokIdent "args",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlExprs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "args",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "name",TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "error",TokSpace 1,TokString "SQL arguments must be variables",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSpace 1,TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSpace 1,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "SQLInfo",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "SQLInfo",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "sqlText",TokSpace 2,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlVars",TokSpace 2,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlExprs",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "inferSQL",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "SQLInfo",TokNewline,TokIdent "inferSQL",TokSpace 1,TokKeyword "sql",TokSpace 1,TokIdent "args",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "SQLInfo",TokSymbol "{",TokSymbol "{",TokSpace 1,TokIdent "sqlText",TokSpace 2,TokSymbol "=",TokSpace 1,TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlVars",TokSpace 2,TokSymbol "=",TokSpace 1,TokIdent "map",TokSpace 1,TokIdent "getVarName",TokSpace 1,TokIdent "args",TokSymbol ";",TokSymbol ",",TokSpace 1,TokIdent "sqlExprs",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "args",TokSymbol ";",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Expr",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "name",TokNewline,TokIdent "getVarName",TokSpace 1,TokSymbol "_",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "error",TokSpace 1,TokString "SQL arguments must be variables",TokNewline,TokNewline,TokNewline,TokNewline,TokNewline])

=== Running: src/TypeInference/Subst.hs ===
-- Raw Source --
module TypeInference.Subst
  ( Subst,
    emptySubst,
    singletonSubst,
    composeSubst,
    apply,
  )
where

import AST.Type
import qualified Data.Map as M

-- 型代入：型変数名 → 型
type Subst = M.Map String Type

-- 空の代入
emptySubst :: Subst
emptySubst = M.empty

-- 単一代入
singletonSubst :: String -> Type -> Subst
singletonSubst = M.singleton

-- 代入の合成
-- s1 を先に適用し、その結果に s2 を適用する
composeSubst :: Subst -> Subst -> Subst
composeSubst s1 s2 =
  M.map (apply s1) s2 `M.union` s1

-- 型への代入適用
apply :: Subst -> Type -> Type
apply s t = case t of
  TUnit ->
    TUnit
  TVar v ->
    case M.lookup v s of
      Just t' -> t'
      Nothing -> TVar v
  TCon c ->
    TCon c
  TArrow t1 t2 ->
    TArrow (apply s t1) (apply s t2)
  TList t1 ->
    TList (apply s t1)
  TApp t1 t2 ->
    TApp (apply s t1) (apply s t2)
  TConstraint cs t1 ->
    TConstraint (map (applyConstraint s) cs) (apply s t1)
  TForall vars t1 ->
    -- Forall の束縛変数には代入を適用しない
    let s' = foldr M.delete s vars
     in TForall vars (apply s' t1)
  TTuple ts ->
    TTuple (map (apply s) ts)

-- 制約への代入適用
applyConstraint :: Subst -> Constraint -> Constraint
applyConstraint s (Constraint cls ts) =
  Constraint cls (map (apply s) ts)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokSymbol "{",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "emptySubst",TokSymbol ",",TokIdent "singletonSubst",TokSymbol ",",TokIdent "composeSubst",TokSymbol ",",TokIdent "apply",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Type",TokNewline,TokNewline,TokNewline,TokIdent "emptySubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokNewline,TokNewline,TokIdent "singletonSubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "composeSubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "s2",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "map",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokTypeIdent "M",TokDot,TokIdent "union",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "apply",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TUnit",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TUnit",TokSymbol "}",TokNewline,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "lookup",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "s",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "t'",TokSpace 1,TokArrow,TokSpace 1,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSymbol "}",TokNewline,TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TArrow",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TList",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "delete",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "vars",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TTuple",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "applyConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokSymbol "{",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "emptySubst",TokSymbol ",",TokIdent "singletonSubst",TokSymbol ",",TokIdent "composeSubst",TokSymbol ",",TokIdent "apply",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokNewline,TokNewline,TokKeyword "type",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Type",TokNewline,TokNewline,TokNewline,TokIdent "emptySubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokNewline,TokNewline,TokIdent "singletonSubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "composeSubst",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokSpace 1,TokIdent "s1",TokSpace 1,TokIdent "s2",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "M",TokDot,TokIdent "map",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokSpace 1,TokIdent "s2",TokSpace 1,TokUnknown '`',TokTypeIdent "M",TokDot,TokIdent "union",TokUnknown '`',TokSpace 1,TokIdent "s1",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "apply",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TUnit",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TUnit",TokSymbol "}",TokNewline,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokArrow,TokSymbol "{",TokKeyword "case",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "lookup",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "s",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "Just",TokSpace 1,TokIdent "t'",TokSpace 1,TokArrow,TokSpace 1,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TCon",TokSpace 1,TokIdent "c",TokSymbol "}",TokNewline,TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TArrow",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TList",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TApp",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokNewline,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokSymbol ";",TokKeyword "let",TokSpace 1,TokIdent "s'",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "foldr",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "delete",TokSpace 1,TokIdent "s",TokSpace 1,TokIdent "vars",TokSymbol "{",TokKeyword "in",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokIdent "vars",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokTypeIdent "TTuple",TokSpace 1,TokIdent "ts",TokSpace 1,TokArrow,TokSymbol "{",TokTypeIdent "TTuple",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "applyConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Constraint",TokSpace 1,TokIdent "cls",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Type.hs ===
-- Raw Source --
module TypeInference.Type where

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  deriving (Eq, Show)

-- Constraint の定義がまだ無い場合は仮で置く
data Constraint = Constraint String
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Type",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TCon",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TList",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TUnit",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokTypeIdent "String",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Type",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TCon",TokSpace 1,TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TArrow",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TList",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TApp",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TConstraint",TokSpace 1,TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TForall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TTuple",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "TUnit",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokTypeIdent "String",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/TypeEnv.hs ===
-- Raw Source --
module TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    emptyEnv,
    extendEnv,
    lookupEnv,
    generalize,
    instantiate,
    applyEnv,
    freeTypeVarsScheme,
    freeTypeVarsEnv,
    freeTypeVars,
  )
where

import AST.Expr (Name)
import AST.Type
import AST.Type (Type (..))
import Data.List (nub, (\\))
import qualified Data.Map as M
import TypeInference.Error (InferError (..))
import TypeInference.Subst

-- 型スキーム：forall a b. t
data Scheme = Forall [String] Type
  deriving (Show, Eq)

-- 型環境：変数名 → 型スキーム
newtype TypeEnv = TypeEnv (M.Map String Scheme)
  deriving (Show, Eq)

{-}
emptyEnv :: TypeEnv
emptyEnv = TypeEnv M.empty
-}

ftv :: Type -> Subst
ftv TUnit = M.empty

emptyEnv :: TypeEnv
emptyEnv = primitiveEnv

extendEnv :: TypeEnv -> String -> Scheme -> TypeEnv
extendEnv (TypeEnv env) x s = TypeEnv (M.insert x s env)

lookupEnv :: TypeEnv -> String -> Maybe Scheme
lookupEnv (TypeEnv env) x = M.lookup x env

freeTypeVarsEnv :: TypeEnv -> [Name]
freeTypeVarsEnv (TypeEnv env) =
  nub (concatMap freeTypeVarsScheme (M.elems env))

freeTypeVarsScheme :: Scheme -> [Name]
freeTypeVarsScheme (Forall vars t) =
  freeTypeVars t \\ vars

-- 型の自由変数を集める
freeTypeVars :: Type -> [String]
freeTypeVars t = case t of
  TVar v -> [v]
  TCon _ -> []
  TArrow t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TList t1 -> freeTypeVars t1
  TApp t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TConstraint cs t1 ->
    concatMap freeConstraintVars cs ++ freeTypeVars t1
  TForall vs t1 ->
    filter (`notElem` vs) (freeTypeVars t1)

freeConstraintVars :: Constraint -> [String]
freeConstraintVars (Constraint _ ts) =
  concatMap freeTypeVars ts

-- 環境の自由型変数
freeEnvVars :: TypeEnv -> [String]
freeEnvVars (TypeEnv env) =
  concatMap (\(Forall _ t) -> freeTypeVars t) (M.elems env)

-- 一般化：env の自由変数を除いた型変数を forall で束縛する
generalize :: TypeEnv -> Type -> Scheme
generalize env t =
  let envVars = freeEnvVars env
      typeVars = freeTypeVars t
      vars = filter (`notElem` envVars) typeVars
   in Forall vars t

-- 特殊化：forall を外し、新しい型変数に置き換える
{-}
instantiate :: Scheme -> Type
instantiate (Forall vars t) =
  let fresh v = TVar (v ++ "'") -- 簡易的な新しい型変数
      s = M.fromList [(v, fresh v) | v <- vars]
   in apply s t
-}
instantiate :: Scheme -> Either InferError Type
instantiate (Forall vars t) =
  Right (freshen vars t)

freshen :: [String] -> Type -> Type
freshen vars t =
  let newVars = M.fromList [(v, TVar ("t_" ++ v)) | v <- vars]
   in apply newVars t

applyEnv :: Subst -> TypeEnv -> TypeEnv
applyEnv s (TypeEnv env) =
  TypeEnv (M.map (\(Forall vs t) -> Forall vs (apply s t)) env)

primitiveEnv :: TypeEnv
primitiveEnv =
  TypeEnv
    ( M.fromList
        [ ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("==", Forall ["a"] (TArrow (TVar "a") (TArrow (TVar "a") (TCon "Bool"))))
        ]
    )


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "freeTypeVarsScheme",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "newtype",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "ftv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokNewline,TokIdent "emptyEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "primitiveEnv",TokNewline,TokNewline,TokIdent "extendEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "x",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokNewline,TokIdent "lookupEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "lookup",TokSpace 1,TokIdent "x",TokSpace 1,TokIdent "env",TokNewline,TokNewline,TokIdent "freeTypeVarsEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freeTypeVarsScheme",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "\\",TokSymbol "\\",TokSpace 1,TokIdent "vars",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "freeTypeVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokIdent "freeConstraintVars",TokSpace 1,TokIdent "cs",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSymbol "}",TokNewline,TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "filter",TokSpace 1,TokSymbol "(",TokUnknown '`',TokIdent "notElem",TokUnknown '`',TokIdent "vs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "freeConstraintVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "ts",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "freeEnvVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "generalize",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "envVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "freeEnvVars",TokSpace 1,TokIdent "env",TokSymbol "{",TokIdent "typeVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "filter",TokSpace 1,TokSymbol "(",TokUnknown '`',TokIdent "notElem",TokUnknown '`',TokIdent "envVars",TokSymbol ")",TokSpace 1,TokIdent "typeVars",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "instantiate",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freshen",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "newVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "fromList",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "vars",TokSymbol "]",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "newVars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "applyEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "primitiveEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "freeTypeVarsScheme",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSpace 1,TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSpace 1,TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSpace 1,TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSpace 1,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokTypeIdent "Type",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokKeyword "newtype",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "{",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "ftv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokNewline,TokIdent "emptyEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "primitiveEnv",TokNewline,TokNewline,TokIdent "extendEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "x",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokNewline,TokIdent "lookupEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Maybe",TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "lookup",TokSpace 1,TokIdent "x",TokSpace 1,TokIdent "env",TokNewline,TokNewline,TokIdent "freeTypeVarsEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "nub",TokSpace 1,TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freeTypeVarsScheme",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "\\",TokSymbol "\\",TokSpace 1,TokIdent "vars",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "freeTypeVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokIdent "freeConstraintVars",TokSpace 1,TokIdent "cs",TokSpace 1,TokOperator "++",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t1",TokSymbol "}",TokNewline,TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSymbol "{",TokIdent "filter",TokSpace 1,TokSymbol "(",TokUnknown '`',TokIdent "notElem",TokUnknown '`',TokIdent "vs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "freeConstraintVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "ts",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "freeEnvVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "concatMap",TokSpace 1,TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "generalize",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokSpace 1,TokIdent "env",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "envVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "freeEnvVars",TokSpace 1,TokIdent "env",TokSymbol "{",TokIdent "typeVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "freeTypeVars",TokSpace 1,TokIdent "t",TokSymbol ";",TokIdent "vars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "filter",TokSpace 1,TokSymbol "(",TokUnknown '`',TokIdent "notElem",TokUnknown '`',TokIdent "envVars",TokSymbol ")",TokSpace 1,TokIdent "typeVars",TokSymbol "}",TokNewline,TokKeyword "in",TokSpace 1,TokTypeIdent "Forall",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "instantiate",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Scheme",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "InferError",TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSpace 1,TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "freshen",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokIdent "newVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "M",TokDot,TokIdent "fromList",TokSpace 1,TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSpace 1,TokSymbol "|",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "vars",TokSymbol "]",TokSymbol "{",TokKeyword "in",TokSpace 1,TokIdent "apply",TokSpace 1,TokIdent "newVars",TokSpace 1,TokIdent "t",TokSymbol "}",TokSymbol "}",TokNewline,TokNewline,TokIdent "applyEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Subst",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokSpace 1,TokIdent "s",TokSpace 1,TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "primitiveEnv",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "TypeEnv",TokSymbol "{",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline])

=== Running: src/TypeInference/Unify.hs ===
-- Raw Source --
module TypeInference.Unify (Subst, unify, UnifyError) where

import AST.Type
import Control.Monad (unless)
import qualified Data.Map as M
import TypeInference.Subst

-- 型の一致に失敗したときのエラー
data UnifyError
  = UnifyMismatch Type Type
  | UnifyOccursCheckFailed String Type
  deriving (Show, Eq)

-- 型の一致を試み、成功すれば代入を返す
{-}
unify :: Type -> Type -> Either UnifyError Subst
unify TUnit TUnit = Right emptySubst
unify (TArrow l1 r1) (TArrow l2 r2) = do
  s1 <- unify l1 l2
  s2 <- unify (apply s1 r1) (apply s1 r2)
  return (composeSubst s2 s1)
unify (TApp f1 a1) (TApp f2 a2) = do
  s1 <- unify f1 f2
  s2 <- unify (apply s1 a1) (apply s1 a2)
  return (composeSubst s2 s1)
unify (TList t1) (TList t2) =
  unify t1 t2
unify (TCon c1) (TCon c2)
  | c1 == c2 = return emptySubst
  | otherwise = Left (UnifyMismatch (TCon c1) (TCon c2))
unify (TVar v) t = bindVar v t
unify t (TVar v) = bindVar v t
-- その他の型構成子は未対応（TConstraint, TForall など）
unify t1 t2 = Left (UnifyMismatch t1 t2)
-}
unify :: Type -> Type -> Either UnifyError Subst

-- 型変数
unify (TVar a) t = varBind a t
unify t (TVar a) = varBind a t

-- Unit
unify TUnit TUnit = Right emptySubst

-- 型コンストラクタ
unify (TCon a) (TCon b)
  | a == b    = Right emptySubst
  | otherwise = Left (UnifyMismatch (TCon a) (TCon b))

-- 関数型
unify (TArrow a1 b1) (TArrow a2 b2) = do
  s1 <- unify a1 a2
  s2 <- unify (apply s1 b1) (apply s1 b2)
  Right (s2 `composeSubst` s1)

-- タプル
unify (TTuple xs) (TTuple ys)
  | length xs == length ys = unifyMany xs ys
  | otherwise = Left (UnifyMismatch (TTuple xs) (TTuple ys))

-- リスト
unify (TList a) (TList b) = unify a b

-- デフォルト
unify t1 t2 = Left (UnifyMismatch t1 t2)

varBind :: String -> Type -> Either UnifyError Subst
varBind a t
  | t == TVar a = Right emptySubst
  | occursCheck a t = Left (UnifyOccursCheckFailed a t)
  | otherwise = Right (M.singleton a t)


occursCheck :: String -> Type -> Bool
occursCheck a (TVar b)       = a == b
occursCheck a (TCon _)       = False
occursCheck a TUnit          = False
occursCheck a (TList t)      = occursCheck a t
occursCheck a (TTuple ts)    = any (occursCheck a) ts
occursCheck a (TArrow t1 t2) = occursCheck a t1 || occursCheck a t2

unifyMany :: [Type] -> [Type] -> Either UnifyError Subst
unifyMany [] [] = Right emptySubst
unifyMany (t1:ts1) (t2:ts2) = do
  s1 <- unify t1 t2
  s2 <- unifyMany (map (apply s1) ts1) (map (apply s1) ts2)
  Right (s2 `composeSubst` s1)
unifyMany ts1 ts2 =
  Left (UnifyMismatch (TTuple ts1) (TTuple ts2))

-- 型変数と型を結びつける（occurs check あり）
bindVar :: String -> Type -> Either UnifyError Subst
bindVar v t
  | t == TVar v = return emptySubst
  | v `occursIn` t = Left (UnifyOccursCheckFailed v t)
  | otherwise = return (singletonSubst v t)

-- 型変数 v が型 t の中に現れるか（無限型を防ぐ）
occursIn :: String -> Type -> Bool
occursIn v t = case t of
  TVar x -> x == v
  TCon _ -> False
  TArrow t1 t2 -> occursIn v t1 || occursIn v t2
  TList t1 -> occursIn v t1
  TApp t1 t2 -> occursIn v t1 || occursIn v t2
  TConstraint cs t1 -> any (occursInConstraint v) cs || occursIn v t1
  TForall vs t1 -> if v `elem` vs then False else occursIn v t1

occursInConstraint :: String -> Constraint -> Bool
occursInConstraint v (Constraint _ ts) =
  any (occursIn v) ts


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "unify",TokSymbol ",",TokTypeIdent "UnifyError",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "unless",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "UnifyError",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "UnifyMismatch",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "UnifyOccursCheckFailed",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokIdent "unify",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "b",TokSpace 4,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a1",TokIdent "b1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a2",TokIdent "b2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "s1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "a1",TokSpace 1,TokIdent "a2",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "xs",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "ys",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "xs",TokSpace 1,TokIdent "ys",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "b",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokNewline,TokNewline,TokIdent "varBind",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "occursCheck",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSpace 7,TokSymbol "=",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "b",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokSymbol "_",TokSymbol ")",TokSpace 7,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokTypeIdent "TUnit",TokSpace 10,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSpace 6,TokSymbol "=",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSpace 4,TokSymbol "=",TokSpace 1,TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "ts",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t2",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t1",TokSymbol ":",TokIdent "ts1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "t2",TokSymbol ":",TokIdent "ts2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "s1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "unifyMany",TokSpace 1,TokIdent "ts1",TokSpace 1,TokIdent "ts2",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "bindVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "v",TokSpace 1,TokUnknown '`',TokIdent "occursIn",TokUnknown '`',TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "occursIn",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokSpace 1,TokIdent "cs",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "if",TokSpace 1,TokIdent "v",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokIdent "vs",TokSpace 1,TokKeyword "then",TokSpace 1,TokTypeIdent "False",TokSpace 1,TokKeyword "else",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol "}",TokNewline,TokNewline,TokIdent "occursInConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokSpace 1,TokIdent "ts",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSpace 1,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "unify",TokSymbol ",",TokTypeIdent "UnifyError",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "unless",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokIdent "qualified",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokSpace 1,TokIdent "as",TokSpace 1,TokTypeIdent "M",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokKeyword "data",TokSpace 1,TokTypeIdent "UnifyError",TokSymbol "{",TokSymbol "=",TokSpace 1,TokTypeIdent "UnifyMismatch",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokSpace 1,TokTypeIdent "UnifyOccursCheckFailed",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokTypeIdent "Type",TokSymbol ";",TokIdent "deriving",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokIdent "unify",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokTypeIdent "TUnit",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "b",TokSpace 4,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a1",TokIdent "b1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a2",TokIdent "b2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "s1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "a1",TokSpace 1,TokIdent "a2",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "xs",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "length",TokSpace 1,TokIdent "ys",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokIdent "xs",TokSpace 1,TokIdent "ys",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "a",TokSymbol ")",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "b",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "b",TokNewline,TokNewline,TokNewline,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokNewline,TokNewline,TokIdent "varBind",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "varBind",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "occursCheck",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSpace 7,TokSymbol "=",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "b",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TCon",TokSymbol "_",TokSymbol ")",TokSpace 7,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokTypeIdent "TUnit",TokSpace 10,TokSymbol "=",TokSpace 1,TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSpace 6,TokSymbol "=",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSpace 4,TokSymbol "=",TokSpace 1,TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokSpace 1,TokIdent "ts",TokNewline,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursCheck",TokSpace 1,TokIdent "a",TokSpace 1,TokIdent "t2",TokNewline,TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Right",TokSpace 1,TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "t1",TokSymbol ":",TokIdent "ts1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "t2",TokSymbol ":",TokIdent "ts2",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "s1",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unify",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "unifyMany",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSpace 1,TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst",TokUnknown '`',TokIdent "s1",TokSymbol ")",TokSymbol "}",TokNewline,TokIdent "unifyMany",TokSpace 1,TokIdent "ts1",TokSpace 1,TokIdent "ts2",TokSpace 1,TokSymbol "=",TokSymbol "{",TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "bindVar",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Either",TokSpace 1,TokTypeIdent "UnifyError",TokSpace 1,TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t",TokSymbol "{",TokSymbol "|",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "==",TokSpace 1,TokTypeIdent "TVar",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "v",TokSpace 1,TokUnknown '`',TokIdent "occursIn",TokUnknown '`',TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Left",TokSpace 1,TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokSpace 1,TokIdent "otherwise",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "return",TokSpace 1,TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokNewline,TokIdent "occursIn",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Type",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t",TokSpace 1,TokSymbol "=",TokSpace 1,TokKeyword "case",TokSpace 1,TokIdent "t",TokSpace 1,TokKeyword "of",TokSymbol "{",TokTypeIdent "TVar",TokSpace 1,TokIdent "x",TokSpace 1,TokArrow,TokSpace 1,TokIdent "x",TokSpace 1,TokSymbol "==",TokSpace 1,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSpace 1,TokSymbol "_",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokSpace 1,TokIdent "t1",TokSpace 1,TokIdent "t2",TokSpace 1,TokArrow,TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokSpace 1,TokIdent "cs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokSpace 1,TokIdent "cs",TokSpace 1,TokSymbol "|",TokSymbol "|",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokSpace 1,TokIdent "vs",TokSpace 1,TokIdent "t1",TokSpace 1,TokArrow,TokSpace 1,TokKeyword "if",TokSpace 1,TokIdent "v",TokSpace 1,TokUnknown '`',TokIdent "elem",TokUnknown '`',TokSpace 1,TokIdent "vs",TokSpace 1,TokKeyword "then",TokSpace 1,TokTypeIdent "False",TokSpace 1,TokKeyword "else",TokSpace 1,TokIdent "occursIn",TokSpace 1,TokIdent "v",TokSpace 1,TokIdent "t1",TokSymbol "}",TokNewline,TokNewline,TokIdent "occursInConstraint",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Constraint",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokSpace 1,TokIdent "v",TokSpace 1,TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "any",TokSpace 1,TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokSpace 1,TokIdent "ts",TokSymbol "}",TokNewline])

=== Running: src/Utils/MyTrace.hs ===
-- Raw Source --
{- NOINLINE traceEnabled -}

module Utils.MyTrace (myTrace, myTraceIO, myTraceShowId, traceEnabled, setTrace) where

import Control.Monad (when)
import Data.IORef
import Debug.Trace (trace, traceIO, traceShowId)
import Parser.Core.Combinator (Parser (..))
import System.IO.Unsafe (unsafePerformIO)

traceEnabled :: IORef Bool
traceEnabled = unsafePerformIO (newIORef True)

setTrace :: Bool -> IO ()
setTrace b = writeIORef traceEnabled b

myTrace :: String -> Parser ()
myTrace msg = Parser $ \input -> unsafePerformIO $ do
  enabled <- readIORef traceEnabled
  when enabled (putStrLn msg)
  return (Just ((), input))

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: (Show a) => a -> a
myTraceShowId = traceShowId

{-}
#ifdef ENABLE_TRACE
myTrace :: String -> a -> a
myTrace = trace

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: Show a => a -> a
myTraceShowId = traceShowId
#else
myTrace :: String -> a -> a
myTrace _ x = x

myTraceIO :: String -> IO ()
myTraceIO _ = pure ()

myTraceShowId :: Show a => a -> a
myTraceShowId = id
#endif
-}

-- Tokens from Lexer --
[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ",",TokIdent "myTraceIO",TokSymbol ",",TokIdent "myTraceShowId",TokSymbol ",",TokIdent "traceEnabled",TokSymbol ",",TokIdent "setTrace",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "when",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokNewline,TokIdent "traceEnabled",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "traceEnabled",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokTypeIdent "True",TokSymbol ")",TokNewline,TokNewline,TokIdent "setTrace",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Bool",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "setTrace",TokSpace 1,TokIdent "b",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "writeIORef",TokSpace 1,TokIdent "traceEnabled",TokSpace 1,TokIdent "b",TokNewline,TokNewline,TokIdent "myTrace",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTrace",TokSpace 1,TokIdent "msg",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "enabled",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "readIORef",TokSpace 1,TokIdent "traceEnabled",TokSymbol ";",TokIdent "when",TokSpace 1,TokIdent "enabled",TokSpace 1,TokSymbol "(",TokIdent "putStrLn",TokIdent "msg",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "myTraceIO",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTraceIO",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "traceIO",TokNewline,TokNewline,TokIdent "myTraceShowId",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokIdent "a",TokSymbol ")",TokSpace 1,TokKeyword "=>",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokIdent "a",TokNewline,TokIdent "myTraceShowId",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "traceShowId",TokNewline,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokNewline,TokNewline,TokKeyword "module",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSpace 1,TokSymbol "(",TokIdent "myTrace",TokSymbol ",",TokIdent "myTraceIO",TokSymbol ",",TokIdent "myTraceShowId",TokSymbol ",",TokIdent "traceEnabled",TokSymbol ",",TokIdent "setTrace",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSpace 1,TokSymbol "(",TokIdent "when",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSpace 1,TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSpace 1,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokSpace 1,TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSpace 1,TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokNewline,TokIdent "traceEnabled",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "IORef",TokSpace 1,TokTypeIdent "Bool",TokNewline,TokIdent "traceEnabled",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokSymbol "(",TokIdent "newIORef",TokTypeIdent "True",TokSymbol ")",TokNewline,TokNewline,TokIdent "setTrace",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "Bool",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "setTrace",TokSpace 1,TokIdent "b",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "writeIORef",TokSpace 1,TokIdent "traceEnabled",TokSpace 1,TokIdent "b",TokNewline,TokNewline,TokIdent "myTrace",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTrace",TokSpace 1,TokIdent "msg",TokSpace 1,TokSymbol "=",TokSpace 1,TokTypeIdent "Parser",TokSpace 1,TokUnknown '$',TokSpace 1,TokSymbol "\\",TokIdent "input",TokSpace 1,TokArrow,TokSpace 1,TokIdent "unsafePerformIO",TokSpace 1,TokUnknown '$',TokSpace 1,TokKeyword "do",TokSymbol "{",TokIdent "enabled",TokSpace 1,TokSymbol "<-",TokSpace 1,TokIdent "readIORef",TokSpace 1,TokIdent "traceEnabled",TokSymbol ";",TokIdent "when",TokSpace 1,TokIdent "enabled",TokSpace 1,TokSymbol "(",TokIdent "putStrLn",TokIdent "msg",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSpace 1,TokSymbol "(",TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ")",TokSymbol "}",TokNewline,TokNewline,TokIdent "myTraceIO",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokTypeIdent "IO",TokSpace 1,TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTraceIO",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "traceIO",TokNewline,TokNewline,TokIdent "myTraceShowId",TokSpace 1,TokSymbol "::",TokSpace 1,TokSymbol "(",TokTypeIdent "Show",TokIdent "a",TokSymbol ")",TokSpace 1,TokKeyword "=>",TokSpace 1,TokIdent "a",TokSpace 1,TokArrow,TokSpace 1,TokIdent "a",TokNewline,TokIdent "myTraceShowId",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "traceShowId",TokNewline,TokNewline])

=== Running: src/Utils/SQLUtils.hs ===
-- Raw Source --
module Utils.SQLUtils (extractSQLVars) where

extractSQLVars :: String -> (String, [String])
extractSQLVars = go "" [] ""
  where
    go acc vars current [] =
      (acc, reverse vars)

    go acc vars current ('{':xs) =
      let (var, rest) = span (/= '}') xs
      in go (acc ++ "?") (var : vars) "" (drop 1 rest)

    go acc vars current (x:xs) =
      go (acc ++ [x]) vars current xs


-- Tokens from Lexer --
[TokKeyword "module",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokSpace 1,TokSymbol "(",TokIdent "extractSQLVars",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokIdent "extractSQLVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "extractSQLVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokString "",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokString "",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "(",TokChar '{',TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokSymbol "(",TokSymbol "/=",TokChar '}',TokSymbol ")",TokSpace 1,TokIdent "xs",TokSymbol ";",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "var",TokSymbol ":",TokIdent "vars",TokSymbol ")",TokSpace 1,TokString "",TokSpace 1,TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokIdent "xs",TokSymbol "}",TokSymbol "}",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
Just ([],[TokKeyword "module",TokSpace 1,TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokSpace 1,TokSymbol "(",TokIdent "extractSQLVars",TokSymbol ")",TokSpace 1,TokKeyword "where",TokNewline,TokNewline,TokIdent "extractSQLVars",TokSpace 1,TokSymbol "::",TokSpace 1,TokTypeIdent "String",TokSpace 1,TokArrow,TokSpace 1,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "extractSQLVars",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "go",TokSpace 1,TokString "",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokString "",TokSymbol "{",TokKeyword "where",TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "[",TokSymbol "]",TokSpace 1,TokSymbol "=",TokSymbol "{",TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "(",TokChar '{',TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokKeyword "let",TokSpace 1,TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSpace 1,TokIdent "span",TokSpace 1,TokSymbol "(",TokSymbol "/=",TokChar '}',TokSymbol ")",TokSpace 1,TokIdent "xs",TokSymbol ";",TokKeyword "in",TokSpace 1,TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSpace 1,TokSymbol "(",TokIdent "var",TokSymbol ":",TokIdent "vars",TokSymbol ")",TokSpace 1,TokString "",TokSpace 1,TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokSymbol "}",TokSymbol "}",TokNewline,TokSymbol "{",TokIdent "go",TokSpace 1,TokIdent "acc",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokSymbol "(",TokIdent "x",TokSymbol ":",TokIdent "xs",TokSymbol ")",TokSpace 1,TokSymbol "=",TokSymbol "{",TokIdent "go",TokSpace 1,TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokSpace 1,TokIdent "vars",TokSpace 1,TokIdent "current",TokSpace 1,TokIdent "xs",TokSymbol "}",TokSymbol "}",TokNewline])

