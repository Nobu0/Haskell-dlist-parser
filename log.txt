=== Running: src/AST/Decl.hs ===
Resolving dependencies...
Build profile: -w ghc-9.6.7 -O1
In order, the following will be built (use -v for more details):
 - dlist-parser-0.1.0.0 (exe:myapp) (file src\Parser\Core\TokenParser.hs changed)
Preprocessing executable 'myapp' for dlist-parser-0.1.0.0...
Building executable 'myapp' for dlist-parser-0.1.0.0...
[13 of 32] Compiling Parser.Core.TokenParser ( src\Parser\Core\TokenParser.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\myapp\build\myapp\myapp-tmp\Parser\Core\TokenParser.o ) [Source file changed]
[15 of 32] Compiling Parser.Expr.PatternParser ( src\Parser\Expr\PatternParser.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\myapp\build\myapp\myapp-tmp\Parser\Expr\PatternParser.o ) [Parser.Core.TokenParser changed]
[24 of 32] Compiling Decl.DeclParser.Util ( src\Decl\DeclParser\Util.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\myapp\build\myapp\myapp-tmp\Decl\DeclParser\Util.o ) [Parser.Core.TokenParser changed]
[27 of 32] Compiling Decl.DeclParser.Import ( src\Decl\DeclParser\Import.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\myapp\build\myapp\myapp-tmp\Decl\DeclParser\Import.o ) [Parser.Core.TokenParser changed]
[33 of 33] Linking C:\\Users\\blue3\\haskell\\dlist-parser\\dist-newstyle\\build\\x86_64-windows\\ghc-9.6.7\\dlist-parser-0.1.0.0\\x\\myapp\\build\\myapp\\myapp.exe [Objects changed]
-- Raw Source --
module AST.Decl where

import AST.Expr
import AST.Pattern (Pattern)
import AST.Type (Constraint, Type)

-- DeclFun Name [Pattern] (Maybe [(Expr, Expr)]) (Maybe Expr) (Maybe [Decl])

data Decl
  = DeclFunGroup Name [FunClause]
  | DeclValue Pattern Expr
  | DeclTypeSig Name Type
  | DeclData Name [Name] [Constraint] [Name]
  | DeclNewtype Name [Name] Constraint
  | DeclModule String (Maybe [Export])
  | DeclClass String [String] [Decl]
  | DeclInstance (Maybe [Constraint]) String [Type] [Decl]
  | DeclTypeAlias String [String] Type
  | DeclImport
      { importQualified :: Bool,
        importModule :: Name,
        importAlias :: Maybe Name,
        importHiding :: Bool,
        importItems :: Maybe [ImportItem]
      }
  deriving (Show, Eq)

data FunClause
  = FunClause
      [Pattern]
      (Maybe [(Expr, Expr)])
      (Maybe Expr)
      (Maybe [Decl])
  deriving (Show, Eq)

data ImportItem
  = ImportVar Name
  | ImportTypeAll Name
  | ImportTypeSome Name [Name]
  | ImportAllItems -- ← 追加！
  deriving (Show, Eq)

data Export
  = ExportVar String -- foo
  | ExportType String Bool -- Bar or Bar(..)
  deriving (Show, Eq)

-- data Constr = Constr Name [Type]
--  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "Decl",TokVLBrace,TokSymbol "=",TokTypeIdent "DeclFunGroup",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "FunClause",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclValue",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclTypeSig",TokTypeIdent "Name",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclData",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclNewtype",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokTypeIdent "Constraint",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclModule",TokTypeIdent "String",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclClass",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclInstance",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ")",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclTypeAlias",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclImport",TokVLBrace,TokSymbol "{",TokIdent "importQualified",TokSymbol "::",TokTypeIdent "Bool",TokSymbol ",",TokVLBrace,TokIdent "importModule",TokSymbol "::",TokTypeIdent "Name",TokSymbol ",",TokSymbol ";",TokIdent "importAlias",TokSymbol "::",TokTypeIdent "Maybe",TokTypeIdent "Name",TokSymbol ",",TokSymbol ";",TokIdent "importHiding",TokSymbol "::",TokTypeIdent "Bool",TokSymbol ",",TokSymbol ";",TokIdent "importItems",TokSymbol "::",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "ImportItem",TokSymbol "]",TokVRBrace,TokNewline,TokSymbol "}",TokVRBrace,TokNewline,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "=",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "ImportItem",TokVLBrace,TokSymbol "=",TokTypeIdent "ImportVar",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeAll",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeSome",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportAllItems",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Export",TokVLBrace,TokSymbol "=",TokTypeIdent "ExportVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "ExportType",TokTypeIdent "String",TokTypeIdent "Bool",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Decl" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Constraint",ImportVar "Type"]}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Name"
<< parseTypeCore: TCon "FunClause"
<< dataConstrNormal: "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "DeclValue" [TCon "Pattern",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Name"
<< dataConstrNormal: "DeclTypeSig" [TCon "Name",TCon "Type"]
<< dataConstrRecord: TokTypeIdent "Name"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "Constraint"
<< parseTypeCore: TCon "Name"
<< dataConstrNormal: "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")]
<< dataConstrRecord: TokTypeIdent "Name"
<< parseTypeCore: TCon "Name"
<< dataConstrNormal: "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"]
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "Export"
<< parseTypeCore: TApp (TCon "Maybe") (TList (TCon "Export"))
<< dataConstrNormal: "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))]
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Decl"
<< dataConstrNormal: "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")]
<< dataConstrRecord: TokSymbol "("
<< parseTypeCore: TCon "Constraint"
<< parseTypeCore: TApp (TCon "Maybe") (TList (TCon "Constraint"))
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TCon "Decl"
<< dataConstrNormal: "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")]
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< dataConstrNormal: "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"]
<< dataConstrRecord: TokSymbol "{"
<< parseTypeCore: TCon "ImportItem"
<< dataConstrRecord: "DeclImport" [Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem"))),Field "importHiding" (TCon "Bool"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importModule" (TCon "Name"),Field "importQualified" (TCon "Bool")]
<< declBody: return DeclData "Decl" [] [Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")],Constraint "DeclValue" [TCon "Pattern",TCon "Expr"],Constraint "DeclTypeSig" [TCon "Name",TCon "Type"],Constraint "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")],Constraint "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"],Constraint "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))],Constraint "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")],Constraint "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")],Constraint "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"],ConstraintRecord "DeclImport" [Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem"))),Field "importHiding" (TCon "Bool"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importModule" (TCon "Name"),Field "importQualified" (TCon "Bool")]] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokSymbol "["
<< dataConstrNormal: "FunClause" []
Just ([DeclModule "AST.Decl" Nothing,DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Constraint",ImportVar "Type"]},DeclData "Decl" [] [Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")],Constraint "DeclValue" [TCon "Pattern",TCon "Expr"],Constraint "DeclTypeSig" [TCon "Name",TCon "Type"],Constraint "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")],Constraint "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"],Constraint "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))],Constraint "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")],Constraint "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")],Constraint "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"],ConstraintRecord "DeclImport" [Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem"))),Field "importHiding" (TCon "Bool"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importModule" (TCon "Name"),Field "importQualified" (TCon "Bool")]] ["Show","Eq"]],[TokNewline,TokKeyword "data",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "=",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "ImportItem",TokVLBrace,TokSymbol "=",TokTypeIdent "ImportVar",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeAll",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeSome",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportAllItems",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Export",TokVLBrace,TokSymbol "=",TokTypeIdent "ExportVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "ExportType",TokTypeIdent "String",TokTypeIdent "Bool",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/AST/Expr.hs ===
-- Raw Source --
module AST.Expr where

import AST.Pattern (Pattern)
import AST.Type (Type)

type Name = String

-- Binding
type Binding = (Pattern, Expr)

-- CaseAlt
data CaseAlt
  = CaseAlt Pattern Expr
  | CaseAltGuard Pattern [(Expr, Expr)]
  deriving (Eq, Show)

-- Stmt
data Stmt
  = Bind Pattern Expr
  | ExprStmt Expr
  | LetStmt [(Pattern, Expr)]
  deriving (Eq, Show)

-- Qualifier
data Qualifier
  = QGenerator Pattern Expr
  | QLet [(Pattern, Expr)]
  | QGuard Expr
  deriving (Eq, Show)

-- Expr 本体
data Expr
  = EVar String
  | EVarType String
  | EInt Int
  | EString String
  | EChar Char
  | EBinOp BinOp Expr Expr
  | EBool Bool
  | ELet Pattern Expr Expr
  | ELetBlock [(Pattern, Expr)] Expr
  | EIf Expr Expr Expr
  | ELam Pattern Expr
  | EApp Expr Expr
  | ECase Expr [CaseAlt]
  | EList [Expr]
  | ETuple [Expr]
  | ERange Expr Expr
  | ERangeStep Expr Expr Expr
  | EListComp Expr [Qualifier]
  | EAnn Expr Type
  | EDo [Stmt]
  | ESeq [Expr]
  | EReturn Expr
  | EUnit
  | ERecord [(String, Expr)]
  | ERecordUpdate Expr [(String, Expr)]
  | EOpSectionL String Expr
  | EOpSectionR Expr String
  | EPlaceholder
  | EWhere Expr [Binding]
  | ELambdaCase [CaseAlt] -- [(Pattern, Expr)]
  | ESQL String [Expr]
  deriving (Eq, Show)

data BinOp
  = Add
  | Sub
  | Mul
  | Div
  | And
  | Or
  | Eq
  | Neq
  | Lt
  | Gt
  | Le
  | Ge
  | Concat
  | Cons
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "type",TokTypeIdent "Binding",TokSymbol "=",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "CaseAlt",TokVLBrace,TokSymbol "=",TokTypeIdent "CaseAlt",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "CaseAltGuard",TokTypeIdent "Pattern",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Stmt",TokVLBrace,TokSymbol "=",TokTypeIdent "Bind",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ExprStmt",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "LetStmt",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Qualifier",TokVLBrace,TokSymbol "=",TokTypeIdent "QGenerator",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "QLet",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "QGuard",TokTypeIdent "Expr",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Expr",TokVLBrace,TokSymbol "=",TokTypeIdent "EVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EVarType",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "EString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "EBinOp",TokTypeIdent "BinOp",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EBool",TokTypeIdent "Bool",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELet",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELetBlock",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EIf",TokTypeIdent "Expr",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELam",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EApp",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ECase",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EList",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ETuple",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERange",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERangeStep",TokTypeIdent "Expr",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EListComp",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "Qualifier",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EAnn",TokTypeIdent "Expr",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "EDo",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ESeq",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EReturn",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EUnit",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERecord",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERecordUpdate",TokTypeIdent "Expr",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EOpSectionL",TokTypeIdent "String",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EOpSectionR",TokTypeIdent "Expr",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EPlaceholder",TokSymbol ";",TokSymbol "|",TokTypeIdent "EWhere",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELambdaCase",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ESQL",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "BinOp",TokVLBrace,TokSymbol "=",TokTypeIdent "Add",TokSymbol ";",TokSymbol "|",TokTypeIdent "Sub",TokSymbol ";",TokSymbol "|",TokTypeIdent "Mul",TokSymbol ";",TokSymbol "|",TokTypeIdent "Div",TokSymbol ";",TokSymbol "|",TokTypeIdent "And",TokSymbol ";",TokSymbol "|",TokTypeIdent "Or",TokSymbol ";",TokSymbol "|",TokTypeIdent "Eq",TokSymbol ";",TokSymbol "|",TokTypeIdent "Neq",TokSymbol ";",TokSymbol "|",TokTypeIdent "Lt",TokSymbol ";",TokSymbol "|",TokTypeIdent "Gt",TokSymbol ";",TokSymbol "|",TokTypeIdent "Le",TokSymbol ";",TokSymbol "|",TokTypeIdent "Ge",TokSymbol ";",TokSymbol "|",TokTypeIdent "Concat",TokSymbol ";",TokSymbol "|",TokTypeIdent "Cons",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Expr" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Type"]}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokSymbol "("
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< declBody: return DeclTypeAlias "Binding" [] (TTuple [TCon "Pattern",TCon "Expr"])
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "CaseAlt" [TCon "Pattern",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Expr",TCon "Expr"]
<< dataConstrNormal: "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]
<< declBody: return DeclData "CaseAlt" [] [Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"],Constraint "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "Bind" [TCon "Pattern",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "ExprStmt" [TCon "Expr"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrNormal: "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]
<< declBody: return DeclData "Stmt" [] [Constraint "Bind" [TCon "Pattern",TCon "Expr"],Constraint "ExprStmt" [TCon "Expr"],Constraint "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "QGenerator" [TCon "Pattern",TCon "Expr"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrNormal: "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "QGuard" [TCon "Expr"]
<< declBody: return DeclData "Qualifier" [] [Constraint "QGenerator" [TCon "Pattern",TCon "Expr"],Constraint "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])],Constraint "QGuard" [TCon "Expr"]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "EVar" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "EVarType" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Int"
<< dataConstrNormal: "EInt" [TCon "Int"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "EString" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Char"
<< dataConstrNormal: "EChar" [TCon "Char"]
<< dataConstrRecord: TokTypeIdent "BinOp"
<< dataConstrNormal: "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Bool"
<< dataConstrNormal: "EBool" [TCon "Bool"]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrNormal: "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "ELam" [TCon "Pattern",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "EApp" [TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< parseTypeCore: TCon "CaseAlt"
<< dataConstrNormal: "ECase" [TCon "Expr",TList (TCon "CaseAlt")]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Expr"
<< dataConstrNormal: "EList" [TList (TCon "Expr")]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Expr"
<< dataConstrNormal: "ETuple" [TList (TCon "Expr")]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "ERange" [TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< parseTypeCore: TCon "Qualifier"
<< dataConstrNormal: "EListComp" [TCon "Expr",TList (TCon "Qualifier")]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "EAnn" [TCon "Expr",TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Stmt"
<< dataConstrNormal: "EDo" [TList (TCon "Stmt")]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Expr"
<< dataConstrNormal: "ESeq" [TList (TCon "Expr")]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "EReturn" [TCon "Expr"]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "EUnit" []
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "String",TCon "Expr"]
<< dataConstrNormal: "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])]
<< dataConstrRecord: TokTypeIdent "Expr"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "String",TCon "Expr"]
<< dataConstrNormal: "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "EOpSectionL" [TCon "String",TCon "Expr"]
<< dataConstrRecord: TokTypeIdent "Expr"
<< dataConstrNormal: "EOpSectionR" [TCon "Expr",TCon "String"]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "EPlaceholder" []
<< dataConstrRecord: TokTypeIdent "Expr"
<< parseTypeCore: TCon "Binding"
<< dataConstrNormal: "EWhere" [TCon "Expr",TList (TCon "Binding")]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "CaseAlt"
<< dataConstrNormal: "ELambdaCase" [TList (TCon "CaseAlt")]
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "Expr"
<< dataConstrNormal: "ESQL" [TCon "String",TList (TCon "Expr")]
<< declBody: return DeclData "Expr" [] [Constraint "EVar" [TCon "String"],Constraint "EVarType" [TCon "String"],Constraint "EInt" [TCon "Int"],Constraint "EString" [TCon "String"],Constraint "EChar" [TCon "Char"],Constraint "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"],Constraint "EBool" [TCon "Bool"],Constraint "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"],Constraint "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"],Constraint "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "ELam" [TCon "Pattern",TCon "Expr"],Constraint "EApp" [TCon "Expr",TCon "Expr"],Constraint "ECase" [TCon "Expr",TList (TCon "CaseAlt")],Constraint "EList" [TList (TCon "Expr")],Constraint "ETuple" [TList (TCon "Expr")],Constraint "ERange" [TCon "Expr",TCon "Expr"],Constraint "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "EListComp" [TCon "Expr",TList (TCon "Qualifier")],Constraint "EAnn" [TCon "Expr",TCon "Type"],Constraint "EDo" [TList (TCon "Stmt")],Constraint "ESeq" [TList (TCon "Expr")],Constraint "EReturn" [TCon "Expr"],Constraint "EUnit" [],Constraint "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])],Constraint "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])],Constraint "EOpSectionL" [TCon "String",TCon "Expr"],Constraint "EOpSectionR" [TCon "Expr",TCon "String"],Constraint "EPlaceholder" [],Constraint "EWhere" [TCon "Expr",TList (TCon "Binding")],Constraint "ELambdaCase" [TList (TCon "CaseAlt")],Constraint "ESQL" [TCon "String",TList (TCon "Expr")]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Add" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Sub" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Mul" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Div" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "And" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Or" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Eq" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Neq" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Lt" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Gt" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Le" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Ge" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "Concat" []
<< dataConstrRecord: TokKeyword "deriving"
<< dataConstrNormal: "Cons" []
<< declBody: return DeclData "BinOp" [] [Constraint "Add" [],Constraint "Sub" [],Constraint "Mul" [],Constraint "Div" [],Constraint "And" [],Constraint "Or" [],Constraint "Eq" [],Constraint "Neq" [],Constraint "Lt" [],Constraint "Gt" [],Constraint "Le" [],Constraint "Ge" [],Constraint "Concat" [],Constraint "Cons" []] ["Eq","Show"]
Just ([DeclModule "AST.Expr" Nothing,DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Type"]},DeclTypeAlias "Name" [] (TCon "String"),DeclTypeAlias "Binding" [] (TTuple [TCon "Pattern",TCon "Expr"]),DeclData "CaseAlt" [] [Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"],Constraint "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]] ["Eq","Show"],DeclData "Stmt" [] [Constraint "Bind" [TCon "Pattern",TCon "Expr"],Constraint "ExprStmt" [TCon "Expr"],Constraint "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]] ["Eq","Show"],DeclData "Qualifier" [] [Constraint "QGenerator" [TCon "Pattern",TCon "Expr"],Constraint "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])],Constraint "QGuard" [TCon "Expr"]] ["Eq","Show"],DeclData "Expr" [] [Constraint "EVar" [TCon "String"],Constraint "EVarType" [TCon "String"],Constraint "EInt" [TCon "Int"],Constraint "EString" [TCon "String"],Constraint "EChar" [TCon "Char"],Constraint "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"],Constraint "EBool" [TCon "Bool"],Constraint "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"],Constraint "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"],Constraint "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "ELam" [TCon "Pattern",TCon "Expr"],Constraint "EApp" [TCon "Expr",TCon "Expr"],Constraint "ECase" [TCon "Expr",TList (TCon "CaseAlt")],Constraint "EList" [TList (TCon "Expr")],Constraint "ETuple" [TList (TCon "Expr")],Constraint "ERange" [TCon "Expr",TCon "Expr"],Constraint "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "EListComp" [TCon "Expr",TList (TCon "Qualifier")],Constraint "EAnn" [TCon "Expr",TCon "Type"],Constraint "EDo" [TList (TCon "Stmt")],Constraint "ESeq" [TList (TCon "Expr")],Constraint "EReturn" [TCon "Expr"],Constraint "EUnit" [],Constraint "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])],Constraint "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])],Constraint "EOpSectionL" [TCon "String",TCon "Expr"],Constraint "EOpSectionR" [TCon "Expr",TCon "String"],Constraint "EPlaceholder" [],Constraint "EWhere" [TCon "Expr",TList (TCon "Binding")],Constraint "ELambdaCase" [TList (TCon "CaseAlt")],Constraint "ESQL" [TCon "String",TList (TCon "Expr")]] ["Eq","Show"],DeclData "BinOp" [] [Constraint "Add" [],Constraint "Sub" [],Constraint "Mul" [],Constraint "Div" [],Constraint "And" [],Constraint "Or" [],Constraint "Eq" [],Constraint "Neq" [],Constraint "Lt" [],Constraint "Gt" [],Constraint "Le" [],Constraint "Ge" [],Constraint "Concat" [],Constraint "Cons" []] ["Eq","Show"]],[TokNewline])

=== Running: src/AST/Module.hs ===
-- Raw Source --
module AST.Module where

import AST.Type
import AST.Decl (Decl)

type Name = String

data Module = Module
  { moduleName :: Name
  , moduleImports :: [Import]
  , moduleDecls :: [Decl]
  }
  deriving (Show, Eq)

data Import = Import
  { importName :: Name
  }
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "data",TokTypeIdent "Module",TokSymbol "=",TokTypeIdent "Module",TokVLBrace,TokSymbol "{",TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol ",",TokIdent "moduleImports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Import",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "moduleDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Import",TokSymbol "=",TokTypeIdent "Import",TokVLBrace,TokSymbol "{",TokIdent "importName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Module" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Decl"]}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokSymbol "{"
<< parseTypeCore: TCon "Import"
<< parseTypeCore: TCon "Decl"
<< dataConstrRecord: "Module" [Field "moduleDecls" (TList (TCon "Decl")),Field "moduleImports" (TList (TCon "Import")),Field "moduleName" (TCon "Name")]
<< declBody: return DeclData "Module" [] [ConstraintRecord "Module" [Field "moduleDecls" (TList (TCon "Decl")),Field "moduleImports" (TList (TCon "Import")),Field "moduleName" (TCon "Name")]] ["Show","Eq"]
<< decl next token: TokVRBrace
<< decl parser called
<< decl dispatch: TokVRBrace
<< unknown token in decl: TokVRBrace
Just ([DeclModule "AST.Module" Nothing,DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Decl"]},DeclTypeAlias "Name" [] (TCon "String"),DeclData "Module" [] [ConstraintRecord "Module" [Field "moduleDecls" (TList (TCon "Decl")),Field "moduleImports" (TList (TCon "Import")),Field "moduleName" (TCon "Name")]] ["Show","Eq"]],[TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Import",TokSymbol "=",TokTypeIdent "Import",TokVLBrace,TokSymbol "{",TokIdent "importName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/AST/Pattern.hs ===
-- Raw Source --
module AST.Pattern where

-- import AST.Type (Type)
-- import AST.Module (Name)
-- import AST.Pattern (Pattern)
-- import AST.Expr (Expr)

type Name = String

data Pattern
  = PVar Name
  | PInt Int
  | PChar Char
  | PString String
  | PWildcard
  | PCons Pattern Pattern
  | PList [Pattern]
  | PTuple [Pattern]
  | PConstr Name [Pattern]
  | PAs Name Pattern -- ← 追加！
  | PApp Pattern [Pattern] -- ★ 修正
  | PInfix Pattern Name Pattern
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokKeyword "where",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "data",TokTypeIdent "Pattern",TokVLBrace,TokSymbol "=",TokTypeIdent "PVar",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "PInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "PChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "PString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "PWildcard",TokSymbol ";",TokSymbol "|",TokTypeIdent "PCons",TokTypeIdent "Pattern",TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokTypeIdent "PList",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PTuple",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PConstr",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PAs",TokTypeIdent "Name",TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokTypeIdent "PApp",TokTypeIdent "Pattern",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PInfix",TokTypeIdent "Pattern",TokTypeIdent "Name",TokTypeIdent "Pattern",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Pattern" Nothing
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Name"
<< dataConstrNormal: "PVar" [TCon "Name"]
<< dataConstrRecord: TokTypeIdent "Int"
<< dataConstrNormal: "PInt" [TCon "Int"]
<< dataConstrRecord: TokTypeIdent "Char"
<< dataConstrNormal: "PChar" [TCon "Char"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "PString" [TCon "String"]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "PWildcard" []
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "PCons" [TCon "Pattern",TCon "Pattern"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< dataConstrNormal: "PList" [TList (TCon "Pattern")]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< dataConstrNormal: "PTuple" [TList (TCon "Pattern")]
<< dataConstrRecord: TokTypeIdent "Name"
<< parseTypeCore: TCon "Pattern"
<< dataConstrNormal: "PConstr" [TCon "Name",TList (TCon "Pattern")]
<< dataConstrRecord: TokTypeIdent "Name"
<< dataConstrNormal: "PAs" [TCon "Name",TCon "Pattern"]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< parseTypeCore: TCon "Pattern"
<< dataConstrNormal: "PApp" [TCon "Pattern",TList (TCon "Pattern")]
<< dataConstrRecord: TokTypeIdent "Pattern"
<< dataConstrNormal: "PInfix" [TCon "Pattern",TCon "Name",TCon "Pattern"]
<< declBody: return DeclData "Pattern" [] [Constraint "PVar" [TCon "Name"],Constraint "PInt" [TCon "Int"],Constraint "PChar" [TCon "Char"],Constraint "PString" [TCon "String"],Constraint "PWildcard" [],Constraint "PCons" [TCon "Pattern",TCon "Pattern"],Constraint "PList" [TList (TCon "Pattern")],Constraint "PTuple" [TList (TCon "Pattern")],Constraint "PConstr" [TCon "Name",TList (TCon "Pattern")],Constraint "PAs" [TCon "Name",TCon "Pattern"],Constraint "PApp" [TCon "Pattern",TList (TCon "Pattern")],Constraint "PInfix" [TCon "Pattern",TCon "Name",TCon "Pattern"]] ["Show","Eq"]
Just ([DeclModule "AST.Pattern" Nothing,DeclTypeAlias "Name" [] (TCon "String"),DeclData "Pattern" [] [Constraint "PVar" [TCon "Name"],Constraint "PInt" [TCon "Int"],Constraint "PChar" [TCon "Char"],Constraint "PString" [TCon "String"],Constraint "PWildcard" [],Constraint "PCons" [TCon "Pattern",TCon "Pattern"],Constraint "PList" [TList (TCon "Pattern")],Constraint "PTuple" [TList (TCon "Pattern")],Constraint "PConstr" [TCon "Name",TList (TCon "Pattern")],Constraint "PAs" [TCon "Name",TCon "Pattern"],Constraint "PApp" [TCon "Pattern",TList (TCon "Pattern")],Constraint "PInfix" [TCon "Pattern",TCon "Name",TCon "Pattern"]] ["Show","Eq"]],[TokNewline])

=== Running: src/AST/Program.hs ===
-- Raw Source --
module AST.Program where


data Program = Program
  { moduleDecl :: Maybe Decl
  , imports    :: [Decl]
  , decls      :: [Decl]
  }


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Program",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Program",TokSymbol "=",TokTypeIdent "Program",TokVLBrace,TokSymbol "{",TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Maybe",TokTypeIdent "Decl",TokSymbol ";",TokSymbol ",",TokIdent "imports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "decls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Program" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokSymbol "{"
<< parseTypeCore: TCon "Decl"
<< parseTypeCore: TCon "Decl"
<< dataConstrRecord: "Program" [Field "decls" (TList (TCon "Decl")),Field "imports" (TList (TCon "Decl")),Field "moduleDecl" (TApp (TCon "Maybe") (TCon "Decl"))]
<< declBody: return DeclData "Program" [] [ConstraintRecord "Program" [Field "decls" (TList (TCon "Decl")),Field "imports" (TList (TCon "Decl")),Field "moduleDecl" (TApp (TCon "Maybe") (TCon "Decl"))]] []
Just ([DeclModule "AST.Program" Nothing,DeclData "Program" [] [ConstraintRecord "Program" [Field "decls" (TList (TCon "Decl")),Field "imports" (TList (TCon "Decl")),Field "moduleDecl" (TApp (TCon "Maybe") (TCon "Decl"))]] []],[])

=== Running: src/AST/Type.hs ===
-- Raw Source --
module AST.Type where

-- import AST.Expr (Name)

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  | TFun Type Type
  deriving (Eq, Show)

data Constraint
  = Constraint String [Type] -- 通常のコンストラクタ
  | ConstraintRecord String [Field] -- レコード構文のコンストラクタ
  deriving (Show, Eq)

data Field = Field String Type
  deriving (Show, Eq)

-- data Constraint = Constraint String [Type]
--  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Type",TokVLBrace,TokSymbol "=",TokTypeIdent "TVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TCon",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TArrow",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TList",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TApp",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TForall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TTuple",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "TUnit",TokSymbol ";",TokSymbol "|",TokTypeIdent "TFun",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Constraint",TokVLBrace,TokSymbol "=",TokTypeIdent "Constraint",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ConstraintRecord",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Field",TokSymbol "=",TokTypeIdent "Field",TokTypeIdent "String",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Type" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TVar" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TCon" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TArrow" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TList" [TCon "Type"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TApp" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Constraint"
<< dataConstrNormal: "TConstraint" [TList (TCon "Constraint"),TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "String"
<< dataConstrNormal: "TForall" [TList (TCon "String"),TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Type"
<< dataConstrNormal: "TTuple" [TList (TCon "Type")]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TUnit" []
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TFun" [TCon "Type",TCon "Type"]
<< declBody: return DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" [],Constraint "TFun" [TCon "Type",TCon "Type"]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "Type"
<< dataConstrNormal: "Constraint" [TCon "String",TList (TCon "Type")]
<< dataConstrRecord: TokTypeIdent "String"
<< parseTypeCore: TCon "Field"
<< dataConstrNormal: "ConstraintRecord" [TCon "String",TList (TCon "Field")]
<< declBody: return DeclData "Constraint" [] [Constraint "Constraint" [TCon "String",TList (TCon "Type")],Constraint "ConstraintRecord" [TCon "String",TList (TCon "Field")]] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "Field" [TCon "String",TCon "Type"]
<< declBody: return DeclData "Field" [] [Constraint "Field" [TCon "String",TCon "Type"]] []
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "AST.Type" Nothing,DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" [],Constraint "TFun" [TCon "Type",TCon "Type"]] ["Eq","Show"],DeclData "Constraint" [] [Constraint "Constraint" [TCon "String",TList (TCon "Type")],Constraint "ConstraintRecord" [TCon "String",TList (TCon "Field")]] ["Show","Eq"],DeclData "Field" [] [Constraint "Field" [TCon "String",TCon "Type"]] []],[TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Data.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Data (dataDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type -- (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

dataDecl :: Parser Decl
dataDecl = do
  keyword "data"
  typeName <- identI
  typeVars <- many identI
  bracesV3 $ do
    symbol "="
    constrs <- sepBy1 dataConstr (symbol "|")
    derivs <- option [] derivingClause
    skipSeparators
    return $ DeclData typeName typeVars constrs derivs

dataConstr :: Parser Constraint
dataConstr = try dataConstrRecord <|> dataConstrNormal

dataConstrNormal :: Parser Constraint
dataConstrNormal = do
  name <- identI
  args <- many typeAtom
  myTrace ("<< dataConstrNormal: " ++ show name ++ " " ++ show args)
  optional (symbol ";")
  return $ Constraint name args

dataConstrRecord :: Parser Constraint
dataConstrRecord = do
  name <- identI
  skipBlk
  t <- lookAhead anyToken
  myTrace ("<< dataConstrRecord: " ++ show t)
  case t of
    TokSymbol "{" -> do
      fields <- fieldDefs
      myTrace ("<< dataConstrRecord: " ++ show name ++ " " ++ show fields)
      return $ ConstraintRecord name fields
    _ -> empty

fieldDef :: Parser Field
fieldDef = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< fieldDef: " ++ show t)
  name <- identI
  symbol "::"
  ty <- typeExpr
  -- t <- lookAhead anyToken
  -- myTrace ("<< fieldDef:2 " ++ show name ++ " " ++ show ty ++ " " ++ show t)
  return $ Field name ty

fieldDefs :: Parser [Field]
fieldDefs = do
  symbol "{"
  skipBlk
  fields <- sepBy1Skip fieldDef (symbol ",")
  -- fields <- getTypeDefs []
  skipBlk
  symbol "}"
  skipBlk
  return (reverse fields)

getTypeDefs :: [Field] -> Parser [Field]
getTypeDefs acc = do
  t <- lookAhead anyToken
  myTrace ("<< typeDef:1 next token " ++ show t)
  case t of
    TokSymbol "}" -> do
      return acc
    _ -> do
      name <- identI
      symbol "::"
      ty <- typeExpr
      skipBlk
      t <- lookAhead anyToken
      myTrace ("<< typeDef:2 next token " ++ show t ++ " " ++ show name ++ " " ++ show ty)
      case t of
        TokSymbol "," -> do
          symbol ","
          skipBlk
          optional (symbol ";")
          getTypeDefs (Field name ty : acc)
        TokSymbol ";" -> do
          symbol ";"
          getTypeDefs (Field name ty : acc)
        TokSymbol "}" -> do
          return (Field name ty : acc)
        _ -> empty

derivingClause :: Parser [Name]
derivingClause = do
  keyword "deriving"
  parens (sepBy1 typeIdent (symbol ",")) <|> fmap pure typeIdent


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Data",TokSymbol "(",TokIdent "dataDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "dataDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "dataDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "data",TokSymbol ";",TokIdent "typeName",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "typeVars",TokSymbol "<-",TokIdent "many",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "constrs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "dataConstr",TokSymbol "(",TokIdent "symbol",TokString "|",TokSymbol ")",TokSymbol ";",TokIdent "derivs",TokSymbol "<-",TokIdent "option",TokSymbol "[",TokSymbol "]",TokIdent "derivingClause",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclData",TokIdent "typeName",TokIdent "typeVars",TokIdent "constrs",TokIdent "derivs",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstr",TokSymbol "=",TokIdent "try",TokIdent "dataConstrRecord",TokOperator "<|>",TokIdent "dataConstrNormal",TokNewline,TokIdent "dataConstrNormal",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrNormal",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrNormal: ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrRecord",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRecord",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRecord: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "fields",TokSymbol "<-",TokIdent "fieldDefs",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRecord: ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "fields",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ConstraintRecord",TokIdent "name",TokIdent "fields",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "fieldDef",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Field",TokNewline,TokIdent "fieldDef",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokVRBrace,TokNewline,TokIdent "fieldDefs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokNewline,TokIdent "fieldDefs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "fields",TokSymbol "<-",TokIdent "sepBy1Skip",TokIdent "fieldDef",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "fields",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "getTypeDefs",TokSymbol "::",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokNewline,TokIdent "getTypeDefs",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef:1 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "return",TokIdent "acc",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString ",",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "getTypeDefs",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString ";",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString ";",TokSymbol ";",TokIdent "getTypeDefs",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "derivingClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "derivingClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "deriving",TokSymbol ";",TokIdent "parens",TokSymbol "(",TokIdent "sepBy1",TokIdent "typeIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokOperator "<|>",TokIdent "fmap",TokIdent "pure",TokIdent "typeIdent",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "dataDecl"
<< declBody: return DeclModule "Decl.DeclParser.Data" (Just [ExportVar "dataDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Data" (Just [ExportVar "dataDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "dataDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "dataDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "data",TokSymbol ";",TokIdent "typeName",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "typeVars",TokSymbol "<-",TokIdent "many",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "constrs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "dataConstr",TokSymbol "(",TokIdent "symbol",TokString "|",TokSymbol ")",TokSymbol ";",TokIdent "derivs",TokSymbol "<-",TokIdent "option",TokSymbol "[",TokSymbol "]",TokIdent "derivingClause",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclData",TokIdent "typeName",TokIdent "typeVars",TokIdent "constrs",TokIdent "derivs",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstr",TokSymbol "=",TokIdent "try",TokIdent "dataConstrRecord",TokOperator "<|>",TokIdent "dataConstrNormal",TokNewline,TokIdent "dataConstrNormal",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrNormal",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrNormal: ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrRecord",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRecord",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRecord: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "fields",TokSymbol "<-",TokIdent "fieldDefs",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRecord: ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "fields",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ConstraintRecord",TokIdent "name",TokIdent "fields",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "fieldDef",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Field",TokNewline,TokIdent "fieldDef",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokVRBrace,TokNewline,TokIdent "fieldDefs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokNewline,TokIdent "fieldDefs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "fields",TokSymbol "<-",TokIdent "sepBy1Skip",TokIdent "fieldDef",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "fields",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "getTypeDefs",TokSymbol "::",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokNewline,TokIdent "getTypeDefs",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef:1 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "return",TokIdent "acc",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "name",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString ",",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "skipBlk",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "getTypeDefs",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString ";",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString ";",TokSymbol ";",TokIdent "getTypeDefs",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "derivingClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "derivingClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "deriving",TokSymbol ";",TokIdent "parens",TokSymbol "(",TokIdent "sepBy1",TokIdent "typeIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokOperator "<|>",TokIdent "fmap",TokIdent "pure",TokIdent "typeIdent",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Fun.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Fun (funDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Control.Monad (guard)
import Data.List (intercalate)
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pPattern, pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

mkSimpleClause :: [Pattern] -> Expr -> Maybe [Decl] -> FunClause
mkSimpleClause pats body whereDecls =
  FunClause pats Nothing (Just body) whereDecls

mkGuardedClause :: [Pattern] -> [(Expr, Expr)] -> Maybe [Decl] -> FunClause
mkGuardedClause pats guards whereDecls =
  FunClause pats (Just guards) Nothing whereDecls

-- 関数宣言
funDecl :: Parser Decl
funDecl = do
  t <- lookAhead anyToken
  myTrace ("<< funDecl: next token=" ++ show t)
  (name, clause1) <- funClause -- funDecl
  rest <- many (try (funClauseWithName name))
  return (DeclFunGroup name (clause1 : rest))

funClause :: Parser (Name, FunClause)
funClause = do
  t0 <- lookAhead anyToken
  myTrace ("<< funClause: next token=" ++ show t0)
  name <- ident
  args <- many pPattern -- patternParser
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funClause: args=" ++ show args ++ " t = " ++ show t)
  case t of
    TokSymbol "=" -> parseSimpleClause name args
    TokSymbol "|" -> parseGuardedClause name args
    _ -> parseGuardedClause name args

parseSimpleClause :: Name -> [Pattern] -> Parser (Name, FunClause)
parseSimpleClause name args = do
  symbol "="
  t <- lookAhead anyToken
  myTrace ("<< parseSimpleClause:2 next token=" ++ show t)
  bracesV3 $ do
    skipSeparators
    e <- expr
    w <- optional (bracesV3 (whereBlock))
    return (name, mkSimpleClause args e w)

parseGuardedClause :: Name -> [Pattern] -> Parser (Name, FunClause)
parseGuardedClause name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedClause: next token=" ++ show t)
  bracesV3 $ do
    skipSeparators
    guards <- guardedRhs
    w <- optional (whereBlock)
    return (name, mkGuardedClause args guards w)

funDeclGroup :: Parser Decl
funDeclGroup = do
  t <- lookAhead anyToken
  myTrace ("<< funDeclGroup: next token=" ++ show t)
  (name1, clause1) <- funClause
  rest <- many (try (funClauseWithName name1))
  return (DeclFunGroup name1 (clause1 : rest))

-- 同じ名前の関数をグループ化する
funClauseWithName :: Name -> Parser FunClause
funClauseWithName name = try $ do
  skipSeparators
  -- skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funClauseWithName: next token=" ++ show t)
  name' <- ident
  guard (name == name')
  args <- many patternParser
  -- skipSeparators
  t <- lookAhead anyToken
  case t of
    TokSymbol "=" -> do
      symbol "="
      bracesV3 $ do
        skipSeparators
        e <- expr
        -- w <- optional (bracesV3 (whereBlock))
        w <- optional whereBlock
        return (mkSimpleClause args e w)
    TokSymbol "|" -> do
      guards <- guardedRhs
      w <- optional whereBlock
      return (mkGuardedClause args guards w)
    _ -> bracesV3 $ do
      skipSeparators
      e <- expr
      -- w <- optional (bracesV3 (whereBlock))
      w <- optional whereBlock
      return (mkSimpleClause args e w)

--  guards <- guardedRhs
--  w <- optional whereBlock
-- return (mkGuardedClause args guards w)

whereBlock :: Parser [Decl]
whereBlock = do
  t0 <- lookAhead anyToken
  myTrace ("<< whereBlock: next token" ++ show t0)
  keyword "where"
  t <- lookAhead anyToken
  myTrace ("<< whereBlock:2 next token" ++ show t)
  bracesV $ do
    decls <- many1 $ do
      skipSeparators
      funDecl
    return decls

guardedRhsM :: Parser [(Expr, Expr)]
guardedRhsM = many1 parseGuardLine

parseGuardLine :: Parser (Expr, Expr)
parseGuardLine = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardLine: next token=" ++ show t)
  symbol "|"
  cond <- expr
  symbol "="
  body <- expr
  return (cond, body)

guardedRhs :: Parser [(Expr, Expr)]
guardedRhs = do
  many1 $ do
    skipSeparators
    t <- lookAhead anyToken
    myTrace ("<< guardedRhs: next token = " ++ show t)
    parseGuardLine

-- sepBy1 parseGuardLine (symbol ";")

funHead :: Parser (Name, [Pattern])
funHead = do
  p <- pattern
  myTrace ("<< funHead pattern: " ++ show p)
  case p of
    PVar name -> do
      args <- many pattern
      return (name, args)
    PApp (PVar name) args -> do
      moreArgs <- many pattern
      return (name, args ++ moreArgs)
    _ -> do
      myTrace "Function definition must start with a variable name"
      empty

{-}
parseGuardedClauseV :: Name -> [Pattern] -> Parser (Name, FunClause)
parseGuardedClauseV name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedClauseV: next token=" ++ show t)
  guards <- guardedRhs
  w <- optional (whereBlockV)
  return (name, mkGuardedClause args guards w)
-}

{-}
whereBlockV :: Parser [Decl]
whereBlockV = do
  t0 <- lookAhead anyToken
  myTrace ("<< whereBlockV: next token" ++ show t0)
  keyword "where"
  t <- lookAhead anyToken
  myTrace ("<< whereBlockV:2 next token" ++ show t)
  decls <- many funDecl
  return decls
-}

{-}
funDecl :: Parser Decl -> Parser Decl
funDecl decl = do
  t0 <- lookAhead anyToken
  myTrace ("<< funDecl: next token=" ++ show t0)
  name <- ident
  args <- many patternParser
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funDecl: args=" ++ show args ++ " t = " ++ show t)
  case t of
    TokSymbol "=" -> parseSimple decl name args
    TokSymbol "|" -> parseGuarded decl name args
    TokVLBrace -> bracesV (parseGuardedV decl name args)
    _ -> empty

parseSimple :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseSimple decl name args = do
  t0 <- lookAhead anyToken
  myTrace ("<< parseSimple: next token" ++ show t0)
  symbol "="
  t <- lookAhead anyToken
  myTrace ("<< parseSimple: next token" ++ show t)
  case t of
    TokVLBrace -> do
      token TokVLBrace
      e <- expr
      w <- optional (bracesV (whereBlock decl))
      token TokVRBrace
      return (DeclFun name args Nothing (Just e) w)
    _ -> do
      e <- expr
      w <- optional (bracesV (whereBlock decl))
      return (DeclFun name args Nothing (Just e) w)

parseGuardedV :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseGuardedV decl name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedV: next token" ++ show t)
  -- guards <- bracesV
  guards <- guardedRhs
  w <- optional (whereBlockV decl)
  return (DeclFun name args (Just guards) Nothing w)

parseGuarded :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseGuarded decl name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuarded: next token" ++ show t)
  guards <- guardedRhsM
  w <- optional (whereBlock decl)
  return (DeclFun name args (Just guards) Nothing w)

-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Fun",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pPattern",TokSymbol ",",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "mkSimpleClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkSimpleClause",TokIdent "pats",TokIdent "body",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "mkGuardedClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkGuardedClause",TokIdent "pats",TokIdent "guards",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokSymbol "(",TokTypeIdent "Just",TokIdent "guards",TokSymbol ")",TokTypeIdent "Nothing",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "funDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDecl: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "funClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pPattern",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: args=",TokOperator "++",TokIdent "show",TokIdent "args",TokOperator "++",TokString " t = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseSimpleClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseSimpleClause:2 next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseGuardedClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardedClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funDeclGroup",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDeclGroup",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDeclGroup: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name1",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name1",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClauseWithName",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokTypeIdent "Parser",TokTypeIdent "FunClause",TokNewline,TokIdent "funClauseWithName",TokIdent "name",TokSymbol "=",TokIdent "try",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClauseWithName: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name'",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "guard",TokSymbol "(",TokIdent "name",TokOperator "==",TokIdent "name'",TokSymbol ")",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "patternParser",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "whereBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock: next token",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock:2 next token",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "decls",TokSymbol "<-",TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "funDecl",TokVRBrace,TokNewline,TokKeyword "return",TokIdent "decls",TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardedRhsM",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhsM",TokSymbol "=",TokIdent "many1",TokIdent "parseGuardLine",TokNewline,TokIdent "parseGuardLine",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "parseGuardLine",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardLine: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardedRhs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< guardedRhs: next token = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "parseGuardLine",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funHead",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funHead pattern: ",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "p",TokKeyword "of",TokVLBrace,TokTypeIdent "PVar",TokIdent "name",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "moreArgs",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "funDecl"
<< declBody: return DeclModule "Decl.DeclParser.Fun" (Just [ExportVar "funDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Fun" (Just [ExportVar "funDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pPattern",TokSymbol ",",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "mkSimpleClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkSimpleClause",TokIdent "pats",TokIdent "body",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "mkGuardedClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkGuardedClause",TokIdent "pats",TokIdent "guards",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokSymbol "(",TokTypeIdent "Just",TokIdent "guards",TokSymbol ")",TokTypeIdent "Nothing",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "funDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDecl: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "funClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pPattern",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: args=",TokOperator "++",TokIdent "show",TokIdent "args",TokOperator "++",TokString " t = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseSimpleClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseSimpleClause:2 next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseGuardedClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardedClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funDeclGroup",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDeclGroup",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDeclGroup: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name1",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name1",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClauseWithName",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokTypeIdent "Parser",TokTypeIdent "FunClause",TokNewline,TokIdent "funClauseWithName",TokIdent "name",TokSymbol "=",TokIdent "try",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClauseWithName: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name'",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "guard",TokSymbol "(",TokIdent "name",TokOperator "==",TokIdent "name'",TokSymbol ")",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "patternParser",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "whereBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock: next token",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock:2 next token",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "decls",TokSymbol "<-",TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "funDecl",TokVRBrace,TokNewline,TokKeyword "return",TokIdent "decls",TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardedRhsM",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhsM",TokSymbol "=",TokIdent "many1",TokIdent "parseGuardLine",TokNewline,TokIdent "parseGuardLine",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "parseGuardLine",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardLine: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardedRhs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< guardedRhs: next token = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "parseGuardLine",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funHead",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funHead pattern: ",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "p",TokKeyword "of",TokVLBrace,TokTypeIdent "PVar",TokIdent "name",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "moreArgs",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Import.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Import (importDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

-- import 文
importDecl :: Parser Decl
importDecl = do
  myTrace "<< importDecl parser called"
  _ <- keyword "import"
  isQual <- option False (True <$ keyword "qualified")
  t <- lookAhead anyToken
  myTrace ("<< importDecl: " ++ show t)
  modName <- moduleName
  alias <- optional (keyword "as" *> identI)
  isHiding <- option False (True <$ keyword "hiding")
  items <- optional importList
  return $ DeclImport isQual modName alias isHiding items

importList :: Parser [ImportItem]
importList =
  parens $
    pure ImportAllItems <$ symbol ".."
      <|> sepBy1 importIdent (symbol ",")

{-}
importIdent :: Parser ImportItem
importIdent = do
  name <- identI
  m <-
    optional $
      parensI $
        (ImportTypeAll name <$ symbol "..")
          <|> (ImportTypeSome name <$> sepBy1 identI (symbol ","))
  return $ case m of
    Just x -> x
    Nothing -> ImportVar name
-}
importIdent :: Parser ImportItem
importIdent = do
  name <-
    try identI
      <|> do
        op <- parens operatorI
        return $ "(" ++ op ++ ")"
  m <-
    optional $
      parensI $
        (ImportTypeAll name <$ symbol "..")
          <|> ImportTypeSome name
            <$> sepBy1 (identI <|> parens operatorIAsName) (symbol ",")
  -- <|> (ImportTypeSome name <$> sepBy1 identI (symbol ","))
  return $ case m of
    Just x -> x
    Nothing -> ImportVar name

{-}
operatorI :: Parser Name
operatorI = do
  TokOperator op <- token satisfyOperator
  return op

satisfyOperator :: Token -> Bool
satisfyOperator (TokOperator _) = True
satisfyOperator _ = False
-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Import",TokSymbol "(",TokIdent "importDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "importDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "importDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< importDecl parser called",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "keyword",TokString "import",TokSymbol ";",TokIdent "isQual",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "qualified",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< importDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "modName",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "alias",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "as",TokOperator "*>",TokIdent "identI",TokSymbol ")",TokSymbol ";",TokIdent "isHiding",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "hiding",TokSymbol ")",TokSymbol ";",TokIdent "items",TokSymbol "<-",TokIdent "optional",TokIdent "importList",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclImport",TokIdent "isQual",TokIdent "modName",TokIdent "alias",TokIdent "isHiding",TokIdent "items",TokVRBrace,TokNewline,TokIdent "importList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "ImportItem",TokSymbol "]",TokNewline,TokIdent "importList",TokSymbol "=",TokVLBrace,TokIdent "parens",TokOperator "$",TokVLBrace,TokIdent "pure",TokTypeIdent "ImportAllItems",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokIdent "importIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "importIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "ImportItem",TokNewline,TokIdent "importIdent",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "identI",TokVLBrace,TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "m",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokOperator "$",TokVLBrace,TokIdent "parensI",TokOperator "$",TokVLBrace,TokSymbol "(",TokTypeIdent "ImportTypeAll",TokIdent "name",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokTypeIdent "ImportTypeSome",TokIdent "name",TokVLBrace,TokOperator "<$>",TokIdent "sepBy1",TokSymbol "(",TokIdent "identI",TokOperator "<|>",TokIdent "parens",TokIdent "operatorIAsName",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "m",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokIdent "x",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "ImportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "importDecl"
<< declBody: return DeclModule "Decl.DeclParser.Import" (Just [ExportVar "importDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Import" (Just [ExportVar "importDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "importDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "importDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< importDecl parser called",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "keyword",TokString "import",TokSymbol ";",TokIdent "isQual",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "qualified",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< importDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "modName",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "alias",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "as",TokOperator "*>",TokIdent "identI",TokSymbol ")",TokSymbol ";",TokIdent "isHiding",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "hiding",TokSymbol ")",TokSymbol ";",TokIdent "items",TokSymbol "<-",TokIdent "optional",TokIdent "importList",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclImport",TokIdent "isQual",TokIdent "modName",TokIdent "alias",TokIdent "isHiding",TokIdent "items",TokVRBrace,TokNewline,TokIdent "importList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "ImportItem",TokSymbol "]",TokNewline,TokIdent "importList",TokSymbol "=",TokVLBrace,TokIdent "parens",TokOperator "$",TokVLBrace,TokIdent "pure",TokTypeIdent "ImportAllItems",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokIdent "importIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "importIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "ImportItem",TokNewline,TokIdent "importIdent",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "identI",TokVLBrace,TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "m",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokOperator "$",TokVLBrace,TokIdent "parensI",TokOperator "$",TokVLBrace,TokSymbol "(",TokTypeIdent "ImportTypeAll",TokIdent "name",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokTypeIdent "ImportTypeSome",TokIdent "name",TokVLBrace,TokOperator "<$>",TokIdent "sepBy1",TokSymbol "(",TokIdent "identI",TokOperator "<|>",TokIdent "parens",TokIdent "operatorIAsName",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "m",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokIdent "x",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "ImportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Instance.hs ===
-- Raw Source --


-- Tokens from Lexer --
[]

-- Parsing --

-- Parsed AST --
Just ([],[])

=== Running: src/Decl/DeclParser/Module.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Module (moduleDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Data.Char (isUpper)
import Data.List (intercalate)
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Type.TypeParser
import Utils.MyTrace

moduleDecl :: Parser Decl
moduleDecl = do
  keyword "module"
  name <- moduleName
  try (exportWhere name) <|> exportWhere2 name

exportWhere :: String -> Parser Decl
exportWhere name = do
  exports <- optional (bracesV3 exportList)
  skipSeparators
  keyword "where"
  return (DeclModule name exports)

exportWhere2 :: String -> Parser Decl
exportWhere2 name = do
  bracesV $ do
    exports <- optional exportList
    skipSeparators
    keyword "where"
    return (DeclModule name exports)

exportItem :: Parser Export
exportItem = do
  t <- lookAhead anyToken
  myTrace ("<< exportItem: next token=" ++ show t)
  name <-
    try typeIdent
      <|> try ident
      <|> do
        op <- parens operatorI
        return $ "(" ++ op ++ ")"
  hasAll <- optional (parens (symbol ".."))
  return $ case hasAll of
    Just _ -> ExportType name True
    Nothing ->
      if isUpper (head name)
        then ExportType name False
        else ExportVar name

exportList :: Parser [Export]
-- exportList = parens (exportItem `sepEndBy` symbol ",")
exportList = parens $ sepBy1Skip exportItem (symbol ",")


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Module",TokSymbol "(",TokIdent "moduleDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "moduleDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "module",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "exportWhere",TokIdent "name",TokSymbol ")",TokOperator "<|>",TokIdent "exportWhere2",TokIdent "name",TokVRBrace,TokNewline,TokIdent "exportWhere",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokIdent "exportList",TokSymbol ")",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exportWhere2",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere2",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokIdent "exportList",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportItem",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Export",TokNewline,TokIdent "exportItem",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exportItem: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "typeIdent",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "hasAll",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "symbol",TokString "..",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "hasAll",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "_",TokArrow,TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "True",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokVLBrace,TokKeyword "then",TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "False",TokSymbol ";",TokKeyword "else",TokTypeIdent "ExportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokNewline,TokIdent "exportList",TokSymbol "=",TokIdent "parens",TokOperator "$",TokIdent "sepBy1Skip",TokIdent "exportItem",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "moduleDecl"
<< declBody: return DeclModule "Decl.DeclParser.Module" (Just [ExportVar "moduleDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Module" (Just [ExportVar "moduleDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "moduleDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "module",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "exportWhere",TokIdent "name",TokSymbol ")",TokOperator "<|>",TokIdent "exportWhere2",TokIdent "name",TokVRBrace,TokNewline,TokIdent "exportWhere",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokIdent "exportList",TokSymbol ")",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exportWhere2",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere2",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokIdent "exportList",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportItem",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Export",TokNewline,TokIdent "exportItem",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exportItem: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "typeIdent",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "hasAll",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "symbol",TokString "..",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "hasAll",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "_",TokArrow,TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "True",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokVLBrace,TokKeyword "then",TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "False",TokSymbol ";",TokKeyword "else",TokTypeIdent "ExportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokNewline,TokIdent "exportList",TokSymbol "=",TokIdent "parens",TokOperator "$",TokIdent "sepBy1Skip",TokIdent "exportItem",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline])

=== Running: src/Decl/DeclParser/Type.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Type (typeAliasDecl, newtypeDecl, constr) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Data.Char (isUpper)
import Data.List (intercalate)
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Type.TypeParser
import Utils.MyTrace

-- newtype 宣言
newtypeDecl :: Parser Decl
newtypeDecl = do
  myTrace "<< newtypeDecl parser called"
  keyword "newtype"
  name <- typeIdent
  vars <- many typeIdent
  symbol "="
  c <- constr
  return (DeclNewtype name vars c)

-- コンストラクタ
constr :: Parser Constraint
constr = do
  myTrace "<< constr parser called"
  cname <- typeIdent
  tys <- many parseType
  return (Constraint cname tys)

typeAliasDecl :: Parser Decl
typeAliasDecl = do
  myTrace "<< typeAliasDecl parser called"
  keyword "type"
  name <- typeIdent
  vars <- many ident
  symbol "="
  body <- parseType
  return $ DeclTypeAlias name vars body


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Type",TokSymbol "(",TokIdent "typeAliasDecl",TokSymbol ",",TokIdent "newtypeDecl",TokSymbol ",",TokIdent "constr",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "newtypeDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "newtype",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "c",TokSymbol "<-",TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSymbol "<-",TokIdent "many",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAliasDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "type",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclTypeAlias",TokIdent "name",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "typeAliasDecl"
<< exportItem: next token=TokIdent "newtypeDecl"
<< exportItem: next token=TokIdent "constr"
<< declBody: return DeclModule "Decl.DeclParser.Type" (Just [ExportVar "typeAliasDecl",ExportVar "newtypeDecl",ExportVar "constr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Type" (Just [ExportVar "typeAliasDecl",ExportVar "newtypeDecl",ExportVar "constr"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "newtypeDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "newtype",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "c",TokSymbol "<-",TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSymbol "<-",TokIdent "many",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAliasDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "type",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclTypeAlias",TokIdent "name",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Util.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Util
  ( parensI,
    identI,
    moduleName,
    tokdot,
    operatorI,
    sepBy1Skip,
    skipBlk,
    typeExpr,
    operatorIAsName,
  )
where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- ★ ここが正しい

-- (keyword) -- , whereClause)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

parensI :: Parser a -> Parser a
parensI p = symbol "(" *> p <* symbol ")"

moduleName :: Parser String
moduleName = intercalate "." <$> sepBy1 identI tokdot

tokdot :: Parser String
tokdot = token TokDot *> pure "."

typeExpr :: Parser Type
typeExpr = do
  ts <- some typeAtom
  return $ foldl1 TApp ts

sepBy1Skip :: Parser a -> Parser sep -> Parser [a]
sepBy1Skip p sep = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< sepBy1Skip: next token " ++ show t)
  skipControlTokens
  x <- p
  xs <- many $ do
    skipControlTokens
    _ <- sep
    skipControlTokens
    p
  skipControlTokens
  optional sep
  skipControlTokens
  return (x : xs)

isControlToken :: Token -> Bool
isControlToken t = case t of
  TokVLBrace -> True
  TokVRBrace -> True
  TokNewline -> True
  TokSymbol ";" -> True
  _ -> False

skipControlTokens :: Parser ()
skipControlTokens = skipMany $ satisfyToken (\t -> if isControlToken t then Just () else Nothing)

skipBlk :: Parser ()
skipBlk = do
  optional (token TokVLBrace)
  optional (token TokVRBrace)
  optional (token TokNewline)
  optional (token $ TokSymbol ";")
  return ()


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokVLBrace,TokSymbol "(",TokIdent "parensI",TokSymbol ",",TokIdent "identI",TokSymbol ",",TokIdent "moduleName",TokSymbol ",",TokIdent "tokdot",TokSymbol ",",TokIdent "operatorI",TokSymbol ",",TokIdent "sepBy1Skip",TokSymbol ",",TokIdent "skipBlk",TokSymbol ",",TokIdent "typeExpr",TokSymbol ",",TokIdent "operatorIAsName",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "parensI",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parensI",TokIdent "p",TokSymbol "=",TokIdent "symbol",TokString "(",TokOperator "*>",TokIdent "p",TokOperator "<*",TokIdent "symbol",TokString ")",TokNewline,TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "moduleName",TokSymbol "=",TokIdent "intercalate",TokString ".",TokOperator "<$>",TokIdent "sepBy1",TokIdent "identI",TokIdent "tokdot",TokNewline,TokIdent "tokdot",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "tokdot",TokSymbol "=",TokIdent "token",TokTypeIdent "TokDot",TokOperator "*>",TokIdent "pure",TokString ".",TokNewline,TokIdent "typeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "sepBy1Skip",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1Skip",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipControlTokens",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "sep",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokIdent "p",TokVRBrace,TokNewline,TokIdent "skipControlTokens",TokSymbol ";",TokIdent "optional",TokIdent "sep",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "isControlToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isControlToken",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokVRBrace",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokNewline",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokSymbol",TokString ";",TokArrow,TokTypeIdent "True",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "False",TokVRBrace,TokNewline,TokIdent "skipControlTokens",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipControlTokens",TokSymbol "=",TokIdent "skipMany",TokOperator "$",TokIdent "satisfyToken",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "isControlToken",TokIdent "t",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "skipBlk",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipBlk",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokOperator "$",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parensI"
<< exportItem: next token=TokIdent "identI"
<< exportItem: next token=TokIdent "moduleName"
<< exportItem: next token=TokIdent "tokdot"
<< exportItem: next token=TokIdent "operatorI"
<< exportItem: next token=TokIdent "sepBy1Skip"
<< exportItem: next token=TokIdent "skipBlk"
<< exportItem: next token=TokIdent "typeExpr"
<< exportItem: next token=TokIdent "operatorIAsName"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Decl.DeclParser.Util" (Just [ExportVar "parensI",ExportVar "identI",ExportVar "moduleName",ExportVar "tokdot",ExportVar "operatorI",ExportVar "sepBy1Skip",ExportVar "skipBlk",ExportVar "typeExpr",ExportVar "operatorIAsName"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParser.Util" (Just [ExportVar "parensI",ExportVar "identI",ExportVar "moduleName",ExportVar "tokdot",ExportVar "operatorI",ExportVar "sepBy1Skip",ExportVar "skipBlk",ExportVar "typeExpr",ExportVar "operatorIAsName"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "parensI",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parensI",TokIdent "p",TokSymbol "=",TokIdent "symbol",TokString "(",TokOperator "*>",TokIdent "p",TokOperator "<*",TokIdent "symbol",TokString ")",TokNewline,TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "moduleName",TokSymbol "=",TokIdent "intercalate",TokString ".",TokOperator "<$>",TokIdent "sepBy1",TokIdent "identI",TokIdent "tokdot",TokNewline,TokIdent "tokdot",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "tokdot",TokSymbol "=",TokIdent "token",TokTypeIdent "TokDot",TokOperator "*>",TokIdent "pure",TokString ".",TokNewline,TokIdent "typeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "sepBy1Skip",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1Skip",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipControlTokens",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "sep",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokIdent "p",TokVRBrace,TokNewline,TokIdent "skipControlTokens",TokSymbol ";",TokIdent "optional",TokIdent "sep",TokSymbol ";",TokIdent "skipControlTokens",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "isControlToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isControlToken",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokVRBrace",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokNewline",TokArrow,TokTypeIdent "True",TokSymbol ";",TokTypeIdent "TokSymbol",TokString ";",TokArrow,TokTypeIdent "True",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "False",TokVRBrace,TokNewline,TokIdent "skipControlTokens",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipControlTokens",TokSymbol "=",TokIdent "skipMany",TokOperator "$",TokIdent "satisfyToken",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "isControlToken",TokIdent "t",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "skipBlk",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipBlk",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "token",TokOperator "$",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParserCore where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- ★ ここが正しい

-- (keyword) -- , whereClause)

import Decl.DeclParser.Data
import Decl.DeclParser.Fun
import Decl.DeclParser.Import
import Decl.DeclParser.Module
import Decl.DeclParser.Type
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Core.TokenParser (operator)
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

-- decls :: Parser [Decl]
-- decls = many decl
{-}
decl :: Parser Decl
decl = do
  skipNewlines
  myTrace "<< decl parser called"
  declBody
-}
isEOF :: Parser Bool
isEOF = Parser $ \ts ->
  case ts of
    [] -> Just (True, [])
    _ -> Just (False, ts)

decl :: Parser Decl
decl = do
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< decl next token: " ++ show t)
  eof <- isEOF
  if eof
    then Parser $ \_ -> Nothing -- many decl に「もう終わり」と伝える
    else do
      myTrace "<< decl parser called"
      declBody

declBody :: Parser Decl
declBody = do
  d <- declDispatch
  myTrace ("<< declBody: return " ++ show d)
  return d

declDispatch :: Parser Decl
declDispatch = do
  t <- lookAhead anyToken
  myTrace ("<< decl dispatch: " ++ show t)
  case t of
    TokKeyword "data" -> dataDecl
    TokKeyword "newType" -> newtypeDecl
    TokKeyword "import" -> importDecl
    TokKeyword "instance" -> instanceDecl
    TokKeyword "module" -> moduleDecl
    TokKeyword "class" -> classDecl
    TokKeyword "type" -> typeAliasDecl
    TokLambdaCase -> empty
    -- _ -> try funDecl <|> valueDecl
    TokIdent _ -> try (funDecl) <|> try typeSigDecl <|> valueDecl
    -- TokSymbol "{" -> try (braces (funDecl decl)) <|> empty
    TokSymbol "(" -> try typeSigDecl <|> empty
    _ -> do
      myTrace ("<< unknown token in decl: " ++ show t)
      empty

-- Haskell ファイル全体
program :: Parser [Decl]
program = many decl

typeSigDecl :: Parser Decl
typeSigDecl = do
  t <- lookAhead anyToken
  myTrace ("<< typeSigDecl: " ++ show t)
  name <-
    try ident
      <|> do
        op <- parens operatorI
        return $ "(" ++ op ++ ")"
  t <- lookAhead anyToken
  myTrace ("<< typeSigDecl:2 " ++ show t)
  symbol "::"
  ty <- parseType
  myTrace ("<< parsed type signature: " ++ name ++ " :: " ++ show ty)
  let decl = DeclTypeSig name ty
  myTrace ("<< returning DeclTypeSig: " ++ show decl)
  return decl

-- 値宣言
valueDecl :: Parser Decl
valueDecl = do
  t <- lookAhead anyToken
  myTrace ("<< valueDecl: " ++ show t)
  pat <- patternParser
  symbol "="
  body <- expr
  return (DeclValue pat body)

instanceDecl :: Parser Decl
instanceDecl = do
  myTrace "<< instanceDecl parser called"
  keyword "instance"
  ctx <- optional (try (constraintList <* keyword "=>"))
  className <- typeIdent
  args <- some typeAtom
  keyword "where"
  methods <- bracedBlock decl
  return (DeclInstance ctx className args methods)

classDecl :: Parser Decl
classDecl = do
  myTrace "<< classDecl parser called"
  keyword "class"
  className <- typeIdent
  vars <- some ident
  keyword "where"
  t <- lookAhead anyToken
  methods <- bracedBlock decl
  return $ DeclClass className vars methods


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Data",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Fun",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Import",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Module",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "(",TokIdent "operator",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "isEOF",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Bool",TokNewline,TokIdent "isEOF",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "decl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSymbol "<-",TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokIdent "eof",TokVLBrace,TokKeyword "then",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "declBody",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "d",TokSymbol "<-",TokIdent "declDispatch",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< declBody: return ",TokOperator "++",TokIdent "show",TokIdent "d",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "d",TokVRBrace,TokNewline,TokIdent "declDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "data",TokArrow,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "newType",TokArrow,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "import",TokArrow,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "instance",TokArrow,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "module",TokArrow,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "class",TokArrow,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "type",TokArrow,TokIdent "typeAliasDecl",TokSymbol ";",TokTypeIdent "TokLambdaCase",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokIdent "_",TokArrow,TokIdent "try",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokOperator "<|>",TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "valueDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "(",TokArrow,TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< unknown token in decl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "program",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSymbol "=",TokIdent "many",TokIdent "decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "ident",TokVLBrace,TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl:2 ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "decl",TokSymbol "=",TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "decl",TokVRBrace,TokNewline,TokIdent "valueDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "instanceDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "instance",TokSymbol ";",TokIdent "ctx",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "classDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "class",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclClass",TokIdent "className",TokIdent "vars",TokIdent "methods",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "Decl.DeclParserCore" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Decl.DeclParserCore" Nothing,DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Data",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Fun",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Import",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Module",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "(",TokIdent "operator",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "isEOF",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Bool",TokNewline,TokIdent "isEOF",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "decl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSymbol "<-",TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokIdent "eof",TokVLBrace,TokKeyword "then",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "declBody",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "d",TokSymbol "<-",TokIdent "declDispatch",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< declBody: return ",TokOperator "++",TokIdent "show",TokIdent "d",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "d",TokVRBrace,TokNewline,TokIdent "declDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "data",TokArrow,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "newType",TokArrow,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "import",TokArrow,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "instance",TokArrow,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "module",TokArrow,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "class",TokArrow,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "type",TokArrow,TokIdent "typeAliasDecl",TokSymbol ";",TokTypeIdent "TokLambdaCase",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokIdent "_",TokArrow,TokIdent "try",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokOperator "<|>",TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "valueDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "(",TokArrow,TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< unknown token in decl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "program",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSymbol "=",TokIdent "many",TokIdent "decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokVLBrace,TokIdent "try",TokIdent "ident",TokVLBrace,TokOperator "<|>",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl:2 ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "decl",TokSymbol "=",TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "decl",TokVRBrace,TokNewline,TokIdent "valueDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "instanceDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "instance",TokSymbol ";",TokIdent "ctx",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "classDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "class",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclClass",TokIdent "className",TokIdent "vars",TokIdent "methods",TokVRBrace,TokNewline])

=== Running: src/Layout/LayoutTransform.hs ===
-- Raw Source --
module Layout.LayoutTransform (layoutTransform) where

import Lexer.Token

layoutTransform :: [Token] -> [Token]
layoutTransform toks = go toks

go :: [Token] -> [Token]
go [] = []
go (TokVNewline (x, y) : rest)
  | x == 0 && x == y = TokNewline : go rest
  | x == y = TokSymbol ";" : go rest
  -- \| x < y = TokSymbol "{" : go rest
  | x < y = TokVLBrace : go rest
  | x > y = closeBlocks (x, y) rest
go (t : rest) =
  t : go rest

closeBlocks :: (Int, Int) -> [Token] -> [Token]
closeBlocks (x, y) rest
  -- \| x > y = TokSymbol "}" : closeBlocks (x - 1, y) rest
  | x > y = TokVRBrace : closeBlocks (x - 1, y) rest
  | otherwise = TokNewline : go rest


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokSymbol "(",TokIdent "layoutTransform",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "layoutTransform",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutTransform",TokIdent "toks",TokSymbol "=",TokIdent "go",TokIdent "toks",TokNewline,TokIdent "go",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "x",TokOperator "==",TokNumber 0,TokSymbol "&",TokSymbol "&",TokIdent "x",TokOperator "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ";",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "<",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVLBrace",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "closeBlocks",TokSymbol "::",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVLBrace,TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVRBrace",TokOperator ":",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "layoutTransform"
<< declBody: return DeclModule "Layout.LayoutTransform" (Just [ExportVar "layoutTransform"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "layoutTransform"
<< decl parser called
<< decl dispatch: TokIdent "layoutTransform"
<< funDecl: next token=TokIdent "layoutTransform"
<< funClause: next token=TokIdent "layoutTransform"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "layoutTransform"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: layoutTransform :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "layoutTransform"
<< decl parser called
<< decl dispatch: TokIdent "layoutTransform"
<< funDecl: next token=TokIdent "layoutTransform"
<< funClause: next token=TokIdent "layoutTransform"
<< pPattern: next token TokIdent "toks"
<< pConstrOrVar: next token TokIdent "toks"
<< parsed pattern: PVar "toks"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "toks"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "go"
<< infixOp: next token TokIdent "go"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< declBody: return DeclFunGroup "layoutTransform" [FunClause [PVar "toks"] Nothing (Just (EApp (EVar "go") (EVar "toks"))) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "go"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: go :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereClause: next token TokIdent "go"
<< infixOp: next token TokIdent "go"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokTypeIdent "TokVNewline"
<< pConstrOrVar: next token TokIdent "x"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pConstrOrVar: next token TokIdent "y"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])) []
<< pConstrOrVar: next token TokVLBrace
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "go" [FunClause [PList []] Nothing (Just (EList [])) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TokVNewline"
<< pConstrOrVar: next token TokIdent "x"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pConstrOrVar: next token TokIdent "y"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< parsed pattern: PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< pPattern: next token TokVLBrace
<< pConstrOrVar: next token TokVLBrace
<< funClause: args=[PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "x"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokOperator "=="
<< atomBaseCore next token: TokNumber 0
<< atomBaseCore next token: TokSymbol "&"
<< whereClause: next token TokSymbol "&"
<< infixOp: next token TokSymbol "&"
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "go"
<< typeSigDecl:2 TokSymbol "("
<< valueDecl: TokIdent "go"
<< pConstrOrVar: next token TokIdent "go"
<< pConstrOrVar: next token TokTypeIdent "TokVNewline"
<< pConstrOrVar: next token TokIdent "x"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pConstrOrVar: next token TokIdent "y"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PVar "go") [PCons (PApp (PVar "TokVNewline") [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])]
Just ([DeclModule "Layout.LayoutTransform" (Just [ExportVar "layoutTransform"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "layoutTransform" [FunClause [PVar "toks"] Nothing (Just (EApp (EVar "go") (EVar "toks"))) Nothing],DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "go" [FunClause [PList []] Nothing (Just (EList [])) Nothing]],[TokIdent "go",TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "x",TokOperator "==",TokNumber 0,TokSymbol "&",TokSymbol "&",TokIdent "x",TokOperator "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ";",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "<",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVLBrace",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "closeBlocks",TokSymbol "::",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVLBrace,TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVRBrace",TokOperator ":",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/Lexer/LayoutLexer.hs ===
-- Raw Source --
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] 0 toks -- 追加: parenDepth = 0

go :: [Int] -> Int -> [Token] -> [Token]
go stack _ [] = []
-- コメント行（空白＋コメント＋改行）を空行とみなす
go stack 0 (TokNewline : TokSpace n : TokNewline : rest)
  | n == head stack =
      TokVNewline (level, level) : TokVNewline (level, level) : go stack 0 rest
  where
    level = length stack - 1
-- 空行（TokNewline のあとに TokNewline または EOF）
go stack 0 (TokNewline : TokNewline : rest) =
  go stack 0 (TokNewline : rest)
-- 行頭のスペース（括弧外のみ処理）
go stack 0 (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack 0 rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
-- 行頭の改行（スペースなし）※括弧外のみ処理
go stack 0 (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' 0 rest
-- 括弧内の TokSpace や TokNewline はスキップ
go stack depth (TokSpace _ : rest) =
  go stack depth rest
-- go stack depth (TokSpace _ : rest)
--  | depth > 0 = go stack depth rest
go stack depth (TokNewline : rest)
  | depth > 0 = go stack depth rest
-- 括弧のネスト制御
go stack depth (TokSymbol "(" : rest) =
  TokSymbol "(" : go stack (depth + 1) rest
go stack depth (TokSymbol ")" : rest) =
  TokSymbol ")" : go stack (max 0 (depth - 1)) rest
-- その他のトークン
go stack depth (t : rest) =
  t : go stack depth rest

{-}
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] toks

go :: [Int] -> [Token] -> [Token]
go stack [] = []
-- 行頭のスペース
go stack (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
-- 行頭の改行（スペースなし）
go stack (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' rest
-- 行頭以外のスペース（SimpleLexer が出さないなら無視でOK）
go stack (TokSpace _ : rest) =
  go stack rest
-- その他のトークン
go stack (t : rest) =
  t : go stack rest
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokSymbol "(",TokIdent "layoutLexer",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "layoutLexer",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutLexer",TokIdent "toks",TokSymbol "=",TokIdent "go",TokSymbol "[",TokNumber 0,TokSymbol "]",TokNumber 0,TokIdent "toks",TokNewline,TokIdent "go",TokSymbol "::",TokSymbol "[",TokTypeIdent "Int",TokSymbol "]",TokArrow,TokTypeIdent "Int",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokIdent "stack",TokIdent "_",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokOperator "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokOperator "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVLBrace,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator ">",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "n",TokOperator ":",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator "<",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokSymbol "[",TokNumber 0,TokSymbol "]",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSpace",TokIdent "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "depth",TokOperator ">",TokNumber 0,TokSymbol "=",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "layoutLexer"
<< declBody: return DeclModule "Lexer.LayoutLexer" (Just [ExportVar "layoutLexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "layoutLexer"
<< decl parser called
<< decl dispatch: TokIdent "layoutLexer"
<< funDecl: next token=TokIdent "layoutLexer"
<< funClause: next token=TokIdent "layoutLexer"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "layoutLexer"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: layoutLexer :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "layoutLexer"
<< decl parser called
<< decl dispatch: TokIdent "layoutLexer"
<< funDecl: next token=TokIdent "layoutLexer"
<< funClause: next token=TokIdent "layoutLexer"
<< pPattern: next token TokIdent "toks"
<< pConstrOrVar: next token TokIdent "toks"
<< parsed pattern: PVar "toks"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "toks"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokSymbol "["
<< exprCore next token: TokNumber 0
<< atomBaseCore next token: TokNumber 0
<< atomBaseCore next token: TokSymbol "]"
<< atomBaseCore next token: TokNumber 0
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "go"
<< infixOp: next token TokIdent "go"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< declBody: return DeclFunGroup "layoutLexer" [FunClause [PVar "toks"] Nothing (Just (EApp (EApp (EApp (EVar "go") (EList [EInt 0])) (EInt 0)) (EVar "toks"))) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "go"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parseTypeCore: TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< parseTypeCore: TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))
<< parsed type signature: go :: TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))
<< returning DeclTypeSig: DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))))
<< declBody: return DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))))
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokIdent "stack"
<< pConstrOrVar: next token TokIdent "stack"
<< parsed pattern: PVar "stack"
<< pPattern: next token TokIdent "_"
<< pConstrOrVar: next token TokIdent "_"
<< parsed pattern: PVar "_"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "stack",PVar "_",PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereClause: next token TokIdent "go"
<< infixOp: next token TokIdent "go"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokIdent "stack"
<< pConstrOrVar: next token TokNumber 0
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokSpace"
<< pConstrOrVar: next token TokIdent "n"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PVar "stack") [PInt 0,PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))]
<< pConstrOrVar: next token TokVLBrace
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "go" [FunClause [PVar "stack",PVar "_",PList []] Nothing (Just (EList [])) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokIdent "stack"
<< pConstrOrVar: next token TokIdent "stack"
<< parsed pattern: PVar "stack"
<< pPattern: next token TokNumber 0
<< pConstrOrVar: next token TokNumber 0
<< parsed pattern: PInt 0
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokSpace"
<< pConstrOrVar: next token TokIdent "n"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))
<< parsed pattern: PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))
<< pPattern: next token TokVLBrace
<< pConstrOrVar: next token TokVLBrace
<< funClause: args=[PVar "stack",PInt 0,PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "n"
<< exprCore next token: TokIdent "n"
<< atomBaseCore next token: TokIdent "n"
<< atomBaseCore next token: TokOperator "=="
<< atomBaseCore next token: TokIdent "head"
<< atomBaseCore next token: TokIdent "stack"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "go"
<< typeSigDecl:2 TokIdent "stack"
<< valueDecl: TokIdent "go"
<< pConstrOrVar: next token TokIdent "go"
<< pConstrOrVar: next token TokIdent "stack"
<< pConstrOrVar: next token TokNumber 0
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokSpace"
<< pConstrOrVar: next token TokIdent "n"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokTypeIdent "TokNewline"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PVar "go") [PVar "stack",PInt 0,PCons (PApp (PVar "TokNewline") []) (PCons (PApp (PVar "TokSpace") [PVar "n"]) (PCons (PApp (PVar "TokNewline") []) (PApp (PVar "rest") [])))]
Just ([DeclModule "Lexer.LayoutLexer" (Just [ExportVar "layoutLexer"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "layoutLexer" [FunClause [PVar "toks"] Nothing (Just (EApp (EApp (EApp (EVar "go") (EList [EInt 0])) (EInt 0)) (EVar "toks"))) Nothing],DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))),DeclFunGroup "go" [FunClause [PVar "stack",PVar "_",PList []] Nothing (Just (EList [])) Nothing]],[TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokOperator "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokOperator "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVLBrace,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator ">",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "n",TokOperator ":",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator "<",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokSymbol "[",TokNumber 0,TokSymbol "]",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSpace",TokIdent "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "depth",TokOperator ">",TokNumber 0,TokSymbol "=",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/Lexer/Lexer.hs ===
-- Raw Source --
module Lexer.Lexer
  ( runLexer   -- ← 外部に公開する関数
  ) where

import Lexer.Token
import Lexer.SimpleLexer
import Lexer.LayoutLexer
import Layout.LayoutTransform

runLexer :: String -> [Token]
runLexer = layoutTransform . layoutLexer . slexer


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokVLBrace,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokKeyword "where",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokNewline,TokKeyword "import",TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokNewline,TokIdent "runLexer",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "runLexer",TokSymbol "=",TokIdent "layoutTransform",TokDot,TokIdent "layoutLexer",TokDot,TokIdent "slexer",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "runLexer"
<< exportItem: next token=TokIdent "runLexer"
<< declBody: return DeclModule "Lexer.Lexer" (Just [ExportVar "runLexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.SimpleLexer", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.LayoutLexer", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Layout"
<< declBody: return DeclImport {importQualified = False, importModule = "Layout.LayoutTransform", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "runLexer"
<< decl parser called
<< decl dispatch: TokIdent "runLexer"
<< funDecl: next token=TokIdent "runLexer"
<< funClause: next token=TokIdent "runLexer"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "runLexer"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TCon "String") (TList (TCon "Token"))
<< parsed type signature: runLexer :: TFun (TCon "String") (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token")))
<< declBody: return DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token")))
<< decl next token: TokIdent "runLexer"
<< decl parser called
<< decl dispatch: TokIdent "runLexer"
<< funDecl: next token=TokIdent "runLexer"
<< funClause: next token=TokIdent "runLexer"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "layoutTransform"
<< expr dispatch: TokIdent "layoutTransform"
<< exprCore next token: TokIdent "layoutTransform"
<< atomBaseCore next token: TokIdent "layoutTransform"
<< atomBaseCore next token: TokDot
<< whereClause: next token TokDot
<< infixOp: next token TokDot
<< whereBlock: next tokenTokDot
<< funClauseWithName: next token=TokDot
<< declBody: return DeclFunGroup "runLexer" [FunClause [] Nothing (Just (EVar "layoutTransform")) Nothing]
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "Lexer.Lexer" (Just [ExportVar "runLexer"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.SimpleLexer", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.LayoutLexer", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Layout.LayoutTransform", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token"))),DeclFunGroup "runLexer" [FunClause [] Nothing (Just (EVar "layoutTransform")) Nothing]],[TokDot,TokIdent "layoutLexer",TokDot,TokIdent "slexer",TokNewline])

=== Running: src/Lexer/SimpleLexer.hs ===
-- Raw Source --
module Lexer.SimpleLexer (slexer) where

import Data.Char
import Data.Char (isLetter)
import Lexer.Token

slexer :: String -> [Token]
slexer = go
  where
    go [] = []
    ------------------------------------------------------------
    -- 改行
    ------------------------------------------------------------
    go ('\n' : rest) =
      TokNewline : go rest
    ------------------------------------------------------------
    -- 行コメント "-- ..."
    ------------------------------------------------------------
    go ('-' : '-' : rest) =
      let rest' = dropWhile (/= '\n') rest
       in go rest'
    ------------------------------------------------------------
    -- ブロックコメント "{- ... -}"
    ------------------------------------------------------------
    go ('{' : '-' : rest) =
      let rest' = skipBlockComment rest
       in go rest'
    ------------------------------------------------------------
    -- 空白（スペース）
    ------------------------------------------------------------
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    ------------------------------------------------------------
    -- 文字リテラル
    ------------------------------------------------------------
    go ('\'' : rest) =
      case rest of
        ('\\' : c : '\'' : rest') ->
          TokChar (escapeChar c) : go rest'
        (c : '\'' : rest') ->
          TokChar c : go rest'
        _ ->
          TokUnknown '\'' : go rest
    ------------------------------------------------------------
    -- 文字列リテラル
    ------------------------------------------------------------
    go ('"' : rest) =
      let (str, rest') = readString rest
       in TokString str : go rest'
    ------------------------------------------------------------
    -- 数字
    ------------------------------------------------------------
    go ('-' : c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    ------------------------------------------------------------
    -- 識別子
    ------------------------------------------------------------
    go ('\\' : rest) =
      case rest of
        'c' : 'a' : 's' : 'e' : r
          | not (null r) && not (isIdentChar (head r)) ->
              TokLambdaCase : go r
        _ -> TokSymbol "\\" : go rest
    -- go (c : rest)
    --  | isLetter c =
    --      let (letters, rest') = span isIdentChar rest
    --          name = c : letters
    --       in classifyIdent name : go rest'
    go (c : rest)
      | isIdentStart c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
    ------------------------------------------------------------
    -- 複数文字記号
    ------------------------------------------------------------
    go ('-' : '>' : rest) = TokArrow : go rest
    go ('=' : '>' : rest) = TokKeyword "=>" : go rest
    go ('+' : '+' : rest) = TokOperator "++" : go rest
    go (':' : ':' : rest) = TokSymbol "::" : go rest
    go (':' : rest) = TokOperator ":" : go rest
    go ('$' : rest) = TokOperator "$" : go rest
    go ('*' : '>' : rest) = TokOperator "*>" : go rest
    go ('<' : '*' : rest) = TokOperator "<*" : go rest
    go ('>' : '>' : rest) = TokOperator ">>" : go rest
    go ('<' : '|' : '>' : rest) = TokOperator "<|>" : go rest
    go ('<' : '$' : '>' : rest) = TokOperator "<$>" : go rest
    go ('<' : '?' : '>' : rest) = TokOperator "<?>" : go rest
    go ('>' : '>' : '=' : rest) = TokOperator ">>=" : go rest
    -- go ('+' : '+' : rest) = TokSymbol "++" : go rest
    go ('=' : '=' : rest) = TokOperator "==" : go rest
    -- go ('(' : ')' : rest) = TokSymbol "()" : go rest
    -- go ('[' : ']' : rest) = TokSymbol "[]" : go rest
    go ('/' : '=' : rest) = TokOperator "/=" : go rest
    go ('<' : '=' : rest) = TokOperator "<=" : go rest
    go ('>' : '=' : rest) = TokOperator ">=" : go rest
    go ('<' : '-' : rest) = TokSymbol "<-" : go rest
    go ('.' : '.' : '.' : rest) = TokEllipsis : go rest
    go ('.' : '.' : rest) = TokSymbol ".." : go rest
    go ('.' : rest) = TokDot : go rest
    go ('+' : rest) = TokOperator "+" : go rest
    go ('-' : rest) = TokOperator "-" : go rest
    go ('*' : rest) = TokOperator "*" : go rest
    go ('/' : rest) = TokOperator "/" : go rest
    -- go ('=' : rest) = TokOperator "=" : go rest
    go ('<' : rest) = TokOperator "<" : go rest
    go ('>' : rest) = TokOperator ">" : go rest
    ------------------------------------------------------------
    -- 単一記号
    ------------------------------------------------------------
    go (c : rest)
      | isSymbolChar c =
          TokSymbol [c] : go rest
    ------------------------------------------------------------
    -- 不明文字
    ------------------------------------------------------------
    go (c : rest) =
      TokUnknown c : go rest

    ------------------------------------------------------------
    -- 補助関数
    ------------------------------------------------------------

    -- isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    -- isIdentChar c = isLetter c || isDigit c || c == '_' || c == '\'' || c == '`'
    isIdentStart c = isLetter c || c == '_' || c == '`'
    isIdentChar c = isIdentStart c || isDigit c || c == '\''

    -- isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&."
    isSymbolChar x = x `elem` "=(){}[]:;,\\'`_|@&"

    classifyIdent "sql" = TokKeyword "sql"
    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "for" = TokKeyword "for"
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "import" = TokKeyword "import"
    classifyIdent "return" = TokKeyword "return"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "class" = TokKeyword "class"
    classifyIdent "type" = TokKeyword "type"
    classifyIdent "newtype" = TokKeyword "newtype"
    classifyIdent "instance" = TokKeyword "instance"
    classifyIdent "as" = TokKeyword "as"
    classifyIdent "qualified" = TokKeyword "qualified"
    classifyIdent "hiding" = TokKeyword "hiding"
    classifyIdent "deriving" = TokKeyword "deriving"
    classifyIdent "=>" = TokKeyword "=>"
    classifyIdent "->" = TokArrow
    -- classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name

    escapeChar 'n' = '\n'
    escapeChar 't' = '\t'
    escapeChar '\\' = '\\'
    escapeChar '\'' = '\''
    escapeChar c = c

    ------------------------------------------------------------
    -- ブロックコメントスキップ
    ------------------------------------------------------------
    skipBlockComment :: String -> String
    skipBlockComment [] = []
    skipBlockComment ('-' : '}' : rest) = rest
    skipBlockComment (_ : rest) = skipBlockComment rest

    ------------------------------------------------------------
    -- 文字列リテラル読み取り
    ------------------------------------------------------------
    readString :: String -> (String, String)
    readString [] = ("", [])
    readString ('"' : rest) = ("", rest)
    readString ('\\' : c : rest) =
      let (s, rest') = readString rest
       in (escapeChar c : s, rest')
    readString (c : rest) =
      let (s, rest') = readString rest
       in (c : s, rest')

{-}
module Lexer.SimpleLexer (runLexer) where

import Data.Char
import Lexer.Token (Token (..))

runLexer :: String -> [Token]
runLexer = go
  where
    go [] = []
    go ('\n' : rest) =
      TokNewline : go rest
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
      | isAlpha c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
      | isSymbolChar c =
          TokSymbol [c] : go rest
      | otherwise =
          TokUnknown c : go rest

    isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&"

    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "->" = TokArrow
    classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokSymbol "(",TokIdent "slexer",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isLetter",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "slexer",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "slexer",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\n',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator "/=",TokChar '\n',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '{',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ' ',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokOperator "==",TokChar ' ',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokSpace",TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\'',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "(",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "TokUnknown",TokChar '\'',TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokString",TokIdent "str",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokChar 'c',TokOperator ":",TokChar 'a',TokOperator ":",TokChar 's',TokOperator ":",TokChar 'e',TokOperator ":",TokIdent "r",TokVLBrace,TokSymbol "|",TokIdent "not",TokSymbol "(",TokIdent "null",TokIdent "r",TokSymbol ")",TokSymbol "&",TokSymbol "&",TokIdent "not",TokSymbol "(",TokIdent "isIdentChar",TokSymbol "(",TokIdent "head",TokIdent "r",TokSymbol ")",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokLambdaCase",TokOperator ":",TokIdent "go",TokIdent "r",TokVRBrace,TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokTypeIdent "TokSymbol",TokString "\\",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isIdentStart",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isIdentChar",TokIdent "rest",TokVLBrace,TokIdent "name",TokSymbol "=",TokIdent "c",TokOperator ":",TokIdent "letters",TokVRBrace,TokNewline,TokKeyword "in",TokIdent "classifyIdent",TokIdent "name",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokArrow",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "++",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ":",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '$',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "$",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '|',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<|>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '$',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<$>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '?',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<?>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokEllipsis",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "..",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokDot",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "+",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isSymbolChar",TokIdent "c",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokSymbol "[",TokIdent "c",TokSymbol "]",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokUnknown",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "isIdentStart",TokIdent "c",TokSymbol "=",TokIdent "isLetter",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '_',TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '`',TokSymbol ";",TokIdent "isIdentChar",TokIdent "c",TokSymbol "=",TokIdent "isIdentStart",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '\'',TokSymbol ";",TokSymbol ";",TokIdent "isSymbolChar",TokIdent "x",TokSymbol "=",TokIdent "x",TokIdent "`elem`",TokString "=(){}[]:;,\\'`_|@&",TokSymbol ";",TokIdent "classifyIdent",TokString "sql",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokString "do",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokString "let",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokString "in",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokString "case",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokString "of",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokString "where",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokString "forall",TokSymbol "=",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokString "for",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokString "if",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokString "then",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokString "else",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokString "module",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokString "import",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokString "return",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokString "data",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokString "class",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokString "type",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokString "newtype",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokString "instance",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokString "as",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "as",TokSymbol ";",TokIdent "classifyIdent",TokString "qualified",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "qualified",TokSymbol ";",TokIdent "classifyIdent",TokString "hiding",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "hiding",TokSymbol ";",TokIdent "classifyIdent",TokString "deriving",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "deriving",TokSymbol ";",TokIdent "classifyIdent",TokString "=>",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokString "->",TokSymbol "=",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokString ".",TokSymbol "=",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokString "::",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokString "<-",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokString "==",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokString "<=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokString ">=",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokString "/=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokIdent "name",TokVLBrace,TokSymbol "|",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokTypeIdent",TokIdent "name",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokIdent",TokIdent "name",TokVRBrace,TokNewline,TokIdent "escapeChar",TokChar 'n',TokSymbol "=",TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokChar 't',TokSymbol "=",TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokChar '\\',TokSymbol "=",TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokChar '\'',TokSymbol "=",TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokIdent "c",TokSymbol "=",TokIdent "c",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '}',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokIdent "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "readString",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "slexer"
<< declBody: return DeclModule "Lexer.SimpleLexer" (Just [ExportVar "slexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isLetter"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "slexer"
<< decl parser called
<< decl dispatch: TokIdent "slexer"
<< funDecl: next token=TokIdent "slexer"
<< funClause: next token=TokIdent "slexer"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "slexer"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TCon "String") (TList (TCon "Token"))
<< parsed type signature: slexer :: TFun (TCon "String") (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token")))
<< declBody: return DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token")))
<< decl next token: TokIdent "slexer"
<< decl parser called
<< decl dispatch: TokIdent "slexer"
<< funDecl: next token=TokIdent "slexer"
<< funClause: next token=TokIdent "slexer"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokVLBrace
<< whereClause: next token TokVLBrace
<< infixOp: next token TokVLBrace
<< whereBlock: next tokenTokKeyword "where"
<< whereBlock:2 next tokenTokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< whereBlock: next tokenTokSymbol ";"
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokChar '\n'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\n') []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\n') []) (PApp (PVar "rest") [])) []
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "TokNewline"
<< exprCore next token: TokTypeIdent "TokNewline"
<< atomBaseCore next token: TokTypeIdent "TokNewline"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokChar '-'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokChar '-'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '-') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '-') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))) []
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokIdent "rest'"
<< valueBinding next token: TokIdent "rest'"
<< pConstrOrVar: next token TokIdent "rest'"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< expr dispatch: TokIdent "dropWhile"
<< exprCore next token: TokIdent "dropWhile"
<< atomBaseCore next token: TokIdent "dropWhile"
<< exprCore next token: TokChar '\n'
<< atomBaseCore next token: TokChar '\n'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< whereClause: next token TokVLBrace
<< infixOp: next token TokVLBrace
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokChar '{'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokChar '-'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '{') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))) []
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokIdent "rest'"
<< valueBinding next token: TokIdent "rest'"
<< pConstrOrVar: next token TokIdent "rest'"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< expr dispatch: TokIdent "skipBlockComment"
<< exprCore next token: TokIdent "skipBlockComment"
<< atomBaseCore next token: TokIdent "skipBlockComment"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< whereClause: next token TokVLBrace
<< infixOp: next token TokVLBrace
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokChar ' '
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar ' ') []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar ' ') []) (PApp (PVar "rest") [])) []
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "spaces"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "spaces") []
<< pConstrOrVar: next token TokIdent "rest'"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "spaces") [],PApp (PVar "rest'") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar ' '
<< atomBaseCore next token: TokChar ' '
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< whereClause: next token TokVLBrace
<< infixOp: next token TokVLBrace
<< expr dispatch: TokTypeIdent "TokSpace"
<< exprCore next token: TokTypeIdent "TokSpace"
<< atomBaseCore next token: TokTypeIdent "TokSpace"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokChar '\''
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])) []
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "rest"
<< exprCore next token: TokIdent "rest"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokChar '\\'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "c"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokChar '\''
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest'"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< caseAlt: next token TokArrow PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokChar '\''
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])
<< parsed pattern: PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "rest"
<< exprCore next token: TokIdent "rest"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokChar '\\'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "c"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokChar '\''
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest'"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< caseAlt: next token TokArrow PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "slexer" [FunClause [] Nothing (Just (EVar "go")) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Lexer.SimpleLexer" (Just [ExportVar "slexer"]),DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isLetter"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token"))),DeclFunGroup "slexer" [FunClause [] Nothing (Just (EVar "go")) Nothing]],[TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\n',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator "/=",TokChar '\n',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '{',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ' ',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokOperator "==",TokChar ' ',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokSpace",TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\'',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "(",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "TokUnknown",TokChar '\'',TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokString",TokIdent "str",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokChar 'c',TokOperator ":",TokChar 'a',TokOperator ":",TokChar 's',TokOperator ":",TokChar 'e',TokOperator ":",TokIdent "r",TokVLBrace,TokSymbol "|",TokIdent "not",TokSymbol "(",TokIdent "null",TokIdent "r",TokSymbol ")",TokSymbol "&",TokSymbol "&",TokIdent "not",TokSymbol "(",TokIdent "isIdentChar",TokSymbol "(",TokIdent "head",TokIdent "r",TokSymbol ")",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokLambdaCase",TokOperator ":",TokIdent "go",TokIdent "r",TokVRBrace,TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokTypeIdent "TokSymbol",TokString "\\",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isIdentStart",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isIdentChar",TokIdent "rest",TokVLBrace,TokIdent "name",TokSymbol "=",TokIdent "c",TokOperator ":",TokIdent "letters",TokVRBrace,TokNewline,TokKeyword "in",TokIdent "classifyIdent",TokIdent "name",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokArrow",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "++",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ":",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '$',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "$",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '|',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<|>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '$',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<$>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '?',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<?>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokEllipsis",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "..",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokDot",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "+",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isSymbolChar",TokIdent "c",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokSymbol "[",TokIdent "c",TokSymbol "]",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokUnknown",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "isIdentStart",TokIdent "c",TokSymbol "=",TokIdent "isLetter",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '_',TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '`',TokSymbol ";",TokIdent "isIdentChar",TokIdent "c",TokSymbol "=",TokIdent "isIdentStart",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokOperator "==",TokChar '\'',TokSymbol ";",TokSymbol ";",TokIdent "isSymbolChar",TokIdent "x",TokSymbol "=",TokIdent "x",TokIdent "`elem`",TokString "=(){}[]:;,\\'`_|@&",TokSymbol ";",TokIdent "classifyIdent",TokString "sql",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokString "do",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokString "let",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokString "in",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokString "case",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokString "of",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokString "where",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokString "forall",TokSymbol "=",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokString "for",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokString "if",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokString "then",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokString "else",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokString "module",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokString "import",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokString "return",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokString "data",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokString "class",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokString "type",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokString "newtype",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokString "instance",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokString "as",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "as",TokSymbol ";",TokIdent "classifyIdent",TokString "qualified",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "qualified",TokSymbol ";",TokIdent "classifyIdent",TokString "hiding",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "hiding",TokSymbol ";",TokIdent "classifyIdent",TokString "deriving",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "deriving",TokSymbol ";",TokIdent "classifyIdent",TokString "=>",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokString "->",TokSymbol "=",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokString ".",TokSymbol "=",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokString "::",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokString "<-",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokString "==",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokString "<=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokString ">=",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokString "/=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokIdent "name",TokVLBrace,TokSymbol "|",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokTypeIdent",TokIdent "name",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokIdent",TokIdent "name",TokVRBrace,TokNewline,TokIdent "escapeChar",TokChar 'n',TokSymbol "=",TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokChar 't',TokSymbol "=",TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokChar '\\',TokSymbol "=",TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokChar '\'',TokSymbol "=",TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokIdent "c",TokSymbol "=",TokIdent "c",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '}',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokIdent "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "readString",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Lexer/Token.hs ===
-- Raw Source --
{-# LANGUAGE OverloadedStrings #-}

module Lexer.Token
  ( Token (..),
  )
where

{-}
import Control.Applicative
import Data.Char (isUpper)
import Data.Void
-- import Text.Megaparsec.Char (oneOf)
import Text.Megaparsec (ParseErrorBundle, Parsec, choice, eof, manyTill, oneOf, parse, satisfy, try, (<|>))
import Text.Megaparsec.Char (alphaNumChar, char, letterChar, space1, string)
import qualified Text.Megaparsec.Char.Lexer as L
-}

-- Parser type
-- type Parser = Parsec Void String

-- Token definition
data Token
  = TokKeyword String
  | TokIdent String
  | TokTypeIdent String
  | TokNumber Int
  | TokFloat Double
  | TokString String
  | TokSymbol String
  | TokOperator String
  | TokChar Char
  | TokForall
  | TokDot
  | TokEllipsis
  | TokArrow
  | TokLParen
  | TokRParen
  | TokNewline
  | TokInt Int
  | TokSpace Int
  | TokIndent
  | TokVLBrace
  | TokVRBrace
  | TokVSemicolon
  | TokVNewline (Int, Int)
  | TokLambdaCase
  | TokUnknown Char
  deriving (Show, Eq, Ord)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokVLBrace,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Token",TokVLBrace,TokSymbol "=",TokTypeIdent "TokKeyword",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokIdent",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokTypeIdent",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokNumber",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokFloat",TokTypeIdent "Double",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokSymbol",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokOperator",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokForall",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokDot",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokEllipsis",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokLParen",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokRParen",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokNewline",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokSpace",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokIndent",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVLBrace",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVRBrace",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVSemicolon",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVNewline",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokLambdaCase",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokUnknown",TokTypeIdent "Char",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Ord",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Token"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Lexer.Token" (Just [ExportType "Token" True])
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokKeyword" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokIdent" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokTypeIdent" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Int"
<< dataConstrNormal: "TokNumber" [TCon "Int"]
<< dataConstrRecord: TokTypeIdent "Double"
<< dataConstrNormal: "TokFloat" [TCon "Double"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokString" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokSymbol" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TokOperator" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Char"
<< dataConstrNormal: "TokChar" [TCon "Char"]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokForall" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokDot" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokEllipsis" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokArrow" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokLParen" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokRParen" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokNewline" []
<< dataConstrRecord: TokTypeIdent "Int"
<< dataConstrNormal: "TokInt" [TCon "Int"]
<< dataConstrRecord: TokTypeIdent "Int"
<< dataConstrNormal: "TokSpace" [TCon "Int"]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokIndent" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokVLBrace" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokVRBrace" []
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokVSemicolon" []
<< dataConstrRecord: TokSymbol "("
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Int"
<< dataConstrNormal: "TokVNewline" [TTuple [TCon "Int",TCon "Int"]]
<< dataConstrRecord: TokSymbol "|"
<< dataConstrNormal: "TokLambdaCase" []
<< dataConstrRecord: TokTypeIdent "Char"
<< dataConstrNormal: "TokUnknown" [TCon "Char"]
<< declBody: return DeclData "Token" [] [Constraint "TokKeyword" [TCon "String"],Constraint "TokIdent" [TCon "String"],Constraint "TokTypeIdent" [TCon "String"],Constraint "TokNumber" [TCon "Int"],Constraint "TokFloat" [TCon "Double"],Constraint "TokString" [TCon "String"],Constraint "TokSymbol" [TCon "String"],Constraint "TokOperator" [TCon "String"],Constraint "TokChar" [TCon "Char"],Constraint "TokForall" [],Constraint "TokDot" [],Constraint "TokEllipsis" [],Constraint "TokArrow" [],Constraint "TokLParen" [],Constraint "TokRParen" [],Constraint "TokNewline" [],Constraint "TokInt" [TCon "Int"],Constraint "TokSpace" [TCon "Int"],Constraint "TokIndent" [],Constraint "TokVLBrace" [],Constraint "TokVRBrace" [],Constraint "TokVSemicolon" [],Constraint "TokVNewline" [TTuple [TCon "Int",TCon "Int"]],Constraint "TokLambdaCase" [],Constraint "TokUnknown" [TCon "Char"]] ["Show","Eq","Ord"]
Just ([DeclModule "Lexer.Token" (Just [ExportType "Token" True]),DeclData "Token" [] [Constraint "TokKeyword" [TCon "String"],Constraint "TokIdent" [TCon "String"],Constraint "TokTypeIdent" [TCon "String"],Constraint "TokNumber" [TCon "Int"],Constraint "TokFloat" [TCon "Double"],Constraint "TokString" [TCon "String"],Constraint "TokSymbol" [TCon "String"],Constraint "TokOperator" [TCon "String"],Constraint "TokChar" [TCon "Char"],Constraint "TokForall" [],Constraint "TokDot" [],Constraint "TokEllipsis" [],Constraint "TokArrow" [],Constraint "TokLParen" [],Constraint "TokRParen" [],Constraint "TokNewline" [],Constraint "TokInt" [TCon "Int"],Constraint "TokSpace" [TCon "Int"],Constraint "TokIndent" [],Constraint "TokVLBrace" [],Constraint "TokVRBrace" [],Constraint "TokVSemicolon" [],Constraint "TokVNewline" [TTuple [TCon "Int",TCon "Int"]],Constraint "TokLambdaCase" [],Constraint "TokUnknown" [TCon "Char"]] ["Show","Eq","Ord"]],[TokNewline])

=== Running: src/main.hs ===
-- Raw Source --
module Main where

-- import Parser.Core.Parser (runParser)

-- (runLexer)
-- import Layout.LayoutTransform --
-- import Lexer.LayoutLexer

import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified Data.Text.IO as TIO
import Decl.DeclParserCore (program)
import Lexer.Lexer (runLexer)
import Lexer.Token (Token)
import Parser.Core.Combinator (Parser (..), runParser, try)
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO
import System.IO (readFile)
import Utils.MyTrace (setTrace)

main :: IO ()
main = do
  args <- getArgs
  case args of
    [file] -> processFile file
    _ -> putStrLn "Usage: myparser <filename>"

processFile :: FilePath -> IO ()
processFile file = do
  handle <- openFile file ReadMode
  hSetEncoding handle utf8 -- ★ ここでエンコーディングを明示！
  src <- TIO.hGetContents handle
  -- src <- T.readFile file

  putStrLn "-- Raw Source --"
  putStrLn (T.unpack src)

  let toks3 = runLexer (T.unpack src)
  putStrLn "\n-- Tokens from Lexer --"
  print toks3
  {-}
    let toks2 = layoutLexer toks1
    putStrLn "\n-- Tokens from LayoutLexer --"
    print toks2

    let toks3 = layoutTransform toks2
    putStrLn "\n-- Tokens after LayoutTransform --"
    print toks3
  -}
  putStrLn "\n-- Parsing --"
  let ast = runParser program toks3
  putStrLn "\n-- Parsed AST --"
  print ast


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Main",TokKeyword "where",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokKeyword "as",TokTypeIdent "T",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokKeyword "as",TokTypeIdent "T",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokKeyword "as",TokTypeIdent "TIO",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSymbol "(",TokIdent "program",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "try",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "Environment",TokSymbol "(",TokIdent "getArgs",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "Exit",TokSymbol "(",TokIdent "exitFailure",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokSymbol "(",TokIdent "readFile",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "setTrace",TokSymbol ")",TokNewline,TokIdent "main",TokSymbol "::",TokTypeIdent "IO",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "main",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "getArgs",TokSymbol ";",TokKeyword "case",TokIdent "args",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "file",TokSymbol "]",TokArrow,TokIdent "processFile",TokIdent "file",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "putStrLn",TokString "Usage: myparser <filename>",TokVRBrace,TokVRBrace,TokNewline,TokIdent "processFile",TokSymbol "::",TokTypeIdent "FilePath",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "processFile",TokIdent "file",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "handle",TokSymbol "<-",TokIdent "openFile",TokIdent "file",TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokIdent "handle",TokIdent "utf8",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokIdent "handle",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "toks3",TokSymbol "=",TokIdent "runLexer",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokIdent "ast",TokSymbol "=",TokIdent "runParser",TokIdent "program",TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokIdent "ast",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "Main" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text", importAlias = Just "T", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "T", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "TIO", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "program"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser",ImportVar "runParser",ImportVar "try"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.Environment", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "getArgs"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.Exit", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exitFailure"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "readFile"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "setTrace"]}
<< decl next token: TokIdent "main"
<< decl parser called
<< decl dispatch: TokIdent "main"
<< funDecl: next token=TokIdent "main"
<< funClause: next token=TokIdent "main"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "main"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "IO"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parsed type signature: main :: TApp (TCon "IO") TUnit
<< returning DeclTypeSig: DeclTypeSig "main" (TApp (TCon "IO") TUnit)
<< declBody: return DeclTypeSig "main" (TApp (TCon "IO") TUnit)
<< decl next token: TokIdent "main"
<< decl parser called
<< decl dispatch: TokIdent "main"
<< funDecl: next token=TokIdent "main"
<< funClause: next token=TokIdent "main"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "args"
<< pConstrOrVar: next token TokIdent "args"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "args") []
<< expr dispatch: TokIdent "getArgs"
<< exprCore next token: TokIdent "getArgs"
<< atomBaseCore next token: TokIdent "getArgs"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "args"
<< exprCore next token: TokIdent "args"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokIdent "file"
<< pConstrOrVar: next token TokSymbol "]"
<< pattern1: (pAs <|> makeCons)PApp (PVar "file") []
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PList [PApp (PVar "file") []]) []
<< caseAlt: next token TokArrow PApp (PList [PApp (PVar "file") []]) []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "processFile"
<< exprCore next token: TokIdent "processFile"
<< atomBaseCore next token: TokIdent "processFile"
<< atomBaseCore next token: TokIdent "file"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< caseAlt: next token TokArrow PApp (PVar "_") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "putStrLn"
<< exprCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokString "Usage: myparser <filename>"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "processFile"
<< infixOp: next token TokIdent "processFile"
<< whereBlock: next tokenTokIdent "processFile"
<< funClauseWithName: next token=TokIdent "processFile"
<< declBody: return DeclFunGroup "main" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "args") []) (EVar "getArgs"),ExprStmt (ECase (EVar "args") [CaseAlt (PApp (PList [PApp (PVar "file") []]) []) (EApp (EVar "processFile") (EVar "file")),CaseAlt (PApp (PVar "_") []) (EApp (EVar "putStrLn") (EString "Usage: myparser <filename>"))])])) Nothing]
<< decl next token: TokIdent "processFile"
<< decl parser called
<< decl dispatch: TokIdent "processFile"
<< funDecl: next token=TokIdent "processFile"
<< funClause: next token=TokIdent "processFile"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "processFile"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "FilePath"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parseTypeCore: TFun (TCon "FilePath") (TApp (TCon "IO") TUnit)
<< parsed type signature: processFile :: TFun (TCon "FilePath") (TApp (TCon "IO") TUnit)
<< returning DeclTypeSig: DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit))
<< declBody: return DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit))
<< decl next token: TokIdent "processFile"
<< decl parser called
<< decl dispatch: TokIdent "processFile"
<< funDecl: next token=TokIdent "processFile"
<< funClause: next token=TokIdent "processFile"
<< pPattern: next token TokIdent "file"
<< pConstrOrVar: next token TokIdent "file"
<< parsed pattern: PVar "file"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "file"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "handle"
<< pConstrOrVar: next token TokIdent "handle"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "handle") []
<< expr dispatch: TokIdent "openFile"
<< exprCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "file"
<< atomBaseCore next token: TokTypeIdent "ReadMode"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "hSetEncoding"
<< pConstrOrVar: next token TokIdent "hSetEncoding"
<< pConstrOrVar: next token TokIdent "handle"
<< pConstrOrVar: next token TokIdent "utf8"
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "hSetEncoding") [PVar "handle",PVar "utf8"]
<< expr dispatch: TokIdent "hSetEncoding"
<< exprCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "handle"
<< atomBaseCore next token: TokIdent "utf8"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "src"
<< pConstrOrVar: next token TokIdent "src"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "src") []
<< expr dispatch: TokTypeIdent "TIO"
<< exprCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokDot
<< whereClause: next token TokDot
<< infixOp: next token TokDot
<< typeSigDecl: TokIdent "processFile"
<< typeSigDecl:2 TokIdent "file"
<< valueDecl: TokIdent "processFile"
<< pConstrOrVar: next token TokIdent "processFile"
<< pConstrOrVar: next token TokIdent "file"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "processFile") [PVar "file"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "handle"
<< pConstrOrVar: next token TokIdent "handle"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "handle") []
<< expr dispatch: TokIdent "openFile"
<< exprCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "file"
<< atomBaseCore next token: TokTypeIdent "ReadMode"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "hSetEncoding"
<< pConstrOrVar: next token TokIdent "hSetEncoding"
<< pConstrOrVar: next token TokIdent "handle"
<< pConstrOrVar: next token TokIdent "utf8"
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "hSetEncoding") [PVar "handle",PVar "utf8"]
<< expr dispatch: TokIdent "hSetEncoding"
<< exprCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "handle"
<< atomBaseCore next token: TokIdent "utf8"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "src"
<< pConstrOrVar: next token TokIdent "src"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "src") []
<< expr dispatch: TokTypeIdent "TIO"
<< exprCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokDot
<< whereClause: next token TokDot
<< infixOp: next token TokDot
Just ([DeclModule "Main" Nothing,DeclImport {importQualified = True, importModule = "Data.Text", importAlias = Just "T", importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "T", importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "TIO", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Decl.DeclParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "program"]},DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser",ImportVar "runParser",ImportVar "try"]},DeclImport {importQualified = False, importModule = "System.Environment", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "getArgs"]},DeclImport {importQualified = False, importModule = "System.Exit", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exitFailure"]},DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "readFile"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "setTrace"]},DeclTypeSig "main" (TApp (TCon "IO") TUnit),DeclFunGroup "main" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "args") []) (EVar "getArgs"),ExprStmt (ECase (EVar "args") [CaseAlt (PApp (PList [PApp (PVar "file") []]) []) (EApp (EVar "processFile") (EVar "file")),CaseAlt (PApp (PVar "_") []) (EApp (EVar "putStrLn") (EString "Usage: myparser <filename>"))])])) Nothing],DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit))],[TokNewline,TokIdent "processFile",TokIdent "file",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "handle",TokSymbol "<-",TokIdent "openFile",TokIdent "file",TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokIdent "handle",TokIdent "utf8",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokIdent "handle",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "toks3",TokSymbol "=",TokIdent "runLexer",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokIdent "ast",TokSymbol "=",TokIdent "runParser",TokIdent "program",TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokIdent "ast",TokVRBrace,TokNewline])

=== Running: src/Parser/Core/Combinator.hs ===
-- Raw Source --
{-# LANGUAGE InstanceSigs #-}

module Parser.Core.Combinator
  ( Parser (..),
    runParser,
    satisfy,
    satisfyMap,
    token,
    tokens,
    between,
    sepBy,
    sepBy1,
    sepEndBy,
    sepEndBy1,
    try,
    chainl1,
    many1,
    manyTill,
    choice,
    choice1,
    lookAhead,
    option,
    skipMany,
    skipMany1
  )
where

import Control.Applicative (Alternative (..), many)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))

-- import app.MyTrace (myTrace)

-- 差分リスト風パーサー
newtype Parser a = Parser {runParser :: [Token] -> Maybe (a, [Token])}

instance Functor Parser where
  fmap :: (a -> b) -> Parser a -> Parser b
  fmap f p = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> Just (f a, rest)
      Nothing -> Nothing

instance Applicative Parser where
  pure :: a -> Parser a
  pure a = Parser $ \input -> Just (a, input)
  (<*>) :: Parser (a -> b) -> Parser a -> Parser b
  pf <*> pa = Parser $ \input ->
    case runParser pf input of
      Just (f, rest1) ->
        case runParser pa rest1 of
          Just (a, rest2) -> Just (f a, rest2)
          Nothing -> Nothing
      Nothing -> Nothing

instance Monad Parser where
  (>>=) :: Parser a -> (a -> Parser b) -> Parser b
  p >>= f = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> runParser (f a) rest
      Nothing -> Nothing

instance Alternative Parser where
  empty :: Parser a
  empty = Parser $ const Nothing
  (<|>) :: Parser a -> Parser a -> Parser a
  p1 <|> p2 = Parser $ \input ->
    runParser p1 input <|> runParser p2 input

-- 補助関数
satisfy :: (Token -> Bool) -> Parser Token
satisfy f = Parser $ \tokens -> case tokens of
  (t : ts) | f t -> Just (t, ts)
  _ -> Nothing

satisfyMap :: (Token -> Maybe a) -> Parser a
satisfyMap f = Parser $ \tokens -> case tokens of
  (t : ts) -> case f t of
    Just x -> Just (x, ts)
    Nothing -> Nothing
  [] -> Nothing

token :: Token -> Parser Token
token t = satisfy (== t)

tokens :: [Token] -> Parser [Token]
tokens expected = Parser $ \input ->
  if expected `isPrefixOf` input
    then Just (expected, drop (length expected) input)
    else Nothing

between :: Parser open -> Parser close -> Parser a -> Parser a
between open close p = do
  _ <- open
  x <- p
  _ <- close
  return x

sepBy :: Parser a -> Parser sep -> Parser [a]
sepBy p sep =
  ( do
      x <- p
      xs <- many (sep *> p)
      return (x : xs)
  )
    <|> pure []

sepBy1 :: Parser a -> Parser sep -> Parser [a]
sepBy1 p sep = do
  first <- p
  rest <- (sep *> sepBy1 p sep) <|> pure []
  return (first : rest)

sepEndBy1 :: Parser a -> Parser sep -> Parser [a]
sepEndBy1 p sep = do
  x <- p
  ( do
      _ <- sep
      xs <- sepEndBy p sep
      return (x : xs)
    )
    <|> pure [x]

sepEndBy :: Parser a -> Parser sep -> Parser [a]
sepEndBy p sep = sepEndBy1 p sep <|> pure []

try :: Parser a -> Parser a
try p = Parser $ \tokens -> runParser p tokens

chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
chainl1 p op = do
  x <- p
  rest x
  where
    rest x =
      ( do
          f <- op
          y <- p
          rest (f x y)
      )
        <|> return x

many1 :: Parser a -> Parser [a]
many1 p = (:) <$> p <*> many p

manyTill :: Parser a -> Parser end -> Parser [a]
manyTill p end = go
  where
    go =
      end
        *> pure []
          <|> (:)
        <$> p
        <*> go

choice1 :: Parser a -> Parser a -> Parser a
choice1 p q = Parser $ \input ->
  case runParser p input of
    Just r -> Just r
    Nothing -> runParser q input

choice :: [Parser a] -> Parser a
choice [] = Parser $ \_ -> Nothing
choice (p : ps) = choice1 p (choice ps)

option :: a -> Parser a -> Parser a
option x p = p <|> pure x

{-}
lookAhead :: Parser a -> Parser a
lookAhead p = Parser $ \input ->
  case runParser p input of
    Just (a, _) -> Just (a, input) -- 成功しても input を消費しない
    Nothing -> Nothing
-}

lookAhead :: Parser a -> Parser a
lookAhead (Parser p) = Parser $ \input ->
  case p input of
    Just (a, _) -> Just (a, input) -- 結果はそのまま、入力は消費しない
    Nothing -> Nothing


skipMany1 :: Parser a -> Parser ()
skipMany1 p = p *> skipMany p

skipMany :: Parser a -> Parser ()
skipMany p = Parser $ \ts ->
  case runParser p ts of
    Just (_, ts') -> runParser (skipMany p) ts'
    Nothing -> Just ((), ts)

-- 依存：symbol は TokenParser 側で定義されるため、ここでは定義しない


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokVLBrace,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "satisfy",TokSymbol ",",TokIdent "satisfyMap",TokSymbol ",",TokIdent "token",TokSymbol ",",TokIdent "tokens",TokSymbol ",",TokIdent "between",TokSymbol ",",TokIdent "sepBy",TokSymbol ",",TokIdent "sepBy1",TokSymbol ",",TokIdent "sepEndBy",TokSymbol ",",TokIdent "sepEndBy1",TokSymbol ",",TokIdent "try",TokSymbol ",",TokIdent "chainl1",TokSymbol ",",TokIdent "many1",TokSymbol ",",TokIdent "manyTill",TokSymbol ",",TokIdent "choice",TokSymbol ",",TokIdent "choice1",TokSymbol ",",TokIdent "lookAhead",TokSymbol ",",TokIdent "option",TokSymbol ",",TokIdent "skipMany",TokSymbol ",",TokIdent "skipMany1",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokTypeIdent "Alternative",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "many",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "newtype",TokTypeIdent "Parser",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokSymbol "{",TokIdent "runParser",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "instance",TokTypeIdent "Functor",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "fmap",TokSymbol "::",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "fmap",TokIdent "f",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Applicative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "pure",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "pure",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<*",TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "pf",TokOperator "<*",TokOperator ">",TokIdent "pa",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pf",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pa",TokIdent "rest1",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Monad",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokSymbol "(",TokOperator ">>",TokSymbol "=",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "p",TokOperator ">>",TokSymbol "=",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Alternative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "empty",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "empty",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokIdent "const",TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "p1",TokOperator "<|>",TokIdent "p2",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokIdent "runParser",TokIdent "p1",TokIdent "input",TokOperator "<|>",TokIdent "runParser",TokIdent "p2",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfy",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "|",TokIdent "f",TokIdent "t",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "satisfyMap",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyMap",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "token",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "token",TokIdent "t",TokSymbol "=",TokIdent "satisfy",TokSymbol "(",TokOperator "==",TokIdent "t",TokSymbol ")",TokNewline,TokIdent "tokens",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokIdent "expected",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "expected",TokIdent "`isPrefixOf`",TokIdent "input",TokVLBrace,TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "between",TokSymbol "::",TokTypeIdent "Parser",TokIdent "open",TokArrow,TokTypeIdent "Parser",TokIdent "close",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "between",TokIdent "open",TokIdent "close",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "open",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "close",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "sepBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "first",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "first",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "sepEndBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokIdent "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokIdent "x",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepEndBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "try",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "try",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokIdent "runParser",TokIdent "p",TokIdent "tokens",TokNewline,TokIdent "chainl1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "chainl1",TokIdent "p",TokIdent "op",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokIdent "x",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "x",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "x",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "many1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokIdent "p",TokSymbol "=",TokSymbol "(",TokOperator ":",TokSymbol ")",TokOperator "<$>",TokIdent "p",TokOperator "<*",TokOperator ">",TokIdent "many",TokIdent "p",TokNewline,TokIdent "manyTill",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "end",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokIdent "p",TokIdent "end",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "=",TokVLBrace,TokIdent "end",TokVLBrace,TokOperator "*>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokOperator ":",TokSymbol ")",TokVRBrace,TokNewline,TokOperator "<$>",TokIdent "p",TokSymbol ";",TokOperator "<*",TokOperator ">",TokIdent "go",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice1",TokIdent "p",TokIdent "q",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "r",TokArrow,TokTypeIdent "Just",TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokIdent "runParser",TokIdent "q",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice",TokSymbol "::",TokSymbol "[",TokTypeIdent "Parser",TokIdent "a",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokIdent "choice1",TokIdent "p",TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokIdent "option",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "option",TokIdent "x",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "<|>",TokIdent "pure",TokIdent "x",TokNewline,TokIdent "lookAhead",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "lookAhead",TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipMany1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany1",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "*>",TokIdent "skipMany",TokIdent "p",TokNewline,TokIdent "skipMany",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "ts",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Parser"
<< exportItem: next token=TokIdent "runParser"
<< exportItem: next token=TokIdent "satisfy"
<< exportItem: next token=TokIdent "satisfyMap"
<< exportItem: next token=TokIdent "token"
<< exportItem: next token=TokIdent "tokens"
<< exportItem: next token=TokIdent "between"
<< exportItem: next token=TokIdent "sepBy"
<< exportItem: next token=TokIdent "sepBy1"
<< exportItem: next token=TokIdent "sepEndBy"
<< exportItem: next token=TokIdent "sepEndBy1"
<< exportItem: next token=TokIdent "try"
<< exportItem: next token=TokIdent "chainl1"
<< exportItem: next token=TokIdent "many1"
<< exportItem: next token=TokIdent "manyTill"
<< exportItem: next token=TokIdent "choice"
<< exportItem: next token=TokIdent "choice1"
<< exportItem: next token=TokIdent "lookAhead"
<< exportItem: next token=TokIdent "option"
<< exportItem: next token=TokIdent "skipMany"
<< exportItem: next token=TokIdent "skipMany1"
<< declBody: return DeclModule "Parser.Core.Combinator" (Just [ExportType "Parser" True,ExportVar "runParser",ExportVar "satisfy",ExportVar "satisfyMap",ExportVar "token",ExportVar "tokens",ExportVar "between",ExportVar "sepBy",ExportVar "sepBy1",ExportVar "sepEndBy",ExportVar "sepEndBy1",ExportVar "try",ExportVar "chainl1",ExportVar "many1",ExportVar "manyTill",ExportVar "choice",ExportVar "choice1",ExportVar "lookAhead",ExportVar "option",ExportVar "skipMany",ExportVar "skipMany1"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Alternative",ImportVar "many"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "newtype"
<< decl parser called
<< decl dispatch: TokKeyword "newtype"
<< unknown token in decl: TokKeyword "newtype"
Just ([DeclModule "Parser.Core.Combinator" (Just [ExportType "Parser" True,ExportVar "runParser",ExportVar "satisfy",ExportVar "satisfyMap",ExportVar "token",ExportVar "tokens",ExportVar "between",ExportVar "sepBy",ExportVar "sepBy1",ExportVar "sepEndBy",ExportVar "sepEndBy1",ExportVar "try",ExportVar "chainl1",ExportVar "many1",ExportVar "manyTill",ExportVar "choice",ExportVar "choice1",ExportVar "lookAhead",ExportVar "option",ExportVar "skipMany",ExportVar "skipMany1"]),DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Alternative",ImportVar "many"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}],[TokNewline,TokKeyword "newtype",TokTypeIdent "Parser",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokSymbol "{",TokIdent "runParser",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "instance",TokTypeIdent "Functor",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "fmap",TokSymbol "::",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "fmap",TokIdent "f",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Applicative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "pure",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "pure",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<*",TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "pf",TokOperator "<*",TokOperator ">",TokIdent "pa",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pf",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pa",TokIdent "rest1",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Monad",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokSymbol "(",TokOperator ">>",TokSymbol "=",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "p",TokOperator ">>",TokSymbol "=",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Alternative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "empty",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "empty",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokIdent "const",TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "p1",TokOperator "<|>",TokIdent "p2",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokIdent "runParser",TokIdent "p1",TokIdent "input",TokOperator "<|>",TokIdent "runParser",TokIdent "p2",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfy",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "|",TokIdent "f",TokIdent "t",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "satisfyMap",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyMap",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "token",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "token",TokIdent "t",TokSymbol "=",TokIdent "satisfy",TokSymbol "(",TokOperator "==",TokIdent "t",TokSymbol ")",TokNewline,TokIdent "tokens",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokIdent "expected",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "expected",TokIdent "`isPrefixOf`",TokIdent "input",TokVLBrace,TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "between",TokSymbol "::",TokTypeIdent "Parser",TokIdent "open",TokArrow,TokTypeIdent "Parser",TokIdent "close",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "between",TokIdent "open",TokIdent "close",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "open",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "close",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "sepBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "first",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "first",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "sepEndBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokIdent "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokIdent "x",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepEndBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "try",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "try",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokIdent "runParser",TokIdent "p",TokIdent "tokens",TokNewline,TokIdent "chainl1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "chainl1",TokIdent "p",TokIdent "op",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokIdent "x",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "x",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "x",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "many1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokIdent "p",TokSymbol "=",TokSymbol "(",TokOperator ":",TokSymbol ")",TokOperator "<$>",TokIdent "p",TokOperator "<*",TokOperator ">",TokIdent "many",TokIdent "p",TokNewline,TokIdent "manyTill",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "end",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokIdent "p",TokIdent "end",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "=",TokVLBrace,TokIdent "end",TokVLBrace,TokOperator "*>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokOperator ":",TokSymbol ")",TokVRBrace,TokNewline,TokOperator "<$>",TokIdent "p",TokSymbol ";",TokOperator "<*",TokOperator ">",TokIdent "go",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice1",TokIdent "p",TokIdent "q",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "r",TokArrow,TokTypeIdent "Just",TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokIdent "runParser",TokIdent "q",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice",TokSymbol "::",TokSymbol "[",TokTypeIdent "Parser",TokIdent "a",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokIdent "choice1",TokIdent "p",TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokIdent "option",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "option",TokIdent "x",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "<|>",TokIdent "pure",TokIdent "x",TokNewline,TokIdent "lookAhead",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "lookAhead",TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipMany1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany1",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "*>",TokIdent "skipMany",TokIdent "p",TokNewline,TokIdent "skipMany",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipMany",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "ts",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Core/Parser.hs ===
-- Raw Source --
-- module Parser.Core.Parser (parseExpr, runToplevelTest, runExprTest, toplevel) where
module Parser.Core.Parser (parseExpr, toplevel) where

import AST.Expr
import Control.Applicative (many, (<|>))
import Lexer.Token (Token (..))
import Lexer.Lexer (runLexer)
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (expr, letExpr)
import Parser.Expr.PatternParser
-- import Parser.Type.TypeParser

-- === 実行関数 ===

toplevel :: Parser (String, Expr)
toplevel = do
  name <- ident
  symbol "="
  body <- exprCore
  return (name, body)
{-}
parseExpr :: [Token] -> IO (Maybe Expr)
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing
-}
parseExpr :: [Token] -> Maybe (Expr, [Token])
parseExpr toks = runParser expr toks

{-}
parseExpr :: [Token] -> Maybe Expr
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> Just result
  _ -> Nothing
-}

parseToplevel :: [Token] -> IO (Maybe (String, Expr))
parseToplevel toks = case runParser toplevel toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing

{-}
-- 式のテスト
runExprTest :: ([Char], [Char]) -> IO ()
runExprTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseExpr tokens
      case result of
        Nothing -> putStrLn "  Parser error!"
        Just ast ->
          compareAST (show ast) expected

-- トップレベル定義のテスト
runToplevelTest :: ([Char], [Char]) -> IO ()
runToplevelTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseToplevel tokens
      case result of
        Nothing -> putStrLn "  Parser error!\n"
        Just (_, ast) ->
          compareAST (show ast) expected
-}

-- 共通の比較処理
compareAST actualRaw expectedRaw = do
  let normalize = filter (not . (`elem` [' ', '\n', '\t']))
      actual = normalize actualRaw
      expected = normalize expectedRaw
  if actual == expected
    then putStrLn "  O Passed\n"
    else do
      putStrLn "  X Failed!"
      putStrLn $ "     Expected: " ++ expectedRaw
      putStrLn $ "     Got:      " ++ actualRaw ++ "\n"


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Parser",TokSymbol "(",TokIdent "parseExpr",TokSymbol ",",TokIdent "toplevel",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "letExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokIdent "toplevel",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "toplevel",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseExpr",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "parseExpr",TokIdent "toks",TokSymbol "=",TokIdent "runParser",TokIdent "expr",TokIdent "toks",TokNewline,TokIdent "parseToplevel",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ")",TokNewline,TokIdent "parseToplevel",TokIdent "toks",TokSymbol "=",TokKeyword "case",TokIdent "runParser",TokIdent "toplevel",TokIdent "toks",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "result",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "|",TokIdent "null",TokIdent "rest",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "result",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "compareAST",TokIdent "actualRaw",TokIdent "expectedRaw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "normalize",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokIdent "`elem`",TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokVLBrace,TokIdent "actual",TokSymbol "=",TokIdent "normalize",TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSymbol "=",TokIdent "normalize",TokIdent "expectedRaw",TokVRBrace,TokNewline,TokKeyword "if",TokIdent "actual",TokOperator "==",TokIdent "expected",TokVLBrace,TokKeyword "then",TokIdent "putStrLn",TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "putStrLn",TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Expected: ",TokOperator "++",TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Got:      ",TokOperator "++",TokIdent "actualRaw",TokOperator "++",TokString "\n",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseExpr"
<< exportItem: next token=TokIdent "toplevel"
<< declBody: return DeclModule "Parser.Core.Parser" (Just [ExportVar "parseExpr",ExportVar "toplevel"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Core.Parser" (Just [ExportVar "parseExpr",ExportVar "toplevel"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "letExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokIdent "toplevel",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "toplevel",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseExpr",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "parseExpr",TokIdent "toks",TokSymbol "=",TokIdent "runParser",TokIdent "expr",TokIdent "toks",TokNewline,TokIdent "parseToplevel",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ")",TokNewline,TokIdent "parseToplevel",TokIdent "toks",TokSymbol "=",TokKeyword "case",TokIdent "runParser",TokIdent "toplevel",TokIdent "toks",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "result",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "|",TokIdent "null",TokIdent "rest",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "result",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "compareAST",TokIdent "actualRaw",TokIdent "expectedRaw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "normalize",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokIdent "`elem`",TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokVLBrace,TokIdent "actual",TokSymbol "=",TokIdent "normalize",TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSymbol "=",TokIdent "normalize",TokIdent "expectedRaw",TokVRBrace,TokNewline,TokKeyword "if",TokIdent "actual",TokOperator "==",TokIdent "expected",TokVLBrace,TokKeyword "then",TokIdent "putStrLn",TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "putStrLn",TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Expected: ",TokOperator "++",TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Got:      ",TokOperator "++",TokIdent "actualRaw",TokOperator "++",TokString "\n",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Core/TokenParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Core.TokenParser
  ( ident,
    int,
    keyword,
    symbol,
    tokenIs,
    parens,
    brackets,
    braces,
    bracesv,
    bracesV,
    bracesV3,
    notFollowedBy,
    (<?>),
    anyToken,
    stringLiteralExpr,
    charLiteralExpr,
    skipNewlines,
    newline,
    skipSeparators,
    name,
    operator,
    bracedBlock,
    anyToken,
    binOp,
    operatorVar,
    satisfyToken,
    symbolToken,
    operatorI,
    operatorIAsName,
    identI,
    typeIdent,
    isSymbolName,
  )
where

import AST.Expr
import Control.Applicative (empty, many, optional, (<|>))
import Data.Char (isAlpha)
import Data.Functor (void)
import qualified Data.Set as Set
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Utils.MyTrace (myTrace)

-- import Text.Megaparsec (token, (<?>))

(<?>) :: Parser a -> String -> Parser a
p <?> _ = p

identI :: Parser String
identI = ident <|> typeIdent

braces :: Parser a -> Parser a
braces p = between (symbol "{") (symbol "}") p

bracesv :: Parser a -> Parser a
bracesv p = do
  -- optional (symbol ";")
  between (token TokVLBrace) (token TokVRBrace) p

-- bracesV :: Parser a -> Parser a
-- bracesV p = between (token TokVLBrace) (token TokVRBrace) p

-- 仮想括弧
bracesV :: Parser a -> Parser a
bracesV p = try (bracesv p) <|> (braces p)

-- 括弧無しでも扱う
bracesV3 :: Parser a -> Parser a
bracesV3 p = do try (bracesv p) <|> (braces p) <|> p

-- parens :: Parser a -> Parser a
-- parens p = between (symbol "(") (symbol ")") p
parens :: Parser a -> Parser a
parens p = do
  symbol "("
  x <- p
  symbol ")"
  return x

brackets :: Parser a -> Parser a
brackets p = between (symbol "[") (symbol "]") p

ident :: Parser String
ident = tokenIs $ \case
  TokIdent s -> Just s
  _ -> Nothing

int :: Parser Int
int = do
  t <- satisfy isNumber
  case t of
    -- TokNumber n -> myTrace ("<< int: " ++ show n) >> pure n
    TokNumber n -> pure n
    -- TokNumber n -> pure n
    _ -> empty
  where
    isNumber (TokNumber _) = True
    isNumber _ = False

keyword :: String -> Parser ()
keyword kw = do
  t <- satisfy isKeyword
  case t of
    -- TokKeyword s | s == kw -> myTrace ("<< keyword: " ++ s) >> pure ()
    TokKeyword s | s == kw -> pure ()
    _ -> empty
  where
    isKeyword (TokKeyword _) = True
    isKeyword _ = False

symbol :: String -> Parser ()
symbol s = tokenIs $ \case
  TokSymbol s' | s' == s -> Just ()
  TokOperator s' | s' == s -> Just ()
  _ -> Nothing

{-}
isSymbolName :: String -> Bool
isSymbolName s = case s of
  ('(' : c : _) -> not (isAlpha c) -- 例: "(++)", "(>>=)", "(<?>)"
  _ -> False
-}

isSymbolName :: String -> Bool
isSymbolName s =
  case s of
    ('(' : _) | last s == ')' -> True -- 括弧付き演算子 (<?>)
    _ -> not (null s) && isSymbolStart (head s)

isSymbolStart :: Char -> Bool
isSymbolStart c = c `elem` "!#$%&*+./<=>?@\\^|-~:"

tokenIs :: (Token -> Maybe a) -> Parser a
tokenIs f = Parser $ \case
  (t : ts) -> case f t of
    Just a -> Just (a, ts)
    Nothing -> Nothing
  [] -> Nothing

notFollowedBy :: Parser a -> Parser ()
notFollowedBy p = Parser $ \input ->
  case runParser p input of
    Nothing -> Just ((), input) -- p が失敗 → 成功
    Just _ -> Nothing -- p が成功 → 失敗

anyToken :: Parser Token
anyToken = Parser $ \input ->
  case input of
    (t : ts) -> Just (t, ts)
    [] -> Nothing

debugPeek :: Parser ()
debugPeek = do
  t <- peekToken
  Parser $ \tokens ->
    Just ((), tokens)

peekToken :: Parser Token
peekToken = Parser $ \tokens -> case tokens of
  [] -> Nothing
  (t : _) -> Just (t, tokens)

typeIdent :: Parser String
typeIdent = satisfyMap $ \case
  TokTypeIdent s -> Just s
  _ -> Nothing

stringLiteralExpr :: Parser String
stringLiteralExpr =
  satisfyToken f
  where
    f (TokString s) = Just s
    f _ = Nothing

charLiteralExpr :: Parser Char
charLiteralExpr =
  satisfyToken f
  where
    f (TokChar s) = Just s
    f _ = Nothing

satisfyToken :: (Token -> Maybe a) -> Parser a
satisfyToken f = Parser $ \ts -> case ts of
  [] -> Nothing
  (t : ts') -> case f t of
    Just x -> Just (x, ts')
    Nothing -> Nothing

skipSeparators :: Parser ()
skipSeparators = do
  _ <- many (tokenIs isSep)
  return ()
  where
    -- isSep TokVLBrace = Just ()
    -- isSep TokVRBrace = Just ()
    isSep TokNewline = Just ()
    isSep (TokSymbol ";") = Just ()
    isSep _ = Nothing

newline :: Parser ()
newline = void (token TokNewline)

skipNewlines :: Parser ()
skipNewlines = do
  _ <- many (tokenIs (\t -> if t == TokNewline then Just () else Nothing))
  return ()

binOp :: [String] -> Parser (Expr -> Expr -> Expr)
binOp ops = tokenIs $ \case
  TokOperator op | op `elem` ops ->
    case parseBinOp op of
      Just bop -> Just (EBinOp bop)
      Nothing -> Nothing
  _ -> Nothing

parseBinOp :: String -> Maybe BinOp
parseBinOp s = case s of
  "+" -> Just Add
  "-" -> Just Sub
  "*" -> Just Mul
  "/" -> Just Div
  "==" -> Just Eq
  "!=" -> Just Neq
  "<" -> Just Lt
  ">" -> Just Gt
  "<=" -> Just Le
  ">=" -> Just Ge
  "&&" -> Just And
  "||" -> Just Or
  "++" -> Just Concat
  ":" -> Just Cons
  _ -> Nothing

operator :: Parser String
operator = choice (map (\s -> symbol s >> return s) allOps)
  where
    allOps =
      [ "==",
        "/=",
        ">=",
        "<=",
        "+",
        "-",
        "*",
        "/",
        ">",
        "<",
        ":"
      ]

operatorVar :: Parser Expr
operatorVar = do
  op <- satisfyToken isOp
  return (EVar op)
  where
    isOp (TokOperator s) = Just s
    isOp _ = Nothing

{-}
operatorI :: Parser Name
operatorI = satisfyToken isOp
  where
    isOp (TokOperator s) = Just s
    isOp _ = Nothing
-}
operatorI :: Parser Name
operatorI = satisfyToken isOp
  where
    isOp (TokOperator s)
      | s `elem` ["$", "++", "<?>", ">>="] = Just s
      | otherwise = Nothing
    isOp _ = Nothing

operatorIAsName :: Parser Name
operatorIAsName = do
  op <- operatorI
  return $ "(" ++ op ++ ")"

{-}
operatorIAsName :: Parser Name
operatorIAsName = do
  op <-
    try (parens operatorI) -- 括弧付き演算子（例: (<?>), (++)
      <|> operatorI -- 括弧なし演算子（例: <?>, ++）
  myTrace ("<< operatorIAsName: " ++ show op)
  return op
-}

{-}
operator :: Parser String
operator = do
  symbol "("
  op <- operatorTok
  symbol ")"
  return (op)
-}

-- 関数名や演算子名をパースする共通パーサー
-- 例: "f" や "==" や "(==)"
name :: Parser String
name = try parenOp <|> ident <|> symbolOp

-- 括弧付きオペレータ: (==)
parenOp :: Parser String
parenOp = do
  symbol "("
  op <- symbolOp
  symbol ")"
  return op

-- 括弧なしのオペレータ: ==
symbolOp :: Parser String
symbolOp = do
  tok <- satisfy isSymbol
  case tok of
    TokSymbol s -> return s
    _ -> empty -- ここには来ないはずだけど、安全のため

-- 文字列がオペレータかどうか
isSymbol :: Token -> Bool
isSymbol (TokSymbol _) = True
isSymbol _ = False

bracedBlock :: Parser a -> Parser [a]
bracedBlock p = do
  symbol "{"
  go 1 []
  where
    go 0 acc = return (reverse acc)
    go n acc = do
      t <- lookAhead anyToken
      case t of
        TokSymbol "{" -> symbol "{" >> go (n + 1) acc
        TokSymbol "}" -> symbol "}" >> go (n - 1) acc
        _ -> do
          x <- p
          go n (x : acc)

symbolToken :: Token -> Parser Token
symbolToken tok = satisfyToken match
  where
    match t
      | t == tok = Just t
      | otherwise = Nothing


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokVLBrace,TokSymbol "(",TokIdent "ident",TokSymbol ",",TokIdent "int",TokSymbol ",",TokIdent "keyword",TokSymbol ",",TokIdent "symbol",TokSymbol ",",TokIdent "tokenIs",TokSymbol ",",TokIdent "parens",TokSymbol ",",TokIdent "brackets",TokSymbol ",",TokIdent "braces",TokSymbol ",",TokIdent "bracesv",TokSymbol ",",TokIdent "bracesV",TokSymbol ",",TokIdent "bracesV3",TokSymbol ",",TokIdent "notFollowedBy",TokSymbol ",",TokSymbol "(",TokOperator "<?>",TokSymbol ")",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "stringLiteralExpr",TokSymbol ",",TokIdent "charLiteralExpr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokIdent "newline",TokSymbol ",",TokIdent "skipSeparators",TokSymbol ",",TokIdent "name",TokSymbol ",",TokIdent "operator",TokSymbol ",",TokIdent "bracedBlock",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "binOp",TokSymbol ",",TokIdent "operatorVar",TokSymbol ",",TokIdent "satisfyToken",TokSymbol ",",TokIdent "symbolToken",TokSymbol ",",TokIdent "operatorI",TokSymbol ",",TokIdent "operatorIAsName",TokSymbol ",",TokIdent "identI",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "isSymbolName",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isAlpha",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokKeyword "as",TokTypeIdent "Set",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokSymbol "(",TokOperator "<?>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "p",TokOperator "<?>",TokIdent "_",TokSymbol "=",TokIdent "p",TokNewline,TokIdent "identI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "identI",TokSymbol "=",TokIdent "ident",TokOperator "<|>",TokIdent "typeIdent",TokNewline,TokIdent "braces",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "braces",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesv",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesv",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "between",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokIdent "p",TokVRBrace,TokNewline,TokIdent "bracesV",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV",TokIdent "p",TokSymbol "=",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokNewline,TokIdent "bracesV3",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV3",TokIdent "p",TokSymbol "=",TokKeyword "do",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokIdent "p",TokNewline,TokIdent "parens",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parens",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "brackets",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "brackets",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "ident",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "ident",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "int",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Int",TokNewline,TokIdent "int",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokNumber",TokIdent "n",TokArrow,TokIdent "pure",TokIdent "n",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isNumber",TokSymbol "(",TokTypeIdent "TokNumber",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "keyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "keyword",TokIdent "kw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokKeyword",TokIdent "s",TokSymbol "|",TokIdent "s",TokOperator "==",TokIdent "kw",TokArrow,TokIdent "pure",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isKeyword",TokSymbol "(",TokTypeIdent "TokKeyword",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbol",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "symbol",TokIdent "s",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokOperator "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokTypeIdent "TokOperator",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokOperator "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isSymbolName",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbolName",TokIdent "s",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '(',TokOperator ":",TokIdent "_",TokSymbol ")",TokSymbol "|",TokIdent "last",TokIdent "s",TokOperator "==",TokChar ')',TokArrow,TokTypeIdent "True",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "not",TokSymbol "(",TokIdent "null",TokIdent "s",TokSymbol ")",TokSymbol "&",TokSymbol "&",TokIdent "isSymbolStart",TokSymbol "(",TokIdent "head",TokIdent "s",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbolStart",TokSymbol "::",TokTypeIdent "Char",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbolStart",TokIdent "c",TokSymbol "=",TokIdent "c",TokIdent "`elem`",TokString "!#$%&*+./<=>?@\\^|-~:",TokNewline,TokIdent "tokenIs",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "tokenIs",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokLambdaCase,TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "a",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "notFollowedBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "notFollowedBy",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "anyToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "input",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "debugPeek",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "debugPeek",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "peekToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSymbol "=",TokIdent "satisfyMap",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokTypeIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "stringLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "charLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Char",TokNewline,TokIdent "charLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokChar",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfyToken",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyToken",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts'",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipSeparators",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipSeparators",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "isSep",TokTypeIdent "TokNewline",TokSymbol "=",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokOperator "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "binOp",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokIdent "ops",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokOperator",TokIdent "op",TokSymbol "|",TokIdent "op",TokIdent "`elem`",TokIdent "ops",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "parseBinOp",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "bop",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "parseBinOp",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokIdent "s",TokSymbol "=",TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokString "+",TokArrow,TokTypeIdent "Just",TokTypeIdent "Add",TokSymbol ";",TokString "-",TokArrow,TokTypeIdent "Just",TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokArrow,TokTypeIdent "Just",TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokArrow,TokTypeIdent "Just",TokTypeIdent "Div",TokSymbol ";",TokString "==",TokArrow,TokTypeIdent "Just",TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokArrow,TokTypeIdent "Just",TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokArrow,TokTypeIdent "Just",TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokArrow,TokTypeIdent "Just",TokTypeIdent "And",TokSymbol ";",TokString "||",TokArrow,TokTypeIdent "Just",TokTypeIdent "Or",TokSymbol ";",TokString "++",TokArrow,TokTypeIdent "Just",TokTypeIdent "Concat",TokSymbol ";",TokString ":",TokArrow,TokTypeIdent "Just",TokTypeIdent "Cons",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "operator",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "operator",TokSymbol "=",TokIdent "choice",TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">>",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "allOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokString "==",TokSymbol ",",TokVLBrace,TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol ",",TokSymbol ";",TokString ":",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "operatorVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "satisfyToken",TokIdent "isOp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "isOp",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Name",TokNewline,TokIdent "operatorI",TokSymbol "=",TokIdent "satisfyToken",TokIdent "isOp",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "s",TokIdent "`elem`",TokSymbol "[",TokString "$",TokSymbol ",",TokString "++",TokSymbol ",",TokString "<?>",TokSymbol ",",TokString ">>=",TokSymbol "]",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isOp",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorIAsName",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Name",TokNewline,TokIdent "operatorIAsName",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokNewline,TokIdent "name",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "name",TokSymbol "=",TokIdent "try",TokIdent "parenOp",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "symbolOp",TokNewline,TokIdent "parenOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "op",TokVRBrace,TokNewline,TokIdent "symbolOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tok",TokSymbol "<-",TokIdent "satisfy",TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokIdent "tok",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s",TokArrow,TokKeyword "return",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbol",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSymbol "(",TokTypeIdent "TokSymbol",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "bracedBlock",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "go",TokNumber 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "go",TokNumber 0,TokIdent "acc",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokIdent "n",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokIdent "symbol",TokString "{",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokIdent "symbol",TokString "}",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "go",TokIdent "n",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbolToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "symbolToken",TokIdent "tok",TokSymbol "=",TokIdent "satisfyToken",TokIdent "match",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "match",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokIdent "tok",TokSymbol "=",TokTypeIdent "Just",TokIdent "t",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "ident"
<< exportItem: next token=TokIdent "int"
<< exportItem: next token=TokIdent "keyword"
<< exportItem: next token=TokIdent "symbol"
<< exportItem: next token=TokIdent "tokenIs"
<< exportItem: next token=TokIdent "parens"
<< exportItem: next token=TokIdent "brackets"
<< exportItem: next token=TokIdent "braces"
<< exportItem: next token=TokIdent "bracesv"
<< exportItem: next token=TokIdent "bracesV"
<< exportItem: next token=TokIdent "bracesV3"
<< exportItem: next token=TokIdent "notFollowedBy"
<< exportItem: next token=TokSymbol "("
<< exportItem: next token=TokIdent "anyToken"
<< exportItem: next token=TokIdent "stringLiteralExpr"
<< exportItem: next token=TokIdent "charLiteralExpr"
<< exportItem: next token=TokIdent "skipNewlines"
<< exportItem: next token=TokIdent "newline"
<< exportItem: next token=TokIdent "skipSeparators"
<< exportItem: next token=TokIdent "name"
<< exportItem: next token=TokIdent "operator"
<< exportItem: next token=TokIdent "bracedBlock"
<< exportItem: next token=TokIdent "anyToken"
<< exportItem: next token=TokIdent "binOp"
<< exportItem: next token=TokIdent "operatorVar"
<< exportItem: next token=TokIdent "satisfyToken"
<< exportItem: next token=TokIdent "symbolToken"
<< exportItem: next token=TokIdent "operatorI"
<< exportItem: next token=TokIdent "operatorIAsName"
<< exportItem: next token=TokIdent "identI"
<< exportItem: next token=TokIdent "typeIdent"
<< exportItem: next token=TokIdent "isSymbolName"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Core.TokenParser" (Just [ExportVar "ident",ExportVar "int",ExportVar "keyword",ExportVar "symbol",ExportVar "tokenIs",ExportVar "parens",ExportVar "brackets",ExportVar "braces",ExportVar "bracesv",ExportVar "bracesV",ExportVar "bracesV3",ExportVar "notFollowedBy",ExportVar "(<?>)",ExportVar "anyToken",ExportVar "stringLiteralExpr",ExportVar "charLiteralExpr",ExportVar "skipNewlines",ExportVar "newline",ExportVar "skipSeparators",ExportVar "name",ExportVar "operator",ExportVar "bracedBlock",ExportVar "anyToken",ExportVar "binOp",ExportVar "operatorVar",ExportVar "satisfyToken",ExportVar "symbolToken",ExportVar "operatorI",ExportVar "operatorIAsName",ExportVar "identI",ExportVar "typeIdent",ExportVar "isSymbolName"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Core.TokenParser" (Just [ExportVar "ident",ExportVar "int",ExportVar "keyword",ExportVar "symbol",ExportVar "tokenIs",ExportVar "parens",ExportVar "brackets",ExportVar "braces",ExportVar "bracesv",ExportVar "bracesV",ExportVar "bracesV3",ExportVar "notFollowedBy",ExportVar "(<?>)",ExportVar "anyToken",ExportVar "stringLiteralExpr",ExportVar "charLiteralExpr",ExportVar "skipNewlines",ExportVar "newline",ExportVar "skipSeparators",ExportVar "name",ExportVar "operator",ExportVar "bracedBlock",ExportVar "anyToken",ExportVar "binOp",ExportVar "operatorVar",ExportVar "satisfyToken",ExportVar "symbolToken",ExportVar "operatorI",ExportVar "operatorIAsName",ExportVar "identI",ExportVar "typeIdent",ExportVar "isSymbolName"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isAlpha",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokKeyword "as",TokTypeIdent "Set",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokSymbol "(",TokOperator "<?>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "p",TokOperator "<?>",TokIdent "_",TokSymbol "=",TokIdent "p",TokNewline,TokIdent "identI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "identI",TokSymbol "=",TokIdent "ident",TokOperator "<|>",TokIdent "typeIdent",TokNewline,TokIdent "braces",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "braces",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesv",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesv",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "between",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokIdent "p",TokVRBrace,TokNewline,TokIdent "bracesV",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV",TokIdent "p",TokSymbol "=",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokNewline,TokIdent "bracesV3",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV3",TokIdent "p",TokSymbol "=",TokKeyword "do",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokIdent "p",TokNewline,TokIdent "parens",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parens",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "brackets",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "brackets",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "ident",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "ident",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "int",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Int",TokNewline,TokIdent "int",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokNumber",TokIdent "n",TokArrow,TokIdent "pure",TokIdent "n",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isNumber",TokSymbol "(",TokTypeIdent "TokNumber",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "keyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "keyword",TokIdent "kw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokKeyword",TokIdent "s",TokSymbol "|",TokIdent "s",TokOperator "==",TokIdent "kw",TokArrow,TokIdent "pure",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isKeyword",TokSymbol "(",TokTypeIdent "TokKeyword",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbol",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "symbol",TokIdent "s",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokOperator "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokTypeIdent "TokOperator",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokOperator "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isSymbolName",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbolName",TokIdent "s",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '(',TokOperator ":",TokIdent "_",TokSymbol ")",TokSymbol "|",TokIdent "last",TokIdent "s",TokOperator "==",TokChar ')',TokArrow,TokTypeIdent "True",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "not",TokSymbol "(",TokIdent "null",TokIdent "s",TokSymbol ")",TokSymbol "&",TokSymbol "&",TokIdent "isSymbolStart",TokSymbol "(",TokIdent "head",TokIdent "s",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbolStart",TokSymbol "::",TokTypeIdent "Char",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbolStart",TokIdent "c",TokSymbol "=",TokIdent "c",TokIdent "`elem`",TokString "!#$%&*+./<=>?@\\^|-~:",TokNewline,TokIdent "tokenIs",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "tokenIs",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokLambdaCase,TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "a",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "notFollowedBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "notFollowedBy",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "anyToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "input",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "debugPeek",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "debugPeek",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "peekToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSymbol "=",TokIdent "satisfyMap",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokTypeIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "stringLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "charLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Char",TokNewline,TokIdent "charLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokChar",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfyToken",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyToken",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts'",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipSeparators",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipSeparators",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "isSep",TokTypeIdent "TokNewline",TokSymbol "=",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "isSep",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokOperator "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "binOp",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokIdent "ops",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokOperator",TokIdent "op",TokSymbol "|",TokIdent "op",TokIdent "`elem`",TokIdent "ops",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "parseBinOp",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "bop",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "parseBinOp",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokIdent "s",TokSymbol "=",TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokString "+",TokArrow,TokTypeIdent "Just",TokTypeIdent "Add",TokSymbol ";",TokString "-",TokArrow,TokTypeIdent "Just",TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokArrow,TokTypeIdent "Just",TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokArrow,TokTypeIdent "Just",TokTypeIdent "Div",TokSymbol ";",TokString "==",TokArrow,TokTypeIdent "Just",TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokArrow,TokTypeIdent "Just",TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokArrow,TokTypeIdent "Just",TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokArrow,TokTypeIdent "Just",TokTypeIdent "And",TokSymbol ";",TokString "||",TokArrow,TokTypeIdent "Just",TokTypeIdent "Or",TokSymbol ";",TokString "++",TokArrow,TokTypeIdent "Just",TokTypeIdent "Concat",TokSymbol ";",TokString ":",TokArrow,TokTypeIdent "Just",TokTypeIdent "Cons",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "operator",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "operator",TokSymbol "=",TokIdent "choice",TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">>",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "allOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokString "==",TokSymbol ",",TokVLBrace,TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol ",",TokSymbol ";",TokString ":",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "operatorVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "satisfyToken",TokIdent "isOp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "isOp",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Name",TokNewline,TokIdent "operatorI",TokSymbol "=",TokIdent "satisfyToken",TokIdent "isOp",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "s",TokIdent "`elem`",TokSymbol "[",TokString "$",TokSymbol ",",TokString "++",TokSymbol ",",TokString "<?>",TokSymbol ",",TokString ">>=",TokSymbol "]",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isOp",TokIdent "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorIAsName",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Name",TokNewline,TokIdent "operatorIAsName",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokString "(",TokOperator "++",TokIdent "op",TokOperator "++",TokString ")",TokVRBrace,TokNewline,TokIdent "name",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "name",TokSymbol "=",TokIdent "try",TokIdent "parenOp",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "symbolOp",TokNewline,TokIdent "parenOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "op",TokVRBrace,TokNewline,TokIdent "symbolOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tok",TokSymbol "<-",TokIdent "satisfy",TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokIdent "tok",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s",TokArrow,TokKeyword "return",TokIdent "s",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbol",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSymbol "(",TokTypeIdent "TokSymbol",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "bracedBlock",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "go",TokNumber 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "go",TokNumber 0,TokIdent "acc",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokIdent "n",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokIdent "symbol",TokString "{",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokIdent "symbol",TokString "}",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "go",TokIdent "n",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbolToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "symbolToken",TokIdent "tok",TokSymbol "=",TokIdent "satisfyToken",TokIdent "match",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "match",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokIdent "tok",TokSymbol "=",TokTypeIdent "Just",TokIdent "t",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/CaseParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.CaseParserCore (caseExprCore, lambdaCaseExpr) where

import AST.Expr
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

caseExprCore :: Parser Expr -> Parser Expr
caseExprCore expr = do
  keyword "case"
  scrut <- expr
  keyword "of"
  bracesV $ do
    -- skipSeparators
    alts <-
      (sepBy1 (caseAlt expr) caseSep)
    --  <|> sepBy1 (caseAlt expr) caseSep
    return (ECase scrut alts)

lambdaCaseExpr :: Parser Expr -> Parser Expr
lambdaCaseExpr expr = do
  myTrace ("<< lambdaCaseExpr")
  token TokLambdaCase
  bracesV $ do
    t <- lookAhead anyToken
    myTrace ("<< lambdaCaseExpr: next token " ++ show t)
    -- token $ TokKeyword "of"
    -- branches <- sepBy1 (caseBranch expr) (symbol ";")
    branches <- sepBy1 (caseAlt expr) (symbol ";")
    return $ ELambdaCase branches

caseBranch :: Parser Expr -> Parser (Pattern, Expr)
caseBranch expr = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< caseBranch: next token " ++ show t)
  pat <- pattern -- pPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< caseBranch:2 next token " ++ show t ++ " " ++ show pat)
  token TokArrow
  body <- expr -- NoInfix
  -- t <- lookAhead anyToken
  -- myTrace ("<< caseBranch:2 next token " ++ show t ++ " " ++ show body)
  return (pat, body)

{-}
caseExprCore :: Parser Expr -> Parser Expr
caseExprCore expr = do
  keyword "case"
  scrut <- expr
  keyword "of"
  bracesV $ do
    -- skipSeparators
    alts <-
      (sepBy1 (caseAlt expr) caseSep)
    --  <|> sepBy1 (caseAlt expr) caseSep
    return (ECase scrut alts)
-}

caseSep :: Parser ()
caseSep =
  symbol ";"
    <|> void (token TokNewline) -- newline
    <|> lookAhead patternStart

newline :: Parser ()
newline = void (token TokNewline)

caseAlt :: Parser Expr -> Parser CaseAlt
caseAlt expr = do
  -- skipNewlines
  pat <- pattern
  t <- lookAhead anyToken
  myTrace ("<< caseAlt: next token " ++ show t ++ " " ++ show pat)
  guards <- many (guardExpr expr)
  t <- lookAhead anyToken
  myTrace ("<< caseAlt:2 next token " ++ show t ++ " " ++ show guards)
  -- guards <- many (caseGuard expr)
  case guards of
    [] -> do
      token TokArrow
      body <- expr
      return (CaseAlt pat body)
    _ ->
      return (CaseAltGuard pat guards)

guardExpr :: Parser Expr -> Parser (Expr, Expr)
guardExpr expr = do
  symbol "|"
  cond <- expr
  token TokArrow
  body <- expr
  skipSeparators
  return (cond, body)

caseGuard :: Parser Expr -> Parser (Expr, Expr)
caseGuard expr = do
  -- optional (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< caseGuard next token: " ++ show t)
  symbol "|"
  cond <- expr
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  -- token TokArrow
  body <- expr
  -- optional (token TokNewline)
  return (cond, body)

caseAltSimple :: Parser Expr -> Parser CaseAlt
caseAltSimple expr = do
  t <- lookAhead anyToken
  myTrace ("<< caseAltSimple next token: " ++ show t)
  pat <- pattern
  token TokArrow
  body <- expr
  return (CaseAlt pat body)

unguarded :: Pattern -> Parser Expr -> Parser CaseAlt
unguarded pat expr = do
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- expr
  return (CaseAlt pat body)

guarded :: Pattern -> Parser Expr -> Parser CaseAlt
guarded pat expr = do
  guards <- many1 (try (guardExpr expr))
  return (CaseAltGuard pat guards)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSymbol "(",TokIdent "caseExprCore",TokSymbol ",",TokIdent "lambdaCaseExpr",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "caseExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "caseExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "case",TokSymbol ";",TokIdent "scrut",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "of",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "alts",TokSymbol "<-",TokVLBrace,TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "lambdaCaseExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "lambdaCaseExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< lambdaCaseExpr",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokLambdaCase",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< lambdaCaseExpr: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "branches",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ELambdaCase",TokIdent "branches",TokVRBrace,TokVRBrace,TokNewline,TokIdent "caseBranch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseBranch",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "caseSep",TokSymbol "=",TokVLBrace,TokIdent "symbol",TokString ";",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "lookAhead",TokIdent "patternStart",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "caseAlt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAlt: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "pat",TokSymbol ")",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAlt:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "guards",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokIdent "guards",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseGuard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseAltSimple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unguarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "many1",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "caseExprCore"
<< exportItem: next token=TokIdent "lambdaCaseExpr"
<< declBody: return DeclModule "Parser.Expr.CaseParserCore" (Just [ExportVar "caseExprCore",ExportVar "lambdaCaseExpr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Expr.CaseParserCore" (Just [ExportVar "caseExprCore",ExportVar "lambdaCaseExpr"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "caseExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "caseExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "case",TokSymbol ";",TokIdent "scrut",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "of",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "alts",TokSymbol "<-",TokVLBrace,TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "lambdaCaseExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "lambdaCaseExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< lambdaCaseExpr",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokLambdaCase",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< lambdaCaseExpr: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "branches",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ELambdaCase",TokIdent "branches",TokVRBrace,TokVRBrace,TokNewline,TokIdent "caseBranch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseBranch",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "caseSep",TokSymbol "=",TokVLBrace,TokIdent "symbol",TokString ";",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "lookAhead",TokIdent "patternStart",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "caseAlt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAlt: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "pat",TokSymbol ")",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAlt:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "guards",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokIdent "guards",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseGuard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseAltSimple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unguarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "many1",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/DoParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.DoParserCore (doExprCore) where

import AST.Expr
import Control.Applicative (empty, many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

doExprCore :: Parser Expr -> Parser Expr
doExprCore expr = do
  keyword "do"
  bracesV $ do
    skipSeparators
    stmts <- doBlock expr
    -- many (token TokNewline)
    return (EDo stmts)

doBlock :: Parser Expr -> Parser [Stmt]
doBlock expr = do
  sepBy (doStmt expr) doSemi

doStmt :: Parser Expr -> Parser Stmt
doStmt expr = do
  many (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< doStmt next token: " ++ show t)
  try (bindStmt expr)
    <|> try (letStmt expr)
    <|> ExprStmt <$> expr

bindStmt :: Parser Expr -> Parser Stmt
bindStmt expr = do
  pat <- pattern
  symbol "<-"
  e <- expr
  return (Bind pat e)

letStmt :: Parser Expr -> Parser Stmt
letStmt expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ";")
  t <- lookAhead anyToken
  myTrace ("<< letStmt:binding next token: " ++ show t)
  case t of
    TokKeyword "in" -> empty
    _ -> return (LetStmt binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)

doSemi :: Parser ()
doSemi = do
  -- optional (token TokNewline)
  symbol ";"


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "doExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "doExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "do",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "stmts",TokSymbol "<-",TokIdent "doBlock",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "doBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sepBy",TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokIdent "doSemi",TokVRBrace,TokNewline,TokIdent "doStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokTypeIdent "ExprStmt",TokOperator "<$>",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "in",TokArrow,TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "doSemi",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "doSemi",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "symbol",TokString ";",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "doExprCore"
<< declBody: return DeclModule "Parser.Expr.DoParserCore" (Just [ExportVar "doExprCore"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Expr.DoParserCore" (Just [ExportVar "doExprCore"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "doExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "doExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "do",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "stmts",TokSymbol "<-",TokIdent "doBlock",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "doBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sepBy",TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokIdent "doSemi",TokVRBrace,TokNewline,TokIdent "doStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokTypeIdent "ExprStmt",TokOperator "<$>",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "in",TokArrow,TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "doSemi",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "doSemi",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "symbol",TokString ";",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprCore
  ( exprCore,
    exprLevel1Core,
    exprLevel2Core,
    exprLevel3Core,
    appExprCore,
    atomCore,
    atomBaseCore,
    parenExprCore,
    tupleExprCore,
    oPsectionCore,
    pRecordExpr,
    lambdaExpr,
  )
where

import AST.Expr
import AST.Expr (BinOp (..), Expr (..))
import Control.Applicative (empty, many, (<|>))
import Control.Monad (guard)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.PatternParser (pattern)
import Parser.SQL.SQLParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace

pRecordExpr :: Parser Expr
pRecordExpr = do
  symbol "{"
  fields <- sepBy1 field (symbol ",")
  symbol "}"
  return (ERecord fields)

field :: Parser (String, Expr)
field = do
  name <- ident
  symbol "="
  value <- exprCore
  return (name, value)

-- ============================================
--  lambdaExpr（ExprCore に戻す）
-- ============================================

lambdaExpr :: Parser Expr
lambdaExpr = do
  symbol "\\"
  arg <- pattern
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- exprCore
  return (ELam arg body)

-- ============================================
--  exprCore（純粋な式パーサー）
-- ============================================

exprCore :: Parser Expr
exprCore = do
  t <- lookAhead anyToken
  myTrace ("<< exprCore next token: " ++ show t)
  -- guard (t /= TokKeyword "let")
  try lambdaExpr
    -- <|> void (token TokEllipsis >> return EPlaceholder)
    <|> try binOpExprCore
    <|> try parseSQL

-- <|> exprLevel1Core

-- ===== 演算子階層 =====

binOpExprCore :: Parser Expr
binOpExprCore = exprCmpCore

exprCmpCore :: Parser Expr
exprCmpCore = chainl1 exprLevel1Core (binOp [">", "<", ">=", "<=", "==", "/="])

exprLevel1Core :: Parser Expr
exprLevel1Core = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< exprLevel1Core next token: " ++ show t)
  chainl1 exprLevel2Core (binOp ["+", "-", "++", ":"])

exprLevel2Core :: Parser Expr
exprLevel2Core = chainl1 exprLevel3Core (binOp ["*", "/"])

exprLevel3Core :: Parser Expr
exprLevel3Core = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< exprLevel3Core next token: " ++ show t)
  try lambdaExpr
    <|> appExprCore

-- ============================================
--  関数適用
-- ============================================

appExprCore :: Parser Expr
appExprCore = do
  f <- atomCore
  args <- many atomCore
  return (foldl EApp f args)

-- ============================================
--  atom
-- ============================================

atomCore :: Parser Expr
atomCore =
  parens parenExprCore
    <|> atomBaseCore

parenExprCore :: Parser Expr
parenExprCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< parenExprCore next token: " ++ show t)
  try oPsectionCore
    <|> try tupleExprCore
    <|> exprCore

tupleExprCore :: Parser Expr
tupleExprCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< tupleExprCore next token: " ++ show t)
  e1 <- exprCore
  symbol ","
  es <- exprCore `sepBy1` symbol ","
  return (ETuple (e1 : es))

oPsectionCore :: Parser Expr
oPsectionCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< oPsectionCore next token: " ++ show t)
  try (EOpSectionL <$> operator <*> exprCore)
    <|> (EOpSectionR <$> exprCore <*> operator)

atomBaseCore :: Parser Expr
atomBaseCore = do
  t <- lookAhead anyToken
  myTrace ("<< atomBaseCore next token: " ++ show t)
  case t of
    TokOperator "$" -> empty
    -- TokSymbol ";" -> empty
    _ ->
      lambdaExpr
        <|> EVar <$> ident
        <|> EInt <$> int
        <|> tunitExpr
        <|> EVarType <$> typeIdent
        <|> (ellipsis >> return EPlaceholder)
        <|> elistExpr
        <|> EString <$> stringLiteralExpr
        <|> EChar <$> charLiteralExpr
        <|> pRecordExpr
        <|> operatorVar
        <|> emptyListExpr

tunitExpr :: Parser Expr
tunitExpr = do
  symbol "("
  symbol ")"
  return (EUnit)

elistExpr :: Parser Expr
elistExpr = do
  symbol "["
  elems <- exprCore `sepBy` symbol ","
  symbol "]"
  return (EList elems)

ellipsis :: Parser ()
ellipsis = tokenIs (\t -> if t == TokEllipsis then Just () else Nothing)

emptyListExpr :: Parser Expr
emptyListExpr = do
  symbol "["
  symbol "]"
  return (EList [])


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokVLBrace,TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprLevel1Core",TokSymbol ",",TokIdent "exprLevel2Core",TokSymbol ",",TokIdent "exprLevel3Core",TokSymbol ",",TokIdent "appExprCore",TokSymbol ",",TokIdent "atomCore",TokSymbol ",",TokIdent "atomBaseCore",TokSymbol ",",TokIdent "parenExprCore",TokSymbol ",",TokIdent "tupleExprCore",TokSymbol ",",TokIdent "oPsectionCore",TokSymbol ",",TokIdent "pRecordExpr",TokSymbol ",",TokIdent "lambdaExpr",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "pRecordExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pRecordExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "fields",TokSymbol "<-",TokIdent "sepBy1",TokIdent "field",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERecord",TokIdent "fields",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "field",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "field",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "value",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "value",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "lambdaExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "lambdaExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "\\",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "parseSQL",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binOpExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSymbol "=",TokIdent "exprCmpCore",TokNewline,TokIdent "exprCmpCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel1Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel1Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "chainl1",TokIdent "exprLevel2Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol ",",TokString ":",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprLevel2Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel3Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel3Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokIdent "appExprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "appExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "atomCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSymbol "=",TokVLBrace,TokIdent "parens",TokIdent "parenExprCore",TokVLBrace,TokOperator "<|>",TokIdent "atomBaseCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parenExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "oPsectionCore",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "tupleExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tupleExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "es",TokSymbol "<-",TokIdent "exprCore",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokOperator ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "oPsectionCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<$>",TokIdent "operator",TokOperator "<*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<$>",TokIdent "exprCore",TokOperator "<*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "atomBaseCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokOperator",TokString "$",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokVLBrace,TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokTypeIdent "EVar",TokOperator "<$>",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EInt",TokOperator "<$>",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "tunitExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EVarType",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "ellipsis",TokOperator ">>",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "elistExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EChar",TokOperator "<$>",TokIdent "charLiteralExpr",TokSymbol ";",TokOperator "<|>",TokIdent "pRecordExpr",TokSymbol ";",TokOperator "<|>",TokIdent "operatorVar",TokSymbol ";",TokOperator "<|>",TokIdent "emptyListExpr",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "tunitExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tunitExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EUnit",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "elistExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "elistExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "elems",TokSymbol "<-",TokIdent "exprCore",TokIdent "`sepBy`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ellipsis",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "ellipsis",TokSymbol "=",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokOperator "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "emptyListExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "emptyListExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "exprCore"
<< exportItem: next token=TokIdent "exprLevel1Core"
<< exportItem: next token=TokIdent "exprLevel2Core"
<< exportItem: next token=TokIdent "exprLevel3Core"
<< exportItem: next token=TokIdent "appExprCore"
<< exportItem: next token=TokIdent "atomCore"
<< exportItem: next token=TokIdent "atomBaseCore"
<< exportItem: next token=TokIdent "parenExprCore"
<< exportItem: next token=TokIdent "tupleExprCore"
<< exportItem: next token=TokIdent "oPsectionCore"
<< exportItem: next token=TokIdent "pRecordExpr"
<< exportItem: next token=TokIdent "lambdaExpr"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprCore" (Just [ExportVar "exprCore",ExportVar "exprLevel1Core",ExportVar "exprLevel2Core",ExportVar "exprLevel3Core",ExportVar "appExprCore",ExportVar "atomCore",ExportVar "atomBaseCore",ExportVar "parenExprCore",ExportVar "tupleExprCore",ExportVar "oPsectionCore",ExportVar "pRecordExpr",ExportVar "lambdaExpr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Expr.ExprCore" (Just [ExportVar "exprCore",ExportVar "exprLevel1Core",ExportVar "exprLevel2Core",ExportVar "exprLevel3Core",ExportVar "appExprCore",ExportVar "atomCore",ExportVar "atomBaseCore",ExportVar "parenExprCore",ExportVar "tupleExprCore",ExportVar "oPsectionCore",ExportVar "pRecordExpr",ExportVar "lambdaExpr"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "pRecordExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pRecordExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "fields",TokSymbol "<-",TokIdent "sepBy1",TokIdent "field",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERecord",TokIdent "fields",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "field",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "field",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "value",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "value",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "lambdaExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "lambdaExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "\\",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokLambdaCase,TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "parseSQL",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binOpExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSymbol "=",TokIdent "exprCmpCore",TokNewline,TokIdent "exprCmpCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel1Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel1Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "chainl1",TokIdent "exprLevel2Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol ",",TokString ":",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprLevel2Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel3Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel3Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokIdent "appExprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "appExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "atomCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSymbol "=",TokVLBrace,TokIdent "parens",TokIdent "parenExprCore",TokVLBrace,TokOperator "<|>",TokIdent "atomBaseCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parenExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "oPsectionCore",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "tupleExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tupleExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "es",TokSymbol "<-",TokIdent "exprCore",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokOperator ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "oPsectionCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<$>",TokIdent "operator",TokOperator "<*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<$>",TokIdent "exprCore",TokOperator "<*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "atomBaseCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokOperator",TokString "$",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokVLBrace,TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokTypeIdent "EVar",TokOperator "<$>",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EInt",TokOperator "<$>",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "tunitExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EVarType",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "ellipsis",TokOperator ">>",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "elistExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EChar",TokOperator "<$>",TokIdent "charLiteralExpr",TokSymbol ";",TokOperator "<|>",TokIdent "pRecordExpr",TokSymbol ";",TokOperator "<|>",TokIdent "operatorVar",TokSymbol ";",TokOperator "<|>",TokIdent "emptyListExpr",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "tunitExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tunitExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EUnit",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "elistExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "elistExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "elems",TokSymbol "<-",TokIdent "exprCore",TokIdent "`sepBy`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ellipsis",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "ellipsis",TokSymbol "=",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokOperator "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokSymbol ")",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "emptyListExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "emptyListExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprExtensions.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprExtensions
  ( expr,
    exprTop,
    exprSeq,
    exprSep,
    letExpr,
    ifExpr,
    returnExpr,
    forExpr,
    postfix,
    skipNewlines,
  )
where

-- import Expr.CaseParserCore (caseExpr)

-- import Expr.DoParserCore (doExpr)

-- import Expr.ListParserCore (listExpr)

import AST.Expr
-- import AST.Decl
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
-- (keyword) -- , whereClause)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.CaseParserCore (caseExprCore, lambdaCaseExpr)
import Parser.Expr.DoParserCore (doExprCore)
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ListParserCore (listExprCore)
import Parser.Expr.PatternParser (pPattern, pattern)
import Parser.SQL.SQLParser
import Utils.MyTrace

expr :: Parser Expr
expr = infixExpr

infixExpr :: Parser Expr
infixExpr = chainl1 exprTerm infixOp

exprTerm :: Parser Expr
exprTerm = do
  e <- exprDispatch
  postfix e

infixOp :: Parser (Expr -> Expr -> Expr)
infixOp = do
  t <- lookAhead anyToken
  myTrace ("<< infixOp: next token " ++ show t)
  op <- operatorI
  myTrace ("<< infixOp: " ++ show op)
  return (\a b -> EApp (EApp (EVar op) a) b)

{-}
expr :: Parser Expr
expr = do
  e <- exprDispatch
  postfix e
-}
-- すべての構文の入口
exprDispatch :: Parser Expr
exprDispatch = do
  t <- lookAhead anyToken
  myTrace ("<< expr dispatch: " ++ show t)
  case t of
    TokKeyword "do" -> doExprCore expr
    TokKeyword "case" -> caseExprCore expr
    -- TokKeyword "let" -> (try letExpr <|> pLetExpr)
    TokKeyword "let" -> letBlock
    TokKeyword "if" -> ifExpr
    TokKeyword "for" -> forExpr
    TokKeyword "return" -> returnExpr
    TokKeyword "sql" -> parseSQL
    TokSymbol "[" -> listExprCore expr
    -- TokSymbol "\\" -> lambdaExpr
    -- TokKeyword "case" -> caseExpr
    TokLambdaCase -> lambdaCaseExpr expr
    _ -> exprCore

{-}
infixExpr :: Parser Expr
infixExpr = chainl1 atomExpr infixOp

infixOp :: Parser (Expr -> Expr -> Expr)
infixOp = do
  op <- operatorI
  return (\a b -> EApp (EApp (EVar op) a) b)
-}

exprNoInfix :: Parser Expr
exprNoInfix = do
  e <- exprDispatch
  postfix e

letBlock :: Parser Expr
letBlock = do
  t <- lookAhead anyToken
  myTrace ("<< letBlock next token: " ++ show t)
  try letExpr <|> pLetExpr

-- letBlock = try pLetExpr <|> letExpr

{-}
-- 後置構文（where など）
postfix :: Expr -> Parser Expr
postfix e =
  try
    ( do
        skipNewlines
        -- t <- lookAhead anyToken
        -- myTrace ("<< postfix next token: " ++ show t)
        binds <- whereClause
        postfix (EWhere e binds)
    )
    <|> return e
-}
{-}
postfix :: Expr -> Parser Expr
postfix e = do
  skipNewlines
  mbBinds <- whereClause
  case mbBinds of
    Just binds -> postfix (EWhere e binds)
    Nothing -> return e
-}
postfix :: Expr -> Parser Expr
postfix e = do
  skipNewlines
  -- 中置演算子を処理
  rest <-
    optional
      ( do
          op <- operatorI
          myTrace ("<< postfix: infix operator = " ++ show op)
          rhs <- expr
          return $ EApp (EApp (EVar op) e) rhs
      )
  case rest of
    Just e' -> postfix e'
    Nothing -> do
      mbBinds <- whereClause
      case mbBinds of
        Just binds -> postfix (EWhere e binds)
        Nothing -> return e

infixApp :: Expr -> Parser Expr
infixApp lhs = do
  op <- operatorI
  rhs <- expr
  return $ EApp (EApp (EVar op) lhs) rhs

whereClause :: Parser (Maybe [Binding])
whereClause = do
  -- skipSeparators
  t <- lookAhead anyToken
  myTrace ("<< whereClause: next token " ++ show t)
  try (keyword "where" >> bindings >>= \bs -> return (Just bs))
    <|> return Nothing

{-}
bindings = do
  b <- binding
  bs <- many binding
  return (b : bs)
-}
bindings :: Parser [Binding]
bindings = do
  bracesV $ do
    skipSeparators
    b <- binding
    bs <- many (skipSeparators >> binding)
    return (b : bs)

-- bindings :: Parser [Binding]
-- bindings = some binding

binding :: Parser Binding
binding = try valueBinding <|> funBinding

{-}
binding :: Parser Binding
binding = do
  pat <- pattern
  _ <- symbol "="   -- ここで '=' が無ければ binding は失敗する
  val <- expr
  return (pat, val)
-}
-- ============================================
--  exprTop / exprSeq
-- ============================================

exprTop :: Parser Expr
exprTop = try exprSeq <|> expr

exprSeq :: Parser Expr
exprSeq = do
  es <- sepEndBy1 (try expr) exprSep
  return $ if length es == 1 then head es else ESeq es

exprSep :: Parser ()
exprSep = skipMany1 (symbol ";" <|> newline)

-- ============================================
--  let / if / return / for
-- ============================================
def :: Parser (Pattern, Expr)
def = do
  p <- pattern
  symbol "="
  e <- expr
  return (p, e)

ifExpr :: Parser Expr
ifExpr = do
  keyword "if"
  cond <- expr
  keyword "then"
  th <- expr
  keyword "else"
  el <- expr
  return (EIf cond th el)

returnExpr :: Parser Expr
returnExpr = do
  keyword "return"
  e <- expr
  return (EReturn e)

forExpr :: Parser Expr
forExpr = do
  keyword "for"
  qs <- sepBy1 qualifier (symbol ",")
  token TokArrow
  body <- expr
  return (EListComp body qs)

qualifier :: Parser Qualifier
qualifier =
  try genQualifier
    <|> guardQualifier

genQualifier :: Parser Qualifier
genQualifier = do
  pat <- pattern
  keyword "in"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Qualifier
guardQualifier = QGuard <$> expr

{-}
funDecl :: Parser Decl
funDecl = do
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  return (FunDecl name args body)
-}

-- binding = try funBinding <|> valueBinding
{-}
funBinding :: Parser Binding
funBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (PApp (PVar name) args, body)
-}

funBinding :: Parser Binding
funBinding = do
  optional newline
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  -- 次のトークンが "=" なら funBinding ではない
  next <- lookAhead anyToken
  if next == TokOperator "="
    then empty -- ← guard の代わりに empty を使う
    else return ()
  args <- many pattern
  symbol "="
  body <- expr
  return (PApp (PVar name) args, body)

valueBinding :: Parser Binding
valueBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< valueBinding next token: " ++ show t)
  pat <- pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (pat, body)

{-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  -- myTrace ("<< letExpr")
  binds <- bindingsBlock
  optional (newline)
  mIn <- optional (keyword "in")
  optional (newline)
  case mIn of
    Just _ -> do
      body <- expr
      return (ELet binds body)
    Nothing ->
      return (ELet binds (EVar "__unit__"))
-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< letExpr next token: " ++ show t)
  binds <- bindingsBlock
  optional newline
  bracesV3 $ do
    mIn <- optional (keyword "in")
    optional newline
    case mIn of
      Just _ -> do
        body <- expr
        return (ELetBlock binds body)
      Nothing ->
        if null binds
          then empty -- ← これが正しい
          else return (ELetBlock binds (EVar "__unit__"))

{-}
  case mIn of
    Just _ -> do
      body <- expr
      return (ELetBlock binds body)
    Nothing ->
      return (ELetBlock binds (EVar "__unit__"))
-}

pLetExpr :: Parser Expr
pLetExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< pLetExpr next token: " ++ show t)
  pat <- pattern
  symbol "="
  e1 <- expr
  bracesV3 $ do
    keyword "in"
    e2 <- expr
    return (ELet pat e1 e2)

bindingsBlock :: Parser [Binding]
bindingsBlock = do
  -- optional (token TokNewline)
  braces (sepBy binding (symbol ";"))
    <|> sepBy binding (symbol ";")

{-}
whereClause :: Parser [Binding]
whereClause = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< whereClause next token: " ++ show t)
  keyword "where"
  bindingsBlock
-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokVLBrace,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokIdent "letExpr",TokSymbol ",",TokIdent "ifExpr",TokSymbol ",",TokIdent "returnExpr",TokSymbol ",",TokIdent "forExpr",TokSymbol ",",TokIdent "postfix",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSymbol "(",TokIdent "caseExprCore",TokSymbol ",",TokIdent "lambdaCaseExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pPattern",TokSymbol ",",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "expr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "expr",TokSymbol "=",TokIdent "infixExpr",TokNewline,TokIdent "infixExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "infixExpr",TokSymbol "=",TokIdent "chainl1",TokIdent "exprTerm",TokIdent "infixOp",TokNewline,TokIdent "exprTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokVRBrace,TokNewline,TokIdent "infixOp",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "infixOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< infixOp: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< infixOp: ",TokOperator "++",TokIdent "show",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "a",TokSymbol ")",TokIdent "b",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "do",TokArrow,TokIdent "doExprCore",TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "case",TokArrow,TokIdent "caseExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "let",TokArrow,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "if",TokArrow,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "for",TokArrow,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "return",TokArrow,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "sql",TokArrow,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "[",TokArrow,TokIdent "listExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokLambdaCase",TokArrow,TokIdent "lambdaCaseExpr",TokIdent "expr",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exprNoInfix",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprNoInfix",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokVRBrace,TokNewline,TokIdent "letBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokIdent "letExpr",TokOperator "<|>",TokIdent "pLetExpr",TokVRBrace,TokNewline,TokIdent "postfix",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokIdent "e",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokIdent "myTrace",TokSymbol "(",TokString "<< postfix: infix operator = ",TokOperator "++",TokIdent "show",TokIdent "op",TokSymbol ")",TokIdent "rhs",TokSymbol "<-",TokIdent "expr",TokKeyword "return",TokOperator "$",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "e",TokSymbol ")",TokIdent "rhs",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "e'",TokArrow,TokIdent "postfix",TokIdent "e'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "mbBinds",TokSymbol "<-",TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokIdent "mbBinds",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "binds",TokArrow,TokIdent "postfix",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "e",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "infixApp",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "infixApp",TokIdent "lhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokIdent "rhs",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "lhs",TokSymbol ")",TokIdent "rhs",TokVRBrace,TokNewline,TokIdent "whereClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereClause: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">>",TokIdent "bindings",TokOperator ">>",TokSymbol "=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindings",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "b",TokSymbol "<-",TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "skipSeparators",TokOperator ">>",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "b",TokOperator ":",TokIdent "bs",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSymbol "=",TokIdent "try",TokIdent "valueBinding",TokOperator "<|>",TokIdent "funBinding",TokNewline,TokIdent "exprTop",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSymbol "=",TokIdent "try",TokIdent "exprSeq",TokOperator "<|>",TokIdent "expr",TokNewline,TokIdent "exprSeq",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "es",TokSymbol "<-",TokIdent "sepEndBy1",TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "if",TokIdent "length",TokIdent "es",TokOperator "==",TokNumber 1,TokKeyword "then",TokIdent "head",TokIdent "es",TokKeyword "else",TokTypeIdent "ESeq",TokIdent "es",TokVRBrace,TokNewline,TokIdent "exprSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "exprSep",TokSymbol "=",TokIdent "skipMany1",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ifExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "if",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "then",TokSymbol ";",TokIdent "th",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "else",TokSymbol ";",TokIdent "el",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "returnExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "return",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "forExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "for",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "qualifier",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSymbol "=",TokVLBrace,TokIdent "try",TokIdent "genQualifier",TokVLBrace,TokOperator "<|>",TokIdent "guardQualifier",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "funBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokIdent "next",TokOperator "==",TokTypeIdent "TokOperator",TokString "=",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "valueBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "mIn",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokKeyword "case",TokIdent "mIn",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "null",TokIdent "binds",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pLetExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "e2",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindingsBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "braces",TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "expr"
<< exportItem: next token=TokIdent "exprTop"
<< exportItem: next token=TokIdent "exprSeq"
<< exportItem: next token=TokIdent "exprSep"
<< exportItem: next token=TokIdent "letExpr"
<< exportItem: next token=TokIdent "ifExpr"
<< exportItem: next token=TokIdent "returnExpr"
<< exportItem: next token=TokIdent "forExpr"
<< exportItem: next token=TokIdent "postfix"
<< exportItem: next token=TokIdent "skipNewlines"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprExtensions" (Just [ExportVar "expr",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep",ExportVar "letExpr",ExportVar "ifExpr",ExportVar "returnExpr",ExportVar "forExpr",ExportVar "postfix",ExportVar "skipNewlines"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Expr.ExprExtensions" (Just [ExportVar "expr",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep",ExportVar "letExpr",ExportVar "ifExpr",ExportVar "returnExpr",ExportVar "forExpr",ExportVar "postfix",ExportVar "skipNewlines"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSymbol "(",TokIdent "caseExprCore",TokSymbol ",",TokIdent "lambdaCaseExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pPattern",TokSymbol ",",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "expr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "expr",TokSymbol "=",TokIdent "infixExpr",TokNewline,TokIdent "infixExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "infixExpr",TokSymbol "=",TokIdent "chainl1",TokIdent "exprTerm",TokIdent "infixOp",TokNewline,TokIdent "exprTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokVRBrace,TokNewline,TokIdent "infixOp",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "infixOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< infixOp: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< infixOp: ",TokOperator "++",TokIdent "show",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "a",TokSymbol ")",TokIdent "b",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "do",TokArrow,TokIdent "doExprCore",TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "case",TokArrow,TokIdent "caseExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "let",TokArrow,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "if",TokArrow,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "for",TokArrow,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "return",TokArrow,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "sql",TokArrow,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "[",TokArrow,TokIdent "listExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokLambdaCase",TokArrow,TokIdent "lambdaCaseExpr",TokIdent "expr",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exprNoInfix",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprNoInfix",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokVRBrace,TokNewline,TokIdent "letBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokIdent "letExpr",TokOperator "<|>",TokIdent "pLetExpr",TokVRBrace,TokNewline,TokIdent "postfix",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokIdent "e",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokIdent "myTrace",TokSymbol "(",TokString "<< postfix: infix operator = ",TokOperator "++",TokIdent "show",TokIdent "op",TokSymbol ")",TokIdent "rhs",TokSymbol "<-",TokIdent "expr",TokKeyword "return",TokOperator "$",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "e",TokSymbol ")",TokIdent "rhs",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "e'",TokArrow,TokIdent "postfix",TokIdent "e'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "mbBinds",TokSymbol "<-",TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokIdent "mbBinds",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "binds",TokArrow,TokIdent "postfix",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "e",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "infixApp",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "infixApp",TokIdent "lhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorI",TokSymbol ";",TokIdent "rhs",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EApp",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokIdent "lhs",TokSymbol ")",TokIdent "rhs",TokVRBrace,TokNewline,TokIdent "whereClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereClause: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">>",TokIdent "bindings",TokOperator ">>",TokSymbol "=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindings",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "b",TokSymbol "<-",TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "skipSeparators",TokOperator ">>",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "b",TokOperator ":",TokIdent "bs",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSymbol "=",TokIdent "try",TokIdent "valueBinding",TokOperator "<|>",TokIdent "funBinding",TokNewline,TokIdent "exprTop",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSymbol "=",TokIdent "try",TokIdent "exprSeq",TokOperator "<|>",TokIdent "expr",TokNewline,TokIdent "exprSeq",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "es",TokSymbol "<-",TokIdent "sepEndBy1",TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "if",TokIdent "length",TokIdent "es",TokOperator "==",TokNumber 1,TokKeyword "then",TokIdent "head",TokIdent "es",TokKeyword "else",TokTypeIdent "ESeq",TokIdent "es",TokVRBrace,TokNewline,TokIdent "exprSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "exprSep",TokSymbol "=",TokIdent "skipMany1",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ifExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "if",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "then",TokSymbol ";",TokIdent "th",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "else",TokSymbol ";",TokIdent "el",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "returnExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "return",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "forExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "for",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "qualifier",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSymbol "=",TokVLBrace,TokIdent "try",TokIdent "genQualifier",TokVLBrace,TokOperator "<|>",TokIdent "guardQualifier",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "funBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokIdent "next",TokOperator "==",TokTypeIdent "TokOperator",TokString "=",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "valueBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "mIn",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokKeyword "case",TokIdent "mIn",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "null",TokIdent "binds",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pLetExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "e2",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindingsBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "braces",TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprParser
  ( exprCore,
    exprTop,
    exprSeq,
    exprSep,
  )
where

import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (exprSep, exprSeq, exprTop)

-- import Parser.SQL.SQLParser

-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprParser",TokVLBrace,TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "exprSep",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprTop",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "exprCore"
<< exportItem: next token=TokIdent "exprTop"
<< exportItem: next token=TokIdent "exprSeq"
<< exportItem: next token=TokIdent "exprSep"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprParser" (Just [ExportVar "exprCore",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprSep",ImportVar "exprSeq",ImportVar "exprTop"]}
Just ([DeclModule "Parser.Expr.ExprParser" (Just [ExportVar "exprCore",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep"]),DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprSep",ImportVar "exprSeq",ImportVar "exprTop"]}],[TokNewline])

=== Running: src/Parser/Expr/ListParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ListParserCore (listExprCore) where

import AST.Expr
import Control.Applicative (many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser (pattern)
import Utils.MyTrace

listExprCore :: Parser Expr -> Parser Expr
listExprCore expr =
  brackets $
    try (listCompExpr expr) -- ★ 最優先
      <|> try (stepRangeExpr expr)
      <|> try (rangeExpr expr)
      <|> listLiteralExpr expr

-- [a, b .. c]
stepRangeExpr :: Parser Expr -> Parser Expr
stepRangeExpr expr = do
  start <- exprCore
  symbol ","
  step <- exprCore
  symbol ".."
  end <- exprCore
  return (ERangeStep start step end)

-- [a .. b]
rangeExpr :: Parser Expr -> Parser Expr
rangeExpr expr = do
  start <- exprCore
  symbol ".."
  end <- exprCore
  return (ERange start end)

-- [a, b, c]
listLiteralExpr :: Parser Expr -> Parser Expr
listLiteralExpr expr = do
  elems <- sepBy exprCore (symbol ",")
  optional (symbol ",")
  return (EList elems)

-- [x | ...]
listCompExpr :: Parser Expr -> Parser Expr
listCompExpr expr = do
  body <- exprCore
  symbol "|"
  qs <- sepBy1 (qualifier expr) (symbol ",")
  return (EListComp body qs)

qualifier :: Parser Expr -> Parser Qualifier
qualifier expr =
  try (genQualifier expr) -- ★ 最優先
    <|> try (letQualifier expr)
    <|> guardQualifier expr

genQualifier :: Parser Expr -> Parser Qualifier
genQualifier expr = do
  pat <- pattern
  symbol "<-"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Expr -> Parser Qualifier
guardQualifier expr = QGuard <$> expr

{-}
letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QGuard (ELet binds (EVar "__unit__")))
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)
-}

letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QLet binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "listExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listExprCore",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "brackets",TokOperator "$",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "listLiteralExpr",TokIdent "expr",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "stepRangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "step",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "rangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "elems",TokSymbol "<-",TokIdent "sepBy",TokIdent "exprCore",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listCompExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "guardQualifier",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokIdent "expr",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "letQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "listExprCore"
<< declBody: return DeclModule "Parser.Expr.ListParserCore" (Just [ExportVar "listExprCore"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "Parser.Expr.ListParserCore" (Just [ExportVar "listExprCore"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "listExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listExprCore",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "brackets",TokOperator "$",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "listLiteralExpr",TokIdent "expr",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "stepRangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "step",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "rangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "elems",TokSymbol "<-",TokIdent "sepBy",TokIdent "exprCore",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listCompExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "guardQualifier",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokIdent "expr",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "letQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/PatternParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.PatternParser
  ( pattern,
    patternParser,
    patternStart,
    pConstrOrVar,
    patternVar,
    constraintP,
    pParenOrTuple,
    pList,
    pWildcard,
    pInt,
    pPattern,
  )
where

import AST.Pattern
import Control.Applicative
import Data.Char (isUpper)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace (myTrace)

patternParser :: Parser Pattern
patternParser = do
  p <- pAs <|> makeCons
  myTrace ("<< patternParser: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

pattern :: Parser Pattern
pattern = do
  p <- pAs <|> makeCons
  myTrace ("<< pattern1: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

patternStart :: Parser ()
patternStart =
  void (symbol "_")
    <|> void ident
    <|> void typeIdent
    <|> void int
    <|> void (symbol "(")

stopPattern :: Parser ()
stopPattern =
  lookAhead $
    symbol "|"
      <|> void (token TokArrow)
      <|> void (token TokNewline)
      <|> symbol ";"
      <|> symbol "}"
      <|> keyword "in"
      <|> keyword "for"
      <|> keyword "return"
      <|> keyword "case"
      <|> keyword "let"
      <|> keyword "if"
      <|> keyword "do"
      <|> eof

eof :: Parser ()
eof = Parser $ \ts ->
  case ts of
    [] -> Just ((), [])
    _ -> Nothing

makeCons :: Parser Pattern
makeCons = do
  p <- makeApp
  rest p
  where
    rest p =
      ( do
          symbol ":"
          p2 <- makeCons
          return (PCons p p2)
      )
        <|> return p

makeApp :: Parser Pattern
makeApp = do
  p <- pAtom
  ps <- many pAtom
  return (PApp p ps)

pAtom :: Parser Pattern
pAtom = do
  t <- lookAhead anyToken
  case t of
    TokKeyword _ -> empty -- ★ キーワードはパターンにならない
    _ -> pure ()
  pAs
    <|> pList
    <|> pParenOrTuple
    <|> pConstrOrVar
    <|> pInt
    <|> pChar
    <|> pString
    <|> (symbol "_" >> return PWildcard)

pPattern :: Parser Pattern
pPattern = do
  t <- lookAhead anyToken
  myTrace ("<< pPattern: next token " ++ show t)
  pat <- pInfix
  myTrace ("<< parsed pattern: " ++ show pat)
  return pat

pInfix :: Parser Pattern
pInfix = chainl1 pAtom infixOp
  where
    infixOp = do
      op <- operatorIAsName
      return (\a b -> PInfix a op b)

pAs :: Parser Pattern
pAs = do
  name <- ident
  symbol "@"
  pat <- pAtom
  return (PAs name pat)

{-}
pConstrOrVar :: Parser Pattern
pConstrOrVar =
  do
    patternVar
    <|> constraintP
-}
{-}
pConstrOrVar :: Parser Pattern
pConstrOrVar = do
  name <- try identI <|> parens operatorIAsName
  return $
    if isUpper (head name) || isSymbolName name
      then PConstr name []
      else PVar name
-}
pConstrOrVar :: Parser Pattern
pConstrOrVar = do
  t <- lookAhead anyToken
  myTrace ("<< pConstrOrVar: next token " ++ show t)
  name <- try identI <|> try (parens operatorIAsName) <|> operatorI
  return $
    if isSymbolName name
      then PConstr name []
      else PVar name

patternVar :: Parser Pattern
patternVar = tokenIs $ \case
  TokIdent name -> Just (PVar name)
  -- TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

constraintP :: Parser Pattern
constraintP = tokenIs $ \case
  -- TokIdent name -> Just (PVar name)
  TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

isKeyword :: String -> Bool
isKeyword s =
  s
    `elem` [ "case",
             "of",
             "let",
             "in",
             "if",
             "then",
             "else",
             "do",
             "return"
           ]

isIdentOnly :: Token -> Bool
isIdentOnly (TokIdent _) = True
isIdentOnly _ = False

pParenOrTuple :: Parser Pattern
pParenOrTuple = parens $ do
  pats <- pattern `sepBy1` symbol ","
  return $ case pats of
    [single] -> single
    _ -> PTuple pats

pList :: Parser Pattern
pList = PList <$> brackets (pattern `sepBy` symbol ",")

pWildcard :: Parser Pattern
pWildcard = symbol "_" >> return PWildcard

pInt :: Parser Pattern
pInt = PInt <$> int

pChar :: Parser Pattern
pChar = do
  c <- charLiteralExpr -- すでに定義済みならそれを使う
  return (PChar c)

pString :: Parser Pattern
pString = PString <$> stringLiteralExpr


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokVLBrace,TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ",",TokIdent "patternStart",TokSymbol ",",TokIdent "pConstrOrVar",TokSymbol ",",TokIdent "patternVar",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "pParenOrTuple",TokSymbol ",",TokIdent "pList",TokSymbol ",",TokIdent "pWildcard",TokSymbol ",",TokIdent "pInt",TokSymbol ",",TokIdent "pPattern",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokIdent "patternParser",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternParser",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "pattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "patternStart",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "patternStart",TokSymbol "=",TokVLBrace,TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "void",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "stopPattern",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "stopPattern",TokSymbol "=",TokVLBrace,TokIdent "lookAhead",TokOperator "$",TokVLBrace,TokIdent "symbol",TokString "|",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString ";",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString "}",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "in",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "for",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "return",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "case",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "let",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "if",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "do",TokSymbol ";",TokOperator "<|>",TokIdent "eof",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "eof",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "eof",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeCons",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokIdent "p",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "p",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "p",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSymbol "<-",TokIdent "many",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokIdent "_",TokArrow,TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "pure",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAs",TokVLBrace,TokOperator "<|>",TokIdent "pList",TokSymbol ";",TokOperator "<|>",TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<|>",TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<|>",TokIdent "pInt",TokSymbol ";",TokOperator "<|>",TokIdent "pChar",TokSymbol ";",TokOperator "<|>",TokIdent "pString",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pPattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pPattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pPattern: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pInfix",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed pattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "pat",TokVRBrace,TokNewline,TokIdent "pInfix",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInfix",TokSymbol "=",TokIdent "chainl1",TokIdent "pAtom",TokIdent "infixOp",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "infixOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorIAsName",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokTypeIdent "PInfix",TokIdent "a",TokIdent "op",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pAs",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "@",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pConstrOrVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pConstrOrVar: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "try",TokIdent "identI",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "parens",TokIdent "operatorIAsName",TokSymbol ")",TokOperator "<|>",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokVLBrace,TokKeyword "if",TokIdent "isSymbolName",TokIdent "name",TokVLBrace,TokKeyword "then",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "else",TokTypeIdent "PVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "patternVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokSymbol ";",TokTypeIdent "TokTypeIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isKeyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokIdent "s",TokSymbol "=",TokVLBrace,TokIdent "s",TokVLBrace,TokIdent "`elem`",TokSymbol "[",TokString "case",TokSymbol ",",TokVLBrace,TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isIdentOnly",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSymbol "(",TokTypeIdent "TokIdent",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "pParenOrTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSymbol "=",TokIdent "parens",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "pats",TokSymbol "<-",TokIdent "pattern",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "pats",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "single",TokSymbol "]",TokArrow,TokIdent "single",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "PTuple",TokIdent "pats",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pList",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSymbol "=",TokTypeIdent "PList",TokOperator "<$>",TokIdent "brackets",TokSymbol "(",TokIdent "pattern",TokIdent "`sepBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokIdent "pWildcard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSymbol "=",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokNewline,TokIdent "pInt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSymbol "=",TokTypeIdent "PInt",TokOperator "<$>",TokIdent "int",TokNewline,TokIdent "pChar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pChar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "c",TokSymbol "<-",TokIdent "charLiteralExpr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PChar",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pString",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pString",TokSymbol "=",TokTypeIdent "PString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "pattern"
<< exportItem: next token=TokIdent "patternParser"
<< exportItem: next token=TokIdent "patternStart"
<< exportItem: next token=TokIdent "pConstrOrVar"
<< exportItem: next token=TokIdent "patternVar"
<< exportItem: next token=TokIdent "constraintP"
<< exportItem: next token=TokIdent "pParenOrTuple"
<< exportItem: next token=TokIdent "pList"
<< exportItem: next token=TokIdent "pWildcard"
<< exportItem: next token=TokIdent "pInt"
<< exportItem: next token=TokIdent "pPattern"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.PatternParser" (Just [ExportVar "pattern",ExportVar "patternParser",ExportVar "patternStart",ExportVar "pConstrOrVar",ExportVar "patternVar",ExportVar "constraintP",ExportVar "pParenOrTuple",ExportVar "pList",ExportVar "pWildcard",ExportVar "pInt",ExportVar "pPattern"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "myTrace"]}
<< decl next token: TokIdent "patternParser"
<< decl parser called
<< decl dispatch: TokIdent "patternParser"
<< funDecl: next token=TokIdent "patternParser"
<< funClause: next token=TokIdent "patternParser"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "patternParser"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Pattern")
<< parsed type signature: patternParser :: TApp (TCon "Parser") (TCon "Pattern")
<< returning DeclTypeSig: DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern"))
<< declBody: return DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern"))
<< decl next token: TokIdent "patternParser"
<< decl parser called
<< decl dispatch: TokIdent "patternParser"
<< funDecl: next token=TokIdent "patternParser"
<< funClause: next token=TokIdent "patternParser"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "p"
<< pConstrOrVar: next token TokIdent "p"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "p") []
<< expr dispatch: TokIdent "pAs"
<< exprCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "makeCons"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pConstrOrVar: next token TokIdent "myTrace"
<< pConstrOrVar: next token TokString "<< patternParser: (pAs <|> makeCons)"
<< pConstrOrVar: next token TokOperator "++"
<< pConstrOrVar: next token TokIdent "show"
<< pConstrOrVar: next token TokIdent "p"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< patternParser: (pAs <|> makeCons)") [PConstr "++" [],PVar "show",PVar "p"]
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") [PApp (PString "<< patternParser: (pAs <|> makeCons)") [PConstr "++" [],PVar "show",PVar "p"]]
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
<< typeSigDecl: TokIdent "patternParser"
<< typeSigDecl:2 TokSymbol "="
<< valueDecl: TokIdent "patternParser"
<< pConstrOrVar: next token TokIdent "patternParser"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "patternParser") []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "p"
<< pConstrOrVar: next token TokIdent "p"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "p") []
<< expr dispatch: TokIdent "pAs"
<< exprCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "makeCons"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pConstrOrVar: next token TokIdent "myTrace"
<< pConstrOrVar: next token TokString "<< patternParser: (pAs <|> makeCons)"
<< pConstrOrVar: next token TokOperator "++"
<< pConstrOrVar: next token TokIdent "show"
<< pConstrOrVar: next token TokIdent "p"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< patternParser: (pAs <|> makeCons)") [PConstr "++" [],PVar "show",PVar "p"]
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") [PApp (PString "<< patternParser: (pAs <|> makeCons)") [PConstr "++" [],PVar "show",PVar "p"]]
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
Just ([DeclModule "Parser.Expr.PatternParser" (Just [ExportVar "pattern",ExportVar "patternParser",ExportVar "patternStart",ExportVar "pConstrOrVar",ExportVar "patternVar",ExportVar "constraintP",ExportVar "pParenOrTuple",ExportVar "pList",ExportVar "pWildcard",ExportVar "pInt",ExportVar "pPattern"]),DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]},DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "myTrace"]},DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern"))],[TokNewline,TokIdent "patternParser",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "pattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "patternStart",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "patternStart",TokSymbol "=",TokVLBrace,TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "void",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "stopPattern",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "stopPattern",TokSymbol "=",TokVLBrace,TokIdent "lookAhead",TokOperator "$",TokVLBrace,TokIdent "symbol",TokString "|",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString ";",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString "}",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "in",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "for",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "return",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "case",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "let",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "if",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "do",TokSymbol ";",TokOperator "<|>",TokIdent "eof",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "eof",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "eof",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeCons",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokIdent "p",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "p",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "p",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSymbol "<-",TokIdent "many",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokIdent "_",TokArrow,TokIdent "empty",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "pure",TokSymbol "(",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAs",TokVLBrace,TokOperator "<|>",TokIdent "pList",TokSymbol ";",TokOperator "<|>",TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<|>",TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<|>",TokIdent "pInt",TokSymbol ";",TokOperator "<|>",TokIdent "pChar",TokSymbol ";",TokOperator "<|>",TokIdent "pString",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pPattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pPattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pPattern: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pInfix",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed pattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "pat",TokVRBrace,TokNewline,TokIdent "pInfix",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInfix",TokSymbol "=",TokIdent "chainl1",TokIdent "pAtom",TokIdent "infixOp",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "infixOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "operatorIAsName",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokTypeIdent "PInfix",TokIdent "a",TokIdent "op",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pAs",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "@",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pConstrOrVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pConstrOrVar: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "try",TokIdent "identI",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "parens",TokIdent "operatorIAsName",TokSymbol ")",TokOperator "<|>",TokIdent "operatorI",TokSymbol ";",TokKeyword "return",TokOperator "$",TokVLBrace,TokKeyword "if",TokIdent "isSymbolName",TokIdent "name",TokVLBrace,TokKeyword "then",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "else",TokTypeIdent "PVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "patternVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokTypeIdent "TokIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokLambdaCase,TokVLBrace,TokSymbol ";",TokTypeIdent "TokTypeIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isKeyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokIdent "s",TokSymbol "=",TokVLBrace,TokIdent "s",TokVLBrace,TokIdent "`elem`",TokSymbol "[",TokString "case",TokSymbol ",",TokVLBrace,TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isIdentOnly",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSymbol "(",TokTypeIdent "TokIdent",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokIdent "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "pParenOrTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSymbol "=",TokIdent "parens",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "pats",TokSymbol "<-",TokIdent "pattern",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "pats",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "single",TokSymbol "]",TokArrow,TokIdent "single",TokSymbol ";",TokIdent "_",TokArrow,TokTypeIdent "PTuple",TokIdent "pats",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pList",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSymbol "=",TokTypeIdent "PList",TokOperator "<$>",TokIdent "brackets",TokSymbol "(",TokIdent "pattern",TokIdent "`sepBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokIdent "pWildcard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSymbol "=",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokNewline,TokIdent "pInt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSymbol "=",TokTypeIdent "PInt",TokOperator "<$>",TokIdent "int",TokNewline,TokIdent "pChar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pChar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "c",TokSymbol "<-",TokIdent "charLiteralExpr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PChar",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pString",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pString",TokSymbol "=",TokTypeIdent "PString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokNewline])

=== Running: src/Parser/SQL/SQLParser.hs ===
-- Raw Source --
module Parser.SQL.SQLParser (parseSQL) where

import AST.Expr -- (Expr (..))

-- {var} 抽出用（後で作る）
import Parser.Core.Combinator
import Parser.Core.TokenParser
-- import Parser.Expr.ExprCore
import Utils.SQLUtils

parseSQL :: Parser Expr
parseSQL = do
  _ <- keyword "sql"
  sqlText <- stringLiteralExpr
  let (sqlBody, vars) = extractSQLVars sqlText
  return (ESQL sqlBody (map EVar vars))


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokSymbol "(",TokIdent "parseSQL",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokNewline,TokIdent "parseSQL",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parseSQL",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "keyword",TokString "sql",TokSymbol ";",TokIdent "sqlText",TokSymbol "<-",TokIdent "stringLiteralExpr",TokSymbol ";",TokKeyword "let",TokSymbol "(",TokIdent "sqlBody",TokSymbol ",",TokIdent "vars",TokSymbol ")",TokSymbol "=",TokIdent "extractSQLVars",TokIdent "sqlText",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ESQL",TokIdent "sqlBody",TokSymbol "(",TokIdent "map",TokTypeIdent "EVar",TokIdent "vars",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseSQL"
<< declBody: return DeclModule "Parser.SQL.SQLParser" (Just [ExportVar "parseSQL"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.SQLUtils", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "parseSQL"
<< decl parser called
<< decl dispatch: TokIdent "parseSQL"
<< funDecl: next token=TokIdent "parseSQL"
<< funClause: next token=TokIdent "parseSQL"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseSQL"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parsed type signature: parseSQL :: TApp (TCon "Parser") (TCon "Expr")
<< returning DeclTypeSig: DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr"))
<< declBody: return DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr"))
<< decl next token: TokIdent "parseSQL"
<< decl parser called
<< decl dispatch: TokIdent "parseSQL"
<< funDecl: next token=TokIdent "parseSQL"
<< funClause: next token=TokIdent "parseSQL"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "_"
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "sql"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sqlText"
<< pConstrOrVar: next token TokIdent "sqlText"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlText") []
<< expr dispatch: TokIdent "stringLiteralExpr"
<< exprCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "sqlBody"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlBody") []
<< pConstrOrVar: next token TokIdent "vars"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "vars") []
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sqlBody") [],PApp (PVar "vars") []]) []
<< expr dispatch: TokIdent "extractSQLVars"
<< exprCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "sqlText"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< typeSigDecl: TokIdent "parseSQL"
<< typeSigDecl:2 TokSymbol "="
<< valueDecl: TokIdent "parseSQL"
<< pConstrOrVar: next token TokIdent "parseSQL"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "parseSQL") []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "_"
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "sql"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sqlText"
<< pConstrOrVar: next token TokIdent "sqlText"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlText") []
<< expr dispatch: TokIdent "stringLiteralExpr"
<< exprCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "sqlBody"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlBody") []
<< pConstrOrVar: next token TokIdent "vars"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "vars") []
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sqlBody") [],PApp (PVar "vars") []]) []
<< expr dispatch: TokIdent "extractSQLVars"
<< exprCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "sqlText"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
Just ([DeclModule "Parser.SQL.SQLParser" (Just [ExportVar "parseSQL"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Utils.SQLUtils", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr"))],[TokNewline,TokIdent "parseSQL",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "_",TokSymbol "<-",TokIdent "keyword",TokString "sql",TokSymbol ";",TokIdent "sqlText",TokSymbol "<-",TokIdent "stringLiteralExpr",TokSymbol ";",TokKeyword "let",TokSymbol "(",TokIdent "sqlBody",TokSymbol ",",TokIdent "vars",TokSymbol ")",TokSymbol "=",TokIdent "extractSQLVars",TokIdent "sqlText",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ESQL",TokIdent "sqlBody",TokSymbol "(",TokIdent "map",TokTypeIdent "EVar",TokIdent "vars",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Parser/Type/TypeParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Type.TypeParser
  ( parseType,
    parseForall,
    arrowType,
    typeApp,
    typeAtom,
    typeIdent,
    constraintP,
    constraintList,
    typeP,
  )
where

import AST.Decl
import AST.Expr
import AST.Type
import Control.Applicative
import Data.Char (isUpper)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Core.TokenParser (skipNewlines)
import Utils.MyTrace

parseType :: Parser Type
parseType = do
  t <- lookAhead anyToken
  myTrace ("<< parseType dispatch: " ++ show t)
  case t of
    TokVLBrace -> bracesV parseTypeCore
    _ -> parseTypeCore

parseTypeCore :: Parser Type
parseTypeCore = do
  skipMany (symbol ";" <|> newline)
  -- t <- lookAhead anyToken
  -- myTrace ("<< parseTypeCore next token: " ++ show t)
  t1 <- arrowType
  myTrace ("<< parseTypeCore: " ++ show t1)
  rest <- optional $ do
    token (TokKeyword "=>")
    t2 <- parseTypeCore
    return (t1, t2)
  case rest of
    Just (TApp (TCon cls) arg, body) ->
      return $ TConstraint [Constraint cls [arg]] body
    Just (TCon cls, body) ->
      return $ TConstraint [Constraint cls []] body
    Just (TTuple cs, body) ->
      return $ TConstraint (map toConstraint cs) body
    Nothing -> return t1
    _ -> empty

arrowType :: Parser Type
arrowType = do
  t1 <- typeApp
  -- t <- lookAhead anyToken
  -- myTrace ("<< arrowType next token: " ++ show t)
  rest <- optional $ do
    token (TokArrow)
    parseTypeCore
  return $ maybe t1 (TFun t1) rest

parensTuple :: Parser Type
parensTuple = do
  symbol "("
  ts <- parseTypeCore `sepBy1` symbol ","
  symbol ")"
  return (TTuple ts)

toConstraint :: Type -> Constraint
toConstraint (TApp (TCon cls) arg) = (Constraint cls [arg])
toConstraint (TCon cls) = (Constraint cls [])
toConstraint other = error $ "Invalid constraint form: " ++ show other

typeApp :: Parser Type
typeApp = do
  f <- typeTerm -- typeAtom
  args <- many typeTerm -- typeAtom
  return $ foldl TApp f args

typeTerm :: Parser Type
typeTerm = do
  ts <- some typeAtom
  return (foldl1 TApp ts)

typeAtom :: Parser Type
typeAtom =
  (parens parseTypeCore) -- 括弧付き型
    <|> tUnitType -- (symbol "()" *> pure TUnit) -- 単位型
    <|> (TCon <$> typeIdent)
    <|> (TVar <$> ident)
    <|> brackets (TList <$> parseTypeCore)
    <|> parensTuple

tUnitType :: Parser Type
tUnitType = do
  symbol "("
  symbol ")"
  return (TUnit)

constrainedType :: Parser Type
constrainedType = do
  symbol "("
  cs <- sepBy1 constraint (symbol ",")
  symbol ")"
  keyword "=>"
  ty <- arrowType
  return (TConstraint cs ty)

parseForall :: Parser Type
parseForall = do
  token TokForall
  vars <- some ident
  token TokDot
  body <- parseTypeCore
  return $ TForall vars body

constraint :: Parser Constraint
constraint = do
  cls <- ident
  ty <- typeApp
  return (Constraint cls [ty])

constraintP :: Parser Constraint
constraintP = do
  className <- typeIdent
  args <- some typeAtom
  return $ Constraint className args

constraintList :: Parser [Constraint]
constraintList = do
  try (parens (constraintP `sepBy1` symbol ","))
    <|> fmap (: []) constraintP

typeP :: Parser Type
typeP = try forallType <|> typeAtom

forallType :: Parser Type
forallType = do
  token TokForall
  vars <- some ident
  token TokDot
  t <- constrainedType
  return (TForall vars t)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokVLBrace,TokSymbol "(",TokIdent "parseType",TokSymbol ",",TokIdent "parseForall",TokSymbol ",",TokIdent "arrowType",TokSymbol ",",TokIdent "typeApp",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "constraintList",TokSymbol ",",TokIdent "typeP",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "(",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "parseType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseType dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokIdent "bracesV",TokIdent "parseTypeCore",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "parseTypeCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseTypeCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseTypeCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipMany",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "t1",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseTypeCore: ",TokOperator "++",TokIdent "show",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "t1",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "arrowType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t1",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokIdent "parseTypeCore",TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokIdent "maybe",TokIdent "t1",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "parensTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parensTuple",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "ts",TokSymbol "<-",TokIdent "parseTypeCore",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "toConstraint",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokIdent "other",TokSymbol "=",TokIdent "error",TokOperator "$",TokString "Invalid constraint form: ",TokOperator "++",TokIdent "show",TokIdent "other",TokNewline,TokIdent "typeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "typeTerm",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeTerm",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl",TokTypeIdent "TApp",TokIdent "f",TokIdent "args",TokVRBrace,TokNewline,TokIdent "typeTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "parens",TokIdent "parseTypeCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "tUnitType",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TVar",TokOperator "<$>",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "brackets",TokSymbol "(",TokTypeIdent "TList",TokOperator "<$>",TokIdent "parseTypeCore",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "parensTuple",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tUnitType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "tUnitType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TUnit",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constrainedType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "cs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "constraint",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokIdent "keyword",TokString "=>",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseForall",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "TForall",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline,TokIdent "constraint",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "cls",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "className",TokIdent "args",TokVRBrace,TokNewline,TokIdent "constraintList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "fmap",TokSymbol "(",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSymbol "=",TokIdent "try",TokIdent "forallType",TokOperator "<|>",TokIdent "typeAtom",TokNewline,TokIdent "forallType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseType"
<< exportItem: next token=TokIdent "parseForall"
<< exportItem: next token=TokIdent "arrowType"
<< exportItem: next token=TokIdent "typeApp"
<< exportItem: next token=TokIdent "typeAtom"
<< exportItem: next token=TokIdent "typeIdent"
<< exportItem: next token=TokIdent "constraintP"
<< exportItem: next token=TokIdent "constraintList"
<< exportItem: next token=TokIdent "typeP"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Type.TypeParser" (Just [ExportVar "parseType",ExportVar "parseForall",ExportVar "arrowType",ExportVar "typeApp",ExportVar "typeAtom",ExportVar "typeIdent",ExportVar "constraintP",ExportVar "constraintList",ExportVar "typeP"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "parseType"
<< decl parser called
<< decl dispatch: TokIdent "parseType"
<< funDecl: next token=TokIdent "parseType"
<< funClause: next token=TokIdent "parseType"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseType"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Type")
<< parsed type signature: parseType :: TApp (TCon "Parser") (TCon "Type")
<< returning DeclTypeSig: DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type"))
<< declBody: return DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type"))
<< decl next token: TokIdent "parseType"
<< decl parser called
<< decl dispatch: TokIdent "parseType"
<< funDecl: next token=TokIdent "parseType"
<< funClause: next token=TokIdent "parseType"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pConstrOrVar: next token TokIdent "myTrace"
<< pConstrOrVar: next token TokString "<< parseType dispatch: "
<< pConstrOrVar: next token TokOperator "++"
<< pConstrOrVar: next token TokIdent "show"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< parseType dispatch: ") [PConstr "++" [],PVar "show",PVar "t"]
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") [PApp (PString "<< parseType dispatch: ") [PConstr "++" [],PVar "show",PVar "t"]]
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "t"
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "TokVLBrace"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "TokVLBrace") []
<< caseAlt: next token TokArrow PApp (PVar "TokVLBrace") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "bracesV"
<< exprCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< caseAlt: next token TokArrow PApp (PVar "_") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "parseTypeCore"
<< exprCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "parseTypeCore"
<< infixOp: next token TokIdent "parseTypeCore"
<< whereBlock: next tokenTokIdent "parseTypeCore"
<< funClauseWithName: next token=TokIdent "parseTypeCore"
<< declBody: return DeclFunGroup "parseType" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< parseType dispatch: ") (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PVar "TokVLBrace") []) (EApp (EVar "bracesV") (EVar "parseTypeCore")),CaseAlt (PApp (PVar "_") []) (EVar "parseTypeCore")])])) Nothing]
<< decl next token: TokIdent "parseTypeCore"
<< decl parser called
<< decl dispatch: TokIdent "parseTypeCore"
<< funDecl: next token=TokIdent "parseTypeCore"
<< funClause: next token=TokIdent "parseTypeCore"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseTypeCore"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Type")
<< parsed type signature: parseTypeCore :: TApp (TCon "Parser") (TCon "Type")
<< returning DeclTypeSig: DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type"))
<< declBody: return DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type"))
<< decl next token: TokIdent "parseTypeCore"
<< decl parser called
<< decl dispatch: TokIdent "parseTypeCore"
<< funDecl: next token=TokIdent "parseTypeCore"
<< funClause: next token=TokIdent "parseTypeCore"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "skipMany"
<< pConstrOrVar: next token TokIdent "skipMany"
<< pConstrOrVar: next token TokIdent "symbol"
<< pConstrOrVar: next token TokString ";"
<< pConstrOrVar: next token TokOperator "<|>"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString ";"]
<< pConstrOrVar: next token TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "skipMany") []
<< expr dispatch: TokIdent "skipMany"
<< exprCore next token: TokIdent "skipMany"
<< atomBaseCore next token: TokIdent "skipMany"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
<< typeSigDecl: TokIdent "parseTypeCore"
<< typeSigDecl:2 TokSymbol "="
<< valueDecl: TokIdent "parseTypeCore"
<< pConstrOrVar: next token TokIdent "parseTypeCore"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "parseTypeCore") []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "skipMany"
<< pConstrOrVar: next token TokIdent "skipMany"
<< pConstrOrVar: next token TokIdent "symbol"
<< pConstrOrVar: next token TokString ";"
<< pConstrOrVar: next token TokOperator "<|>"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString ";"]
<< pConstrOrVar: next token TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "skipMany") []
<< expr dispatch: TokIdent "skipMany"
<< exprCore next token: TokIdent "skipMany"
<< atomBaseCore next token: TokIdent "skipMany"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
Just ([DeclModule "Parser.Type.TypeParser" (Just [ExportVar "parseType",ExportVar "parseForall",ExportVar "arrowType",ExportVar "typeApp",ExportVar "typeAtom",ExportVar "typeIdent",ExportVar "constraintP",ExportVar "constraintList",ExportVar "typeP"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type")),DeclFunGroup "parseType" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< parseType dispatch: ") (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PVar "TokVLBrace") []) (EApp (EVar "bracesV") (EVar "parseTypeCore")),CaseAlt (PApp (PVar "_") []) (EVar "parseTypeCore")])])) Nothing],DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type"))],[TokNewline,TokIdent "parseTypeCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipMany",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "t1",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseTypeCore: ",TokOperator "++",TokIdent "show",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "t1",TokSymbol ";",TokIdent "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "arrowType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t1",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokIdent "parseTypeCore",TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokIdent "maybe",TokIdent "t1",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "parensTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parensTuple",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "ts",TokSymbol "<-",TokIdent "parseTypeCore",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "toConstraint",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokIdent "other",TokSymbol "=",TokIdent "error",TokOperator "$",TokString "Invalid constraint form: ",TokOperator "++",TokIdent "show",TokIdent "other",TokNewline,TokIdent "typeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "typeTerm",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeTerm",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl",TokTypeIdent "TApp",TokIdent "f",TokIdent "args",TokVRBrace,TokNewline,TokIdent "typeTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "parens",TokIdent "parseTypeCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "tUnitType",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TVar",TokOperator "<$>",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "brackets",TokSymbol "(",TokTypeIdent "TList",TokOperator "<$>",TokIdent "parseTypeCore",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "parensTuple",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tUnitType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "tUnitType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TUnit",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constrainedType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "cs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "constraint",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokIdent "keyword",TokString "=>",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseForall",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "TForall",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline,TokIdent "constraint",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "cls",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "className",TokIdent "args",TokVRBrace,TokNewline,TokIdent "constraintList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokIdent "`sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "fmap",TokSymbol "(",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSymbol "=",TokIdent "try",TokIdent "forallType",TokOperator "<|>",TokIdent "typeAtom",TokNewline,TokIdent "forallType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Error.hs ===
-- Raw Source --
module TypeInference.Error where

import AST.Type (Type (..))
import TypeInference.Unify (UnifyError)

-- 型推論全体で使うエラー型
data InferError
  = InferUnboundVariable String
  | InferMismatch Type Type
  | InferUnifyError UnifyError
  | InferOther String
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "InferError",TokVLBrace,TokSymbol "=",TokTypeIdent "InferUnboundVariable",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferMismatch",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferUnifyError",TokTypeIdent "UnifyError",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferOther",TokTypeIdent "String",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.Error" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "UnifyError"]}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "InferUnboundVariable" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "InferMismatch" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokTypeIdent "UnifyError"
<< dataConstrNormal: "InferUnifyError" [TCon "UnifyError"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "InferOther" [TCon "String"]
<< declBody: return DeclData "InferError" [] [Constraint "InferUnboundVariable" [TCon "String"],Constraint "InferMismatch" [TCon "Type",TCon "Type"],Constraint "InferUnifyError" [TCon "UnifyError"],Constraint "InferOther" [TCon "String"]] ["Show","Eq"]
Just ([DeclModule "TypeInference.Error" Nothing,DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "UnifyError"]},DeclData "InferError" [] [Constraint "InferUnboundVariable" [TCon "String"],Constraint "InferMismatch" [TCon "Type",TCon "Type"],Constraint "InferUnifyError" [TCon "UnifyError"],Constraint "InferOther" [TCon "String"]] ["Show","Eq"]],[TokNewline])

=== Running: src/TypeInference/Infer/Core - 繧ｳ繝斐ｼ.hs ===
-- Raw Source --
module TypeInference.Infer
  ( InferError (..),
    inferExpr,
    inferDecl,
    inferProgram,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    applyEnv,
    emptyEnv,
    extendEnv,
    freeTypeVars,
    freeTypeVarsEnv,
    generalize,
    instantiate,
    lookupEnv,
  )
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr の返り値：型と代入
type InferResult = (Subst, Type)

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

inferBindings :: TypeEnv -> [(Pattern, Expr)] -> Either InferError (Subst, TypeEnv)
inferBindings env [] = Right (emptySubst, emptyEnv)
inferBindings env ((pat, expr) : rest) = do
  -- パターン推論
  (sPat, envPat, tPat) <- inferPattern pat

  -- 右辺の推論
  (sExpr, tExpr) <- inferExpr (applyEnv sPat env) expr

  -- パターン型と右辺型を unify（エラー型を変換）
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su

  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat

  -- 残りの束縛
  (sRest, envRest) <- inferBindings (applyEnv s env) rest

  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest

  Right (sFinal, envFinal)

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s

    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

-- 式の型推論（まだ中身は空）
-- inferExpr :: TypeEnv -> Expr -> Either InferError InferResult
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (ELetBlock binds body) = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

-- SQL
inferExpr env (ESQL _ params) = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, tParam) <- inferExpr envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)

-- 1. 変数
inferExpr env (EVar x) =
  case lookupEnv env x of
    Nothing -> Left (InferUnboundVariable x)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- 2. 整数リテラル
inferExpr env (EInt _) =
  Right (emptySubst, TCon "Int")
-- 3. ブールリテラル
inferExpr env (EBool _) =
  Right (emptySubst, TCon "Bool")
-- 4. 文字列リテラル
inferExpr env (EString _) =
  Right (emptySubst, TCon "String")
-- 5. 関数適用（HM 型推論の核）
inferExpr env (EApp e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ ->
      Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)
-- 6. ラムダ式
inferExpr env (ELam pat body) = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-- 7. let 式
inferExpr env (ELet pat e1 e2) = do
  -- パターン推論
  (sPat, envPat, tPat) <- inferPattern pat
  -- e1 の推論
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  -- パターン型と e1 の型を unify
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  -- ここまでの置換をまとめる
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  -- パターンから得た環境を適用
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  -- e2 の推論
  (s3, t2) <- inferExpr env' e2
  -- 全体の置換
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)
-- 8. if 式
inferExpr env (EIf cond eThen eElse) = do
  (s1, tCond) <- inferExpr env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExpr env1 eThen
  (s3, tElse) <- inferExpr (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-- 9. case 式
inferExpr env (ECase scrut branches) = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results
-- 10. タプル
inferExpr env (ETuple es) = do
  inferred <- mapM (inferExpr env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))
-- 11. リスト
inferExpr env (EList es) = do
  inferred <- mapM (inferExpr env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))
-- Where
inferExpr env (EWhere e binds) = do
  -- 本体を推論
  (s1, t1) <- inferExpr env e
  -- 本体のスコープを使って where の定義を推論
  env' <- foldM inferBinding (applyEnv s1 env) binds
  -- where の定義はスコープに影響しないので、型は t1 のまま返す
  return (s1, t1)
-- do
inferExpr env (EDo stmts) = inferDo env stmts
inferExpr env (EBinOp op e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)

inferDo :: TypeEnv -> [Stmt] -> Either InferError (Subst, Type)
inferDo env [] =
  Left (InferOther "Empty do block")
inferDo env [ExprStmt e] =
  inferExpr env e -- 最後の式の型が do の型
inferDo env (stmt : rest) = do
  (s1, env1) <- inferStmt env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt :: TypeEnv -> Stmt -> Either InferError (Subst, TypeEnv)
inferStmt env (ExprStmt e) = do
  (s, _) <- inferExpr env e
  return (s, env)
inferStmt env (LetStmt binds) =
  inferBindings env binds
inferStmt env (Bind pat e) = do
  -- 式の型を推論
  (s1, t1) <- inferExpr env e

  -- パターンの型を推論
  (s2, env2, tPat) <- inferPattern pat

  -- unify のエラーを InferError に変換
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- 置換を合成
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- 環境に適用
  let env' = applyEnv s env2

  return (s, env')

inferBinding :: TypeEnv -> (Pattern, Expr) -> Either InferError TypeEnv
inferBinding env (pat, expr) = do
  -- 式の型を推論
  (s1, t1) <- inferExpr env expr

  -- パターンの型を推論
  (s2, env2, tPat) <- inferPattern pat

  -- unify のエラーを InferError に変換
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- 置換を合成
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- 環境に置換を適用
  let env' = applyEnv s env2

  return env'

-- 宣言の型推論（まだ骨格だけ）
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats body -> do
    -- パターンごとに型推論
    (sPats, envPats, argTypes) <- inferPatterns pats

    -- パターンで拡張した環境で body を推論
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body

    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)

    Right (extendEnv env name scheme, s)
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)

inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- 仮の型を環境に入れる（再帰対応）
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)

  -- 各 clause の型を推論
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]

  -- unify して 1 つの型にまとめる
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)

  -- generalize
  let scheme = generalizeInfer env finalType

  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats

  -- ★ 関数型をここで作る
  let funType = foldr TArrow tBody argTypes

  Right (s, funType)

freshVar :: Int -> Type
freshVar n = TVar ("t" ++ show n)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- 変数パターン
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- 単一変数の PApp パターン（あなたのパーサーが生成する形）
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- ★ 追加：PApp の一般形（引数なし）
  PApp p [] -> inferPattern p
  {-}
  -- 変数パターン
  PVar v ->
    let t = TVar ("t_" ++ v)
        env = extendEnv emptyEnv v (Forall [] t)
     in Right (emptySubst, env, t)
     -}
  -- 整数リテラル
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ワイルドカード
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- リストパターン [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- 全要素の型を t0 と unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- タプルパターン (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- コンストラクタパターン Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons パターン (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As パターン x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokVLBrace,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sExpr",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "CaseAlt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sPat",TokIdent "`composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ESQL",TokIdent "_",TokIdent "params",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "x",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EInt",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBool",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EString",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokIdent "`composeSubst`",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSymbol "<-",TokIdent "foldM",TokIdent "inferBinding",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "=",TokIdent "inferDo",TokIdent "env",TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "opType",TokSymbol "=",TokTypeIdent "TArrow",TokIdent "t1",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinEnv",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tOp",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokIdent "opType",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferDo",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Stmt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokIdent "body",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshVar",TokSymbol "::",TokTypeIdent "Int",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokIdent "n",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "_",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "InferError"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferDecl"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer" (Just [ExportType "InferError" True,ExportVar "inferExpr",ExportVar "inferDecl",ExportVar "inferProgram"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer" (Just [ExportType "InferError" True,ExportVar "inferExpr",ExportVar "inferDecl",ExportVar "inferProgram"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sExpr",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "CaseAlt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sPat",TokIdent "`composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ESQL",TokIdent "_",TokIdent "params",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "x",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EInt",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBool",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EString",TokIdent "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokIdent "`composeSubst`",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSymbol "<-",TokIdent "foldM",TokIdent "inferBinding",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "=",TokIdent "inferDo",TokIdent "env",TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "opType",TokSymbol "=",TokTypeIdent "TArrow",TokIdent "t1",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinEnv",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tOp",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokIdent "opType",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferDo",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Stmt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokIdent "body",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshVar",TokSymbol "::",TokTypeIdent "Int",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokIdent "n",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "_",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Core.hs ===
-- Raw Source --
module TypeInference.Infer.Core
  ( counter,
    builtinPatternEnv,
    builtinOps,
    builtinEnv,
    generalizeInfer,
    groupDecls,
    unifyMany,
    mergeEnvs,
    freshTypeVar,
    InferResult,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr の返り値：型と代入
type InferResult = (Subst, Type)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _ _ _) <- decls]

--  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokVLBrace,TokSymbol "(",TokIdent "counter",TokSymbol ",",TokIdent "builtinPatternEnv",TokSymbol ",",TokIdent "builtinOps",TokSymbol ",",TokIdent "builtinEnv",TokSymbol ",",TokIdent "generalizeInfer",TokSymbol ",",TokIdent "groupDecls",TokSymbol ",",TokIdent "unifyMany",TokSymbol ",",TokIdent "mergeEnvs",TokSymbol ",",TokIdent "freshTypeVar",TokSymbol ",",TokTypeIdent "InferResult",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "_",TokIdent "_",TokIdent "_",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "counter"
<< exportItem: next token=TokIdent "builtinPatternEnv"
<< exportItem: next token=TokIdent "builtinOps"
<< exportItem: next token=TokIdent "builtinEnv"
<< exportItem: next token=TokIdent "generalizeInfer"
<< exportItem: next token=TokIdent "groupDecls"
<< exportItem: next token=TokIdent "unifyMany"
<< exportItem: next token=TokIdent "mergeEnvs"
<< exportItem: next token=TokIdent "freshTypeVar"
<< exportItem: next token=TokTypeIdent "InferResult"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Core" (Just [ExportVar "counter",ExportVar "builtinPatternEnv",ExportVar "builtinOps",ExportVar "builtinEnv",ExportVar "generalizeInfer",ExportVar "groupDecls",ExportVar "unifyMany",ExportVar "mergeEnvs",ExportVar "freshTypeVar",ExportType "InferResult" False])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Core" (Just [ExportVar "counter",ExportVar "builtinPatternEnv",ExportVar "builtinOps",ExportVar "builtinEnv",ExportVar "generalizeInfer",ExportVar "groupDecls",ExportVar "unifyMany",ExportVar "mergeEnvs",ExportVar "freshTypeVar",ExportType "InferResult" False]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokIdent "_",TokIdent "_",TokIdent "_",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprApp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprApp (inferApp) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferApp inferExprFn env e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  tv <- freshTypeVar
  s3 <- case unify (apply s2 t1) (TFun t2 tv) of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s tv)

{-}
-- TypeInference/Infer/Expr/ExprApp.hs
module TypeInference.Infer.Expr.ExprApp
  ( inferApp,
    inferLam,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp :: TypeEnv -> Expr -> Expr -> Either InferError (Subst, Type)
inferApp env e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ -> Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)

inferLam :: TypeEnv -> Pattern -> Expr -> Either InferError (Subst, Type)
inferLam env pat body = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferApp",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferApp",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferApp"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprApp" (Just [ExportVar "inferApp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferApp"
<< decl parser called
<< decl dispatch: TokIdent "inferApp"
<< funDecl: next token=TokIdent "inferApp"
<< funClause: next token=TokIdent "inferApp"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferApp"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parsed type signature: inferApp :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< returning DeclTypeSig: DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< declBody: return DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< decl next token: TokIdent "inferApp"
<< decl parser called
<< decl dispatch: TokIdent "inferApp"
<< funDecl: next token=TokIdent "inferApp"
<< funClause: next token=TokIdent "inferApp"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e1"
<< parsed pattern: PVar "e1"
<< pPattern: next token TokIdent "e2"
<< pConstrOrVar: next token TokIdent "e2"
<< parsed pattern: PVar "e2"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "e1",PVar "e2"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pConstrOrVar: next token TokIdent "s3"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "inferApp"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferApp"
<< pConstrOrVar: next token TokIdent "inferApp"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferApp") [PVar "inferExprFn",PVar "env",PVar "e1",PVar "e2"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pConstrOrVar: next token TokIdent "s3"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprApp" (Just [ExportVar "inferApp"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))],[TokNewline,TokIdent "inferApp",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprBinOp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprBinOp (inferBinOp) where

import AST.Expr (BinOp (..), Expr (..))
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  BinOp ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferBinOp inferExprFn env op e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  let s12 = s2 `composeSubst` s1
  (arg1, arg2, result) <- case op of
    Add -> pure (TCon "Int", TCon "Int", TCon "Int")
    Sub -> pure (TCon "Int", TCon "Int", TCon "Int")
    Mul -> pure (TCon "Int", TCon "Int", TCon "Int")
    Div -> pure (TCon "Int", TCon "Int", TCon "Int")
    And -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Or -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Eq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Neq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Lt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Gt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Le -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Ge -> pure (TCon "Int", TCon "Int", TCon "Bool")
  s3 <- case unify (apply s12 t1) arg1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right sA -> case unify (apply sA (apply s12 t2)) (apply sA arg2) of
      Left uerr -> Left (InferUnifyError uerr)
      Right sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)

{-}
  s3 <-
    unify (apply s12 t1) arg1
      >>= \sA ->
        unify (apply sA (apply s12 t2)) (apply sA arg2)
          >>= \sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)
-}
{-}
-- TypeInference/Infer/Expr/ExprBinOp.hs
module TypeInference.Infer.Expr.ExprBinOp
  ( inferBinOp,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp :: TypeEnv -> String -> Expr -> Expr -> Either InferError (Subst, Type)
inferBinOp inferExpr env op e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferBinOp",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "BinOp",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinOp",TokIdent "inferExprFn",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "s12",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSymbol "<-",TokKeyword "case",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Add",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Neq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Lt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokIdent "arg1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sA",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sB",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "sB",TokIdent "`composeSubst`",TokIdent "sA",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferBinOp"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprBinOp" (Just [ExportVar "inferBinOp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferBinOp"
<< decl parser called
<< decl dispatch: TokIdent "inferBinOp"
<< funDecl: next token=TokIdent "inferBinOp"
<< funClause: next token=TokIdent "inferBinOp"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferBinOp"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferBinOp :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferBinOp"
<< decl parser called
<< decl dispatch: TokIdent "inferBinOp"
<< funDecl: next token=TokIdent "inferBinOp"
<< funClause: next token=TokIdent "inferBinOp"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "op"
<< pConstrOrVar: next token TokIdent "op"
<< parsed pattern: PVar "op"
<< pPattern: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e1"
<< parsed pattern: PVar "e1"
<< pPattern: next token TokIdent "e2"
<< pConstrOrVar: next token TokIdent "e2"
<< parsed pattern: PVar "e2"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "op",PVar "e1",PVar "e2"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "s12"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "s12") []
<< expr dispatch: TokIdent "s2"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokIdent "arg1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg1") []
<< pConstrOrVar: next token TokIdent "arg2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg2") []
<< pConstrOrVar: next token TokIdent "result"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "result") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "arg1") [],PApp (PVar "arg2") [],PApp (PVar "result") []]) []
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "arg1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg1") []
<< pConstrOrVar: next token TokIdent "arg2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg2") []
<< pConstrOrVar: next token TokIdent "result"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "result") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "arg1") [],PApp (PVar "arg2") [],PApp (PVar "result") []]) []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "op"
<< exprCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Add"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Add") []
<< caseAlt: next token TokArrow PApp (PVar "Add") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Sub"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Sub") []
<< caseAlt: next token TokArrow PApp (PVar "Sub") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Mul"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Mul") []
<< caseAlt: next token TokArrow PApp (PVar "Mul") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Div"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Div") []
<< caseAlt: next token TokArrow PApp (PVar "Div") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "And"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "And") []
<< caseAlt: next token TokArrow PApp (PVar "And") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Or"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Or") []
<< caseAlt: next token TokArrow PApp (PVar "Or") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Eq"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Eq") []
<< caseAlt: next token TokArrow PApp (PVar "Eq") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "pure"
<< pConstrOrVar: next token TokIdent "pure"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokString "Bool"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PString "Bool"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "pure") [PTuple [PApp (PVar "tv") [],PApp (PVar "tv") [],PApp (PVar "TCon") [PString "Bool"]]]
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokTypeIdent "Neq"
<< infixOp: next token TokTypeIdent "Neq"
<< pConstrOrVar: next token TokTypeIdent "Neq"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Neq") []
<< caseAlt: next token TokArrow PApp (PVar "Neq") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "pure"
<< pConstrOrVar: next token TokIdent "pure"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokString "Bool"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PString "Bool"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "pure") [PTuple [PApp (PVar "tv") [],PApp (PVar "tv") [],PApp (PVar "TCon") [PString "Bool"]]]
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokTypeIdent "Lt"
<< infixOp: next token TokTypeIdent "Lt"
<< pConstrOrVar: next token TokTypeIdent "Lt"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Lt") []
<< caseAlt: next token TokArrow PApp (PVar "Lt") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Gt"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Gt") []
<< caseAlt: next token TokArrow PApp (PVar "Gt") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Le"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Le") []
<< caseAlt: next token TokArrow PApp (PVar "Le") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Ge"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Ge") []
<< caseAlt: next token TokArrow PApp (PVar "Ge") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "s3"
<< infixOp: next token TokIdent "s3"
<< typeSigDecl: TokIdent "inferBinOp"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferBinOp"
<< pConstrOrVar: next token TokIdent "inferBinOp"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "op"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferBinOp") [PVar "inferExprFn",PVar "env",PVar "op",PVar "e1",PVar "e2"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "s12"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "s12") []
<< expr dispatch: TokIdent "s2"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokIdent "arg1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg1") []
<< pConstrOrVar: next token TokIdent "arg2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg2") []
<< pConstrOrVar: next token TokIdent "result"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "result") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "arg1") [],PApp (PVar "arg2") [],PApp (PVar "result") []]) []
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "arg1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg1") []
<< pConstrOrVar: next token TokIdent "arg2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg2") []
<< pConstrOrVar: next token TokIdent "result"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "result") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "arg1") [],PApp (PVar "arg2") [],PApp (PVar "result") []]) []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "op"
<< exprCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Add"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Add") []
<< caseAlt: next token TokArrow PApp (PVar "Add") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Sub"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Sub") []
<< caseAlt: next token TokArrow PApp (PVar "Sub") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Mul"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Mul") []
<< caseAlt: next token TokArrow PApp (PVar "Mul") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Div"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Div") []
<< caseAlt: next token TokArrow PApp (PVar "Div") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "And"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "And") []
<< caseAlt: next token TokArrow PApp (PVar "And") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Or"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Or") []
<< caseAlt: next token TokArrow PApp (PVar "Or") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Eq"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Eq") []
<< caseAlt: next token TokArrow PApp (PVar "Eq") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "pure"
<< pConstrOrVar: next token TokIdent "pure"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokString "Bool"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PString "Bool"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "pure") [PTuple [PApp (PVar "tv") [],PApp (PVar "tv") [],PApp (PVar "TCon") [PString "Bool"]]]
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokTypeIdent "Neq"
<< infixOp: next token TokTypeIdent "Neq"
<< pConstrOrVar: next token TokTypeIdent "Neq"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Neq") []
<< caseAlt: next token TokArrow PApp (PVar "Neq") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "pure"
<< pConstrOrVar: next token TokIdent "pure"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokString "Bool"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PString "Bool"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "pure") [PTuple [PApp (PVar "tv") [],PApp (PVar "tv") [],PApp (PVar "TCon") [PString "Bool"]]]
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "tv"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokTypeIdent "Lt"
<< infixOp: next token TokTypeIdent "Lt"
<< pConstrOrVar: next token TokTypeIdent "Lt"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Lt") []
<< caseAlt: next token TokArrow PApp (PVar "Lt") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Gt"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Gt") []
<< caseAlt: next token TokArrow PApp (PVar "Gt") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Le"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Le") []
<< caseAlt: next token TokArrow PApp (PVar "Le") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Ge"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Ge") []
<< caseAlt: next token TokArrow PApp (PVar "Ge") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "pure"
<< exprCore next token: TokIdent "pure"
<< atomBaseCore next token: TokIdent "pure"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "s3"
<< infixOp: next token TokIdent "s3"
Just ([DeclModule "TypeInference.Infer.Expr.ExprBinOp" (Just [ExportVar "inferBinOp"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))],[TokNewline,TokIdent "inferBinOp",TokIdent "inferExprFn",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "s12",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSymbol "<-",TokKeyword "case",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Add",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Neq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Lt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokIdent "arg1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sA",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sB",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "sB",TokIdent "`composeSubst`",TokIdent "sA",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprCase.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprCase (inferCase) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [CaseAlt] ->
  Either InferError (Subst, Type)
inferCase inferExprFn env scrut branches = do
  (sScrut, tScrut) <- inferExprFn env scrut
  results <- mapM (inferBranch inferExprFn env tScrut sScrut) branches
  unifyManyExpr results

inferBranch ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Type ->
  Subst ->
  CaseAlt ->
  Either InferError (Subst, Type)
inferBranch inferExprFn env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = sUnify `composeSubst` sPat `composeSubst` sScrut
  inferExprFn (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right su -> Right su
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)

{-}
-- TypeInference/Infer/Expr/ExprCase.hs
module TypeInference.Infer.Expr.ExprCase
  ( inferCase,
    inferBranch,
    unifyManyExpr,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase :: TypeEnv -> Expr -> [CaseAlt] -> Either InferError (Subst, Type)
inferCase inferExpr env scrut branches = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s
    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferCase",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferCase",TokIdent "inferExprFn",TokIdent "env",TokIdent "scrut",TokIdent "branches",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Type",TokArrow,TokSymbol ";",TokTypeIdent "Subst",TokArrow,TokSymbol ";",TokTypeIdent "CaseAlt",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sPat",TokIdent "`composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokNewline,TokIdent "unifyManyExpr",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokIdent "xs",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sU",TokIdent "`composeSubst`",TokIdent "sNext",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferCase"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprCase" (Just [ExportVar "inferCase"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferCase"
<< decl parser called
<< decl dispatch: TokIdent "inferCase"
<< funDecl: next token=TokIdent "inferCase"
<< funClause: next token=TokIdent "inferCase"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferCase"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "CaseAlt"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parsed type signature: inferCase :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< returning DeclTypeSig: DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< declBody: return DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< decl next token: TokIdent "inferCase"
<< decl parser called
<< decl dispatch: TokIdent "inferCase"
<< funDecl: next token=TokIdent "inferCase"
<< funClause: next token=TokIdent "inferCase"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "scrut"
<< pConstrOrVar: next token TokIdent "scrut"
<< parsed pattern: PVar "scrut"
<< pPattern: next token TokIdent "branches"
<< pConstrOrVar: next token TokIdent "branches"
<< parsed pattern: PVar "branches"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "scrut",PVar "branches"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "sScrut"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sScrut") []
<< pConstrOrVar: next token TokIdent "tScrut"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tScrut") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "results"
<< pConstrOrVar: next token TokIdent "results"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "results") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "branches"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "unifyManyExpr"
<< pConstrOrVar: next token TokIdent "unifyManyExpr"
<< pConstrOrVar: next token TokIdent "results"
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "unifyManyExpr") [PVar "results"]
<< expr dispatch: TokIdent "unifyManyExpr"
<< exprCore next token: TokIdent "unifyManyExpr"
<< atomBaseCore next token: TokIdent "unifyManyExpr"
<< atomBaseCore next token: TokIdent "results"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "inferBranch"
<< infixOp: next token TokIdent "inferBranch"
<< whereBlock: next tokenTokIdent "inferBranch"
<< funClauseWithName: next token=TokIdent "inferBranch"
<< declBody: return DeclFunGroup "inferCase" [FunClause [PVar "inferExprFn",PVar "env",PVar "scrut",PVar "branches"] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "scrut")),Bind (PApp (PVar "results") []) (EApp (EApp (EVar "mapM") (EApp (EApp (EApp (EApp (EVar "inferBranch") (EVar "inferExprFn")) (EVar "env")) (EVar "tScrut")) (EVar "sScrut"))) (EVar "branches")),ExprStmt (EApp (EVar "unifyManyExpr") (EVar "results"))])) Nothing]
<< decl next token: TokIdent "inferBranch"
<< decl parser called
<< decl dispatch: TokIdent "inferBranch"
<< funDecl: next token=TokIdent "inferBranch"
<< funClause: next token=TokIdent "inferBranch"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferBranch"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferBranch :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferBranch"
<< decl parser called
<< decl dispatch: TokIdent "inferBranch"
<< funDecl: next token=TokIdent "inferBranch"
<< funClause: next token=TokIdent "inferBranch"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "tScrut"
<< pConstrOrVar: next token TokIdent "tScrut"
<< parsed pattern: PVar "tScrut"
<< pPattern: next token TokIdent "sScrut"
<< pConstrOrVar: next token TokIdent "sScrut"
<< parsed pattern: PVar "sScrut"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "CaseAlt"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "expr"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "CaseAlt") [PVar "pat",PVar "expr"]
<< parsed pattern: PApp (PVar "CaseAlt") [PVar "pat",PVar "expr"]
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "tScrut",PVar "sScrut",PApp (PVar "CaseAlt") [PVar "pat",PVar "expr"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "sPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pConstrOrVar: next token TokIdent "envPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sUnify"
<< pConstrOrVar: next token TokIdent "sUnify"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sUnify") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "s"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "s"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "inferBranch"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferBranch"
<< pConstrOrVar: next token TokIdent "inferBranch"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "tScrut"
<< pConstrOrVar: next token TokIdent "sScrut"
<< pConstrOrVar: next token TokTypeIdent "CaseAlt"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "expr"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "CaseAlt") [PVar "pat",PVar "expr"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferBranch") [PVar "inferExprFn",PVar "env",PVar "tScrut",PVar "sScrut",PApp (PVar "CaseAlt") [PVar "pat",PVar "expr"]]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "sPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pConstrOrVar: next token TokIdent "envPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sUnify"
<< pConstrOrVar: next token TokIdent "sUnify"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sUnify") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "s"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "s"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprCase" (Just [ExportVar "inferCase"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))),DeclFunGroup "inferCase" [FunClause [PVar "inferExprFn",PVar "env",PVar "scrut",PVar "branches"] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "scrut")),Bind (PApp (PVar "results") []) (EApp (EApp (EVar "mapM") (EApp (EApp (EApp (EApp (EVar "inferBranch") (EVar "inferExprFn")) (EVar "env")) (EVar "tScrut")) (EVar "sScrut"))) (EVar "branches")),ExprStmt (EApp (EVar "unifyManyExpr") (EVar "results"))])) Nothing],DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))],[TokNewline,TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sPat",TokIdent "`composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokNewline,TokIdent "unifyManyExpr",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokIdent "xs",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sU",TokIdent "`composeSubst`",TokIdent "sNext",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDispatch.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDispatch (inferExpr) where

import AST.Expr
import AST.Type
import AST.Type (Type (..)) -- これで TFun などのコンストラクタが使えるようになる
import TypeInference.Error
import TypeInference.Infer.Expr.ExprApp (inferApp)
import TypeInference.Infer.Expr.ExprBinOp (inferBinOp)
import TypeInference.Infer.Expr.ExprCase (inferCase)
import TypeInference.Infer.Expr.ExprDo (inferDo)
import TypeInference.Infer.Expr.ExprIf (inferIf)
import TypeInference.Infer.Expr.ExprLet (inferLet, inferLetBlock, inferWhere)
import TypeInference.Infer.Expr.ExprLiteral (inferBool, inferInt, inferList, inferString, inferTuple)
import TypeInference.Infer.Expr.ExprSQL (inferSQL)
import TypeInference.Subst
import TypeInference.TypeEnv

-- 他の構文モジュールもここに import
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (EVar name) =
  case lookupEnv env name of
    Nothing -> Left (InferUnboundVariable name)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- AST で定義された型で分岐 ここが欠損すると型推論ができなくなる
inferExpr env expr = case expr of
  ELet pat e1 e2 -> inferLet inferExpr env pat e1 e2
  ELetBlock binds body -> inferLetBlock inferExpr env binds body
  EWhere e binds -> inferWhere inferExpr env e binds
  EIf c t f -> inferIf inferExpr env c t f
  EDo stmts -> inferDo inferExpr env stmts
  ECase scrut alts -> inferCase inferExpr env scrut alts
  EApp e1 e2 -> inferApp inferExpr env e1 e2
  EBinOp op e1 e2 -> inferBinOp inferExpr env op e1 e2
  -- リテラル
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple inferExpr env es
  EList es -> inferList inferExpr env es
  -- 拡張タイプ SQL
  ESQL _ params -> inferSQL inferExpr env params

{-}
  ELetBlock binds body -> inferLetBlock env binds body
  ELet pat e1 e2 -> inferLet env pat e1 e2
  EWhere e binds -> inferWhere env e binds
  ECase scrut alts -> inferCase env scrut alts
  EApp e1 e2 -> inferApp env e1 e2
  ELam pat body -> inferLam env pat body
  EDo stmts -> inferDo env stmts
  EBinOp op e1 e2 -> inferBinOp env op e1 e2
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple env es
  EList es -> inferList env es
  ESQL _ params -> inferSQL env params
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSymbol "(",TokIdent "inferDo",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSymbol "(",TokIdent "inferIf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSymbol "(",TokIdent "inferBool",TokSymbol ",",TokIdent "inferInt",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "name",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "name",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol "=",TokKeyword "case",TokIdent "expr",TokKeyword "of",TokVLBrace,TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferLet",TokIdent "inferExpr",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokArrow,TokIdent "inferLetBlock",TokIdent "inferExpr",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokArrow,TokIdent "inferWhere",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokIdent "c",TokIdent "t",TokIdent "f",TokArrow,TokIdent "inferIf",TokIdent "inferExpr",TokIdent "env",TokIdent "c",TokIdent "t",TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokIdent "stmts",TokArrow,TokIdent "inferDo",TokIdent "inferExpr",TokIdent "env",TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokArrow,TokIdent "inferCase",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferApp",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferBinOp",TokIdent "inferExpr",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokIdent "_",TokArrow,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokIdent "_",TokArrow,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokIdent "_",TokArrow,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokIdent "es",TokArrow,TokIdent "inferTuple",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokIdent "es",TokArrow,TokIdent "inferList",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokIdent "_",TokIdent "params",TokArrow,TokIdent "inferSQL",TokIdent "inferExpr",TokIdent "env",TokIdent "params",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprDispatch" (Just [ExportVar "inferExpr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprApp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferApp"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprBinOp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBinOp"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprCase", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferCase"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprDo", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferDo"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprIf", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferIf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferLet",ImportVar "inferLetBlock",ImportVar "inferWhere"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLiteral", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBool",ImportVar "inferInt",ImportVar "inferList",ImportVar "inferString",ImportVar "inferTuple"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprSQL", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferSQL"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferExpr"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "TypeEnv"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parsed type signature: inferExpr :: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< returning DeclTypeSig: DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< declBody: return DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "EVar"
<< pConstrOrVar: next token TokIdent "name"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "EVar") [PVar "name"]
<< parsed pattern: PApp (PVar "EVar") [PVar "name"]
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "env",PApp (PVar "EVar") [PVar "name"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "lookupEnv"
<< exprCore next token: TokIdent "lookupEnv"
<< atomBaseCore next token: TokIdent "lookupEnv"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Nothing"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Nothing") []
<< caseAlt: next token TokArrow PApp (PVar "Nothing") []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Just"
<< pConstrOrVar: next token TokIdent "sigma"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Just") [PVar "sigma"]
<< caseAlt: next token TokArrow PApp (PVar "Just") [PVar "sigma"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "instantiate"
<< exprCore next token: TokIdent "instantiate"
<< atomBaseCore next token: TokIdent "instantiate"
<< atomBaseCore next token: TokIdent "sigma"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "emptySubst"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "emptySubst") []
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "emptySubst") [],PApp (PVar "t") []]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferExpr"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "expr"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "env") [PVar "expr"]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "ELet"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ELetBlock"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokIdent "body"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt: next token TokArrow PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EWhere"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt: next token TokArrow PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EIf"
<< pConstrOrVar: next token TokIdent "c"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "f"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt: next token TokArrow PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EDo"
<< pConstrOrVar: next token TokIdent "stmts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt: next token TokArrow PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ECase"
<< pConstrOrVar: next token TokIdent "scrut"
<< pConstrOrVar: next token TokIdent "alts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt: next token TokArrow PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EApp"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EBinOp"
<< pConstrOrVar: next token TokIdent "op"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< declBody: return DeclFunGroup "inferExpr" [FunClause [PVar "env",PApp (PVar "EVar") [PVar "name"]] Nothing (Just (ECase (EApp (EApp (EVar "lookupEnv") (EVar "env")) (EVar "name")) [CaseAlt (PApp (PVar "Nothing") []) (EApp (EVarType "Left") (EApp (EVarType "InferUnboundVariable") (EVar "name"))),CaseAlt (PApp (PVar "Just") [PVar "sigma"]) (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "instantiate") (EVar "sigma")),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EVar "t"]))])])) Nothing]
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "expr"
<< pConstrOrVar: next token TokIdent "expr"
<< parsed pattern: PVar "expr"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "env",PVar "expr"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "ELet"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ELetBlock"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokIdent "body"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt: next token TokArrow PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EWhere"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt: next token TokArrow PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EIf"
<< pConstrOrVar: next token TokIdent "c"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "f"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt: next token TokArrow PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EDo"
<< pConstrOrVar: next token TokIdent "stmts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt: next token TokArrow PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ECase"
<< pConstrOrVar: next token TokIdent "scrut"
<< pConstrOrVar: next token TokIdent "alts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt: next token TokArrow PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EApp"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EBinOp"
<< pConstrOrVar: next token TokIdent "op"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
<< typeSigDecl: TokIdent "inferExpr"
<< typeSigDecl:2 TokIdent "env"
<< valueDecl: TokIdent "inferExpr"
<< pConstrOrVar: next token TokIdent "inferExpr"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "expr"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExpr") [PVar "env",PVar "expr"]
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "ELet"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "ELet") [PVar "pat",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ELetBlock"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokIdent "body"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt: next token TokArrow PApp (PVar "ELetBlock") [PVar "binds",PVar "body"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EWhere"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt: next token TokArrow PApp (PVar "EWhere") [PVar "e",PVar "binds"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EIf"
<< pConstrOrVar: next token TokIdent "c"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "f"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt: next token TokArrow PApp (PVar "EIf") [PVar "c",PVar "t",PVar "f"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EDo"
<< pConstrOrVar: next token TokIdent "stmts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt: next token TokArrow PApp (PVar "EDo") [PVar "stmts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "ECase"
<< pConstrOrVar: next token TokIdent "scrut"
<< pConstrOrVar: next token TokIdent "alts"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt: next token TokArrow PApp (PVar "ECase") [PVar "scrut",PVar "alts"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EApp"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EApp") [PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "EBinOp"
<< pConstrOrVar: next token TokIdent "op"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt: next token TokArrow PApp (PVar "EBinOp") [PVar "op",PVar "e1",PVar "e2"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokSymbol ";"
Just ([DeclModule "TypeInference.Infer.Expr.ExprDispatch" (Just [ExportVar "inferExpr"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprApp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferApp"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprBinOp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBinOp"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprCase", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferCase"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprDo", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferDo"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprIf", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferIf"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferLet",ImportVar "inferLetBlock",ImportVar "inferWhere"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLiteral", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBool",ImportVar "inferInt",ImportVar "inferList",ImportVar "inferString",ImportVar "inferTuple"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprSQL", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferSQL"]},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))),DeclFunGroup "inferExpr" [FunClause [PVar "env",PApp (PVar "EVar") [PVar "name"]] Nothing (Just (ECase (EApp (EApp (EVar "lookupEnv") (EVar "env")) (EVar "name")) [CaseAlt (PApp (PVar "Nothing") []) (EApp (EVarType "Left") (EApp (EVarType "InferUnboundVariable") (EVar "name"))),CaseAlt (PApp (PVar "Just") [PVar "sigma"]) (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "instantiate") (EVar "sigma")),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EVar "t"]))])])) Nothing]],[TokNewline,TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol "=",TokKeyword "case",TokIdent "expr",TokKeyword "of",TokVLBrace,TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferLet",TokIdent "inferExpr",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokArrow,TokIdent "inferLetBlock",TokIdent "inferExpr",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokArrow,TokIdent "inferWhere",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokIdent "c",TokIdent "t",TokIdent "f",TokArrow,TokIdent "inferIf",TokIdent "inferExpr",TokIdent "env",TokIdent "c",TokIdent "t",TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokIdent "stmts",TokArrow,TokIdent "inferDo",TokIdent "inferExpr",TokIdent "env",TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokArrow,TokIdent "inferCase",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferApp",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferBinOp",TokIdent "inferExpr",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokIdent "_",TokArrow,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokIdent "_",TokArrow,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokIdent "_",TokArrow,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokIdent "es",TokArrow,TokIdent "inferTuple",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokIdent "es",TokArrow,TokIdent "inferList",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokIdent "_",TokIdent "params",TokArrow,TokIdent "inferSQL",TokIdent "inferExpr",TokIdent "env",TokIdent "params",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDo.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDo (inferDo, inferStmt) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprLet (inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferDo ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Stmt] ->
  Either InferError (Subst, Type)
inferDo inferExprFn env [] =
  Left (InferOther "Empty do block")
inferDo inferExprFn env [ExprStmt e] =
  inferExprFn env e
inferDo inferExprFn env (stmt : rest) = do
  (s1, env1) <- inferStmt inferExprFn env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo inferExprFn env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Stmt ->
  Either InferError (Subst, TypeEnv)
inferStmt inferExprFn env (ExprStmt e) = do
  (s, _) <- inferExprFn env e
  return (s, env)
inferStmt inferExprFn env (LetStmt binds) =
  inferBindings inferExprFn env binds
inferStmt inferExprFn env (Bind pat e) = do
  (s1, t1) <- inferExprFn env e
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return (s, env')


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSymbol "(",TokIdent "inferDo",TokSymbol ",",TokIdent "inferStmt",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "(",TokIdent "inferBindings",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferDo",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Stmt",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferDo"
<< exportItem: next token=TokIdent "inferStmt"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprDo" (Just [ExportVar "inferDo",ExportVar "inferStmt"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBindings"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferDo"
<< decl parser called
<< decl dispatch: TokIdent "inferDo"
<< funDecl: next token=TokIdent "inferDo"
<< funClause: next token=TokIdent "inferDo"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferDo"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Stmt"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferDo :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferDo"
<< decl parser called
<< decl dispatch: TokIdent "inferDo"
<< funDecl: next token=TokIdent "inferDo"
<< funClause: next token=TokIdent "inferDo"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferDo"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokTypeIdent "ExprStmt"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokSymbol "]"
<< pattern1: (pAs <|> makeCons)PApp (PVar "ExprStmt") [PVar "e"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PVar "ExprStmt") [PVar "e"]]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferDo"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "stmt"
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "env1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "env1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "env1") []]) []
<< expr dispatch: TokIdent "inferStmt"
<< exprCore next token: TokIdent "inferStmt"
<< atomBaseCore next token: TokIdent "inferStmt"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmt"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "env'"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "env'") []
<< expr dispatch: TokIdent "applyEnv"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env'"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "inferStmt"
<< infixOp: next token TokIdent "inferStmt"
<< whereBlock: next tokenTokIdent "inferStmt"
<< funClauseWithName: next token=TokIdent "inferStmt"
<< declBody: return DeclFunGroup "inferDo" [FunClause [PVar "inferExprFn",PVar "env",PList []] Nothing (Just (EApp (EVarType "Left") (EApp (EVarType "InferOther") (EString "Empty do block")))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PVar "ExprStmt") [PVar "e"]]]] Nothing (Just (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e"))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "env1") []]) []) (EApp (EApp (EApp (EVar "inferStmt") (EVar "inferExprFn")) (EVar "env")) (EVar "stmt")),LetStmt [(PApp (PVar "env'") [],EApp (EApp (EVar "applyEnv") (EVar "s1")) (EVar "env1"))],Bind (PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []) (EApp (EApp (EApp (EVar "inferDo") (EVar "inferExprFn")) (EVar "env'")) (EVar "rest")),ExprStmt (EReturn (ETuple [EApp (EApp (EVar "s2") (EVar "`composeSubst`")) (EVar "s1"),EVar "t2"]))])) Nothing]
<< decl next token: TokIdent "inferStmt"
<< decl parser called
<< decl dispatch: TokIdent "inferStmt"
<< funDecl: next token=TokIdent "inferStmt"
<< funClause: next token=TokIdent "inferStmt"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferStmt"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "TypeEnv"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"])
<< parseTypeCore: TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"]))))
<< parsed type signature: inferStmt :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"]))))
<< returning DeclTypeSig: DeclTypeSig "inferStmt" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"])))))
<< declBody: return DeclTypeSig "inferStmt" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"])))))
<< decl next token: TokIdent "inferStmt"
<< decl parser called
<< decl dispatch: TokIdent "inferStmt"
<< funDecl: next token=TokIdent "inferStmt"
<< funClause: next token=TokIdent "inferStmt"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "ExprStmt"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "ExprStmt") [PVar "e"]
<< parsed pattern: PApp (PVar "ExprStmt") [PVar "e"]
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PApp (PVar "ExprStmt") [PVar "e"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s") [],PApp (PVar "_") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "inferStmt"
<< infixOp: next token TokIdent "inferStmt"
<< whereBlock: next tokenTokIdent "inferStmt"
<< funClauseWithName: next token=TokIdent "inferStmt"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokTypeIdent "LetStmt"
<< pConstrOrVar: next token TokIdent "binds"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "LetStmt") [PVar "binds"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PApp (PVar "LetStmt") [PVar "binds"]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokIdent "inferBindings"
<< exprCore next token: TokIdent "inferBindings"
<< atomBaseCore next token: TokIdent "inferBindings"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferStmt"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokTypeIdent "Bind"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "Bind") [PVar "pat",PVar "e"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PApp (PVar "Bind") [PVar "pat",PVar "e"]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "env2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "env2") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "env2") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pConstrOrVar: next token TokIdent "s3"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "s"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "s"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< declBody: return DeclFunGroup "inferStmt" [FunClause [PVar "inferExprFn",PVar "env",PApp (PVar "ExprStmt") [PVar "e"]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "_") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e")),ExprStmt (EReturn (ETuple [EVar "s",EVar "env"]))])) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PApp (PVar "LetStmt") [PVar "binds"]]] Nothing (Just (EApp (EApp (EApp (EVar "inferBindings") (EVar "inferExprFn")) (EVar "env")) (EVar "binds"))) Nothing]
<< decl next token: TokIdent "inferStmt"
<< decl parser called
<< decl dispatch: TokIdent "inferStmt"
<< funDecl: next token=TokIdent "inferStmt"
<< funClause: next token=TokIdent "inferStmt"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "Bind"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "Bind") [PVar "pat",PVar "e"]
<< parsed pattern: PApp (PVar "Bind") [PVar "pat",PVar "e"]
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PApp (PVar "Bind") [PVar "pat",PVar "e"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "env2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "env2") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "env2") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pConstrOrVar: next token TokIdent "s3"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "s"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "s"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "inferStmt"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferStmt"
<< pConstrOrVar: next token TokIdent "inferStmt"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokTypeIdent "Bind"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "Bind") [PVar "pat",PVar "e"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferStmt") [PVar "inferExprFn",PVar "env",PApp (PVar "Bind") [PVar "pat",PVar "e"]]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pConstrOrVar: next token TokIdent "env2"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "env2") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "env2") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pConstrOrVar: next token TokIdent "s3"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "s"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "s"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprDo" (Just [ExportVar "inferDo",ExportVar "inferStmt"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBindings"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferDo" [FunClause [PVar "inferExprFn",PVar "env",PList []] Nothing (Just (EApp (EVarType "Left") (EApp (EVarType "InferOther") (EString "Empty do block")))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PVar "ExprStmt") [PVar "e"]]]] Nothing (Just (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e"))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "env1") []]) []) (EApp (EApp (EApp (EVar "inferStmt") (EVar "inferExprFn")) (EVar "env")) (EVar "stmt")),LetStmt [(PApp (PVar "env'") [],EApp (EApp (EVar "applyEnv") (EVar "s1")) (EVar "env1"))],Bind (PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []) (EApp (EApp (EApp (EVar "inferDo") (EVar "inferExprFn")) (EVar "env'")) (EVar "rest")),ExprStmt (EReturn (ETuple [EApp (EApp (EVar "s2") (EVar "`composeSubst`")) (EVar "s1"),EVar "t2"]))])) Nothing],DeclTypeSig "inferStmt" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Stmt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "TypeEnv"]))))),DeclFunGroup "inferStmt" [FunClause [PVar "inferExprFn",PVar "env",PApp (PVar "ExprStmt") [PVar "e"]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "_") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e")),ExprStmt (EReturn (ETuple [EVar "s",EVar "env"]))])) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PApp (PVar "LetStmt") [PVar "binds"]]] Nothing (Just (EApp (EApp (EApp (EVar "inferBindings") (EVar "inferExprFn")) (EVar "env")) (EVar "binds"))) Nothing]],[TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprIf.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprIf
  ( inferIf,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferIf ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)

{-}
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokVLBrace,TokSymbol "(",TokIdent "inferIf",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferIf",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferIf",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokIdent "`composeSubst`",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferIf"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprIf" (Just [ExportVar "inferIf"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferIf"
<< decl parser called
<< decl dispatch: TokIdent "inferIf"
<< funDecl: next token=TokIdent "inferIf"
<< funClause: next token=TokIdent "inferIf"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferIf"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferIf :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferIf"
<< decl parser called
<< decl dispatch: TokIdent "inferIf"
<< funDecl: next token=TokIdent "inferIf"
<< funClause: next token=TokIdent "inferIf"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "cond"
<< pConstrOrVar: next token TokIdent "cond"
<< parsed pattern: PVar "cond"
<< pPattern: next token TokIdent "eThen"
<< pConstrOrVar: next token TokIdent "eThen"
<< parsed pattern: PVar "eThen"
<< pPattern: next token TokIdent "eElse"
<< pConstrOrVar: next token TokIdent "eElse"
<< parsed pattern: PVar "eElse"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "cond",PVar "eThen",PVar "eElse"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "tCond"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tCond") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "tCond") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "cond"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sBool"
<< pConstrOrVar: next token TokIdent "sBool"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sBool") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "tCond"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "inferIf"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferIf"
<< pConstrOrVar: next token TokIdent "inferIf"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "cond"
<< pConstrOrVar: next token TokIdent "eThen"
<< pConstrOrVar: next token TokIdent "eElse"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferIf") [PVar "inferExprFn",PVar "env",PVar "cond",PVar "eThen",PVar "eElse"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "tCond"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tCond") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "tCond") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "cond"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "sBool"
<< pConstrOrVar: next token TokIdent "sBool"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sBool") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "tCond"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprIf" (Just [ExportVar "inferIf"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))],[TokNewline,TokIdent "inferIf",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokIdent "`composeSubst`",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLet.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLet
  ( inferLet,
    inferLetBlock,
    inferWhere,
    inferBindings,
    inferBinding,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import qualified Data.Map as M
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferLet ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Pattern ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferLet inferExprFn env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExprFn (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExprFn env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferBindings ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, TypeEnv)
inferBindings inferExprFn env [] = Right (emptySubst, emptyEnv)
inferBindings inferExprFn env ((pat, expr) : rest) = do
  (sPat, envPat, tPat) <- inferPattern pat
  (sExpr, tExpr) <- inferExprFn (applyEnv sPat env) expr
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat
  (sRest, envRest) <- inferBindings inferExprFn (applyEnv s env) rest
  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest
  Right (sFinal, envFinal)

inferLetBlock ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Expr ->
  Either InferError (Subst, Type)
inferLetBlock inferExprFn env binds body = do
  (sBinds, envBinds) <- inferBindings inferExprFn env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExprFn env'' body

inferWhere ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, Type)
inferWhere inferExprFn env e binds = do
  (s1, t1) <- inferExprFn env e
  _ <- foldM (inferBinding inferExprFn) (applyEnv s1 env) binds
  return (s1, t1)

inferBinding ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  (Pattern, Expr) ->
  Either InferError TypeEnv
inferBinding inferExprFn env (pat, expr) = do
  (s1, t1) <- inferExprFn env expr
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return env'

-- 同様に inferLetBlock, inferWhere, inferBindings, inferBinding も inferExprFn を引数に取るように変更
{-}
inferLet :: TypeEnv -> Pattern -> Expr -> Expr -> Either InferError (Subst, Type)
inferLet inferExpr env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExpr env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferLetBlock :: TypeEnv -> [(Pattern, Expr)] -> Expr -> Either InferError (Subst, Type)
inferLetBlock inferBindings env binds body = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

inferWhere :: TypeEnv -> Expr -> [(Pattern, Expr)] -> Either InferError (Subst, Type)
inferWhere inferExpr inferBinding env e binds = do
  (s1, t1) <- inferExpr env e
  _ <- foldM inferBinding (applyEnv s1 env) binds
  return (s1, t1)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokVLBrace,TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ",",TokIdent "inferBindings",TokSymbol ",",TokIdent "inferBinding",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferLet",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Pattern",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLet",TokIdent "inferExprFn",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sExpr",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferWhere",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferWhere",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "foldM",TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokVRBrace,TokNewline,TokIdent "inferBinding",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferLet"
<< exportItem: next token=TokIdent "inferLetBlock"
<< exportItem: next token=TokIdent "inferWhere"
<< exportItem: next token=TokIdent "inferBindings"
<< exportItem: next token=TokIdent "inferBinding"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprLet" (Just [ExportVar "inferLet",ExportVar "inferLetBlock",ExportVar "inferWhere",ExportVar "inferBindings",ExportVar "inferBinding"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferLet"
<< decl parser called
<< decl dispatch: TokIdent "inferLet"
<< funDecl: next token=TokIdent "inferLet"
<< funClause: next token=TokIdent "inferLet"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferLet"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferLet :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferLet"
<< decl parser called
<< decl dispatch: TokIdent "inferLet"
<< funDecl: next token=TokIdent "inferLet"
<< funClause: next token=TokIdent "inferLet"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "pat"
<< parsed pattern: PVar "pat"
<< pPattern: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e1"
<< parsed pattern: PVar "e1"
<< pPattern: next token TokIdent "e2"
<< pConstrOrVar: next token TokIdent "e2"
<< parsed pattern: PVar "e2"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "pat",PVar "e1",PVar "e2"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "sPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pConstrOrVar: next token TokIdent "envPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s2"
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "inferLet"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferLet"
<< pConstrOrVar: next token TokIdent "inferLet"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "pat"
<< pConstrOrVar: next token TokIdent "e1"
<< pConstrOrVar: next token TokIdent "e2"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferLet") [PVar "inferExprFn",PVar "env",PVar "pat",PVar "e1",PVar "e2"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "sPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pConstrOrVar: next token TokIdent "envPat"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pConstrOrVar: next token TokIdent "tPat"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s2"
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprLet" (Just [ExportVar "inferLet",ExportVar "inferLetBlock",ExportVar "inferWhere",ExportVar "inferBindings",ExportVar "inferBinding"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))],[TokNewline,TokIdent "inferLet",TokIdent "inferExprFn",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokIdent "`composeSubst`",TokIdent "sExpr",TokIdent "`composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferWhere",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferWhere",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokIdent "_",TokSymbol "<-",TokIdent "foldM",TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokVRBrace,TokNewline,TokIdent "inferBinding",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokIdent "`composeSubst`",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLiteral.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLiteral
  ( inferInt,
    inferBool,
    inferString,
    inferTuple,
    inferList,
  )
where

import AST.Expr
import AST.Type
import Control.Monad (mapM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferInt = Right (emptySubst, TCon "Int")

inferBool = Right (emptySubst, TCon "Bool")

inferString = Right (emptySubst, TCon "String")

inferTuple ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferTuple inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))

inferList ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferList inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))

unifyList :: Type -> [(Subst, Type)] -> Either InferError Subst
unifyList t [] = Right emptySubst
unifyList t ((s, tElem) : rest) = do
  sU <- case unify (apply s t) tElem of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s' = sU `composeSubst` s
  unifyList (apply s' t) rest


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokVLBrace,TokSymbol "(",TokIdent "inferInt",TokSymbol ",",TokIdent "inferBool",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "mapM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferInt",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokNewline,TokIdent "inferBool",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokNewline,TokIdent "inferString",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokNewline,TokIdent "inferTuple",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferTuple",TokIdent "inferExprFn",TokIdent "env",TokIdent "es",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferList",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferList",TokIdent "inferExprFn",TokIdent "env",TokIdent "es",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "unifyList",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokIdent "tElem",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "sU",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferInt"
<< exportItem: next token=TokIdent "inferBool"
<< exportItem: next token=TokIdent "inferString"
<< exportItem: next token=TokIdent "inferTuple"
<< exportItem: next token=TokIdent "inferList"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprLiteral" (Just [ExportVar "inferInt",ExportVar "inferBool",ExportVar "inferString",ExportVar "inferTuple",ExportVar "inferList"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "mapM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferInt"
<< decl parser called
<< decl dispatch: TokIdent "inferInt"
<< funDecl: next token=TokIdent "inferInt"
<< funClause: next token=TokIdent "inferInt"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "inferBool"
<< infixOp: next token TokIdent "inferBool"
<< whereBlock: next tokenTokIdent "inferBool"
<< funClauseWithName: next token=TokIdent "inferBool"
<< declBody: return DeclFunGroup "inferInt" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Int")]))) Nothing]
<< decl next token: TokIdent "inferBool"
<< decl parser called
<< decl dispatch: TokIdent "inferBool"
<< funDecl: next token=TokIdent "inferBool"
<< funClause: next token=TokIdent "inferBool"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "inferString"
<< infixOp: next token TokIdent "inferString"
<< whereBlock: next tokenTokIdent "inferString"
<< funClauseWithName: next token=TokIdent "inferString"
<< declBody: return DeclFunGroup "inferBool" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Bool")]))) Nothing]
<< decl next token: TokIdent "inferString"
<< decl parser called
<< decl dispatch: TokIdent "inferString"
<< funDecl: next token=TokIdent "inferString"
<< funClause: next token=TokIdent "inferString"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "String"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "inferTuple"
<< infixOp: next token TokIdent "inferTuple"
<< whereBlock: next tokenTokIdent "inferTuple"
<< funClauseWithName: next token=TokIdent "inferTuple"
<< declBody: return DeclFunGroup "inferString" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "String")]))) Nothing]
<< decl next token: TokIdent "inferTuple"
<< decl parser called
<< decl dispatch: TokIdent "inferTuple"
<< funDecl: next token=TokIdent "inferTuple"
<< funClause: next token=TokIdent "inferTuple"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferTuple"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferTuple :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferTuple"
<< decl parser called
<< decl dispatch: TokIdent "inferTuple"
<< funDecl: next token=TokIdent "inferTuple"
<< funClause: next token=TokIdent "inferTuple"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "es"
<< pConstrOrVar: next token TokIdent "es"
<< parsed pattern: PVar "es"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "es"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "inferred"
<< pConstrOrVar: next token TokIdent "inferred"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "inferred") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "es"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "substs"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "substs") []
<< expr dispatch: TokIdent "map"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "fst"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "types"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "types") []
<< expr dispatch: TokIdent "map"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "snd"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< expr dispatch: TokIdent "foldl"
<< exprCore next token: TokIdent "foldl"
<< atomBaseCore next token: TokIdent "foldl"
<< atomBaseCore next token: TokIdent "composeSubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "substs"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "map"
<< pConstrOrVar: next token TokIdent "apply"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s"]
<< pConstrOrVar: next token TokIdent "types"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "s") [],PApp (PVar "TTuple") [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]]]
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "map"
<< pConstrOrVar: next token TokIdent "apply"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s"]
<< pConstrOrVar: next token TokIdent "types"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "s") [],PApp (PVar "TTuple") [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "inferList"
<< infixOp: next token TokIdent "inferList"
<< whereBlock: next tokenTokIdent "inferList"
<< funClauseWithName: next token=TokIdent "inferList"
<< declBody: return DeclFunGroup "inferTuple" [FunClause [PVar "inferExprFn",PVar "env",PVar "es"] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),LetStmt [(PApp (PVar "substs") [],EApp (EApp (EVar "map") (EVar "fst")) (EVar "inferred"))],LetStmt [(PApp (PVar "types") [],EApp (EApp (EVar "map") (EVar "snd")) (EVar "inferred"))],LetStmt [(PApp (PVar "s") [],EApp (EApp (EApp (EVar "foldl") (EVar "composeSubst")) (EVar "emptySubst")) (EVar "substs"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TTuple") (EApp (EApp (EVar "map") (EApp (EVar "apply") (EVar "s"))) (EVar "types"))]))])) Nothing]
<< decl next token: TokIdent "inferList"
<< decl parser called
<< decl dispatch: TokIdent "inferList"
<< funDecl: next token=TokIdent "inferList"
<< funClause: next token=TokIdent "inferList"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferList"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferList :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferList"
<< decl parser called
<< decl dispatch: TokIdent "inferList"
<< funDecl: next token=TokIdent "inferList"
<< funClause: next token=TokIdent "inferList"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "es"
<< pConstrOrVar: next token TokIdent "es"
<< parsed pattern: PVar "es"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "es"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "inferred"
<< pConstrOrVar: next token TokIdent "inferred"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "inferred") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "es"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "inferred"
<< exprCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokSymbol "]"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PList []) []
<< caseAlt: next token TokArrow PApp (PList []) []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "emptySubst"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "emptySubst") []
<< pConstrOrVar: next token TokTypeIdent "TList"
<< pConstrOrVar: next token TokIdent "tv"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TList") [PVar "tv"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "emptySubst") [],PApp (PVar "TList") [PVar "tv"]]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TList"
<< atomBaseCore next token: TokTypeIdent "TList"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokSymbol "("
<< infixOp: next token TokSymbol "("
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])) []
<< caseAlt: next token TokArrow PApp (PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])) []
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "sRest"
<< pConstrOrVar: next token TokIdent "sRest"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sRest") []
<< expr dispatch: TokIdent "unifyList"
<< exprCore next token: TokIdent "unifyList"
<< atomBaseCore next token: TokIdent "unifyList"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< expr dispatch: TokIdent "sRest"
<< exprCore next token: TokIdent "sRest"
<< atomBaseCore next token: TokIdent "sRest"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokTypeIdent "TList"
<< pConstrOrVar: next token TokIdent "apply"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s",PVar "t1"]
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TList") [PApp (PVar "apply") [PVar "s",PVar "t1"]]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "s") [],PApp (PVar "TList") [PApp (PVar "apply") [PVar "s",PVar "t1"]]]]
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokTypeIdent "TList"
<< pConstrOrVar: next token TokIdent "apply"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s",PVar "t1"]
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TList") [PApp (PVar "apply") [PVar "s",PVar "t1"]]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PTuple [PApp (PVar "s") [],PApp (PVar "TList") [PApp (PVar "apply") [PVar "s",PVar "t1"]]]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TList"
<< atomBaseCore next token: TokTypeIdent "TList"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "unifyList"
<< infixOp: next token TokIdent "unifyList"
<< whereBlock: next tokenTokIdent "unifyList"
<< funClauseWithName: next token=TokIdent "unifyList"
<< declBody: return DeclFunGroup "inferList" [FunClause [PVar "inferExprFn",PVar "env",PVar "es"] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),ExprStmt (ECase (EVar "inferred") [CaseAlt (PApp (PList []) []) (EDo [Bind (PApp (PVar "tv") []) (EVar "freshTypeVar"),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TList") (EVar "tv")]))]),CaseAlt (PApp (PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])) []) (EDo [Bind (PApp (PVar "sRest") []) (EApp (EApp (EVar "unifyList") (EVar "t1")) (EVar "rest")),LetStmt [(PApp (PVar "s") [],EApp (EApp (EVar "sRest") (EVar "`composeSubst`")) (EVar "s1"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TList") (EApp (EApp (EVar "apply") (EVar "s")) (EVar "t1"))]))])])])) Nothing]
<< decl next token: TokIdent "unifyList"
<< decl parser called
<< decl dispatch: TokIdent "unifyList"
<< funDecl: next token=TokIdent "unifyList"
<< funClause: next token=TokIdent "unifyList"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "unifyList"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Type"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TTuple [TCon "Subst",TCon "Type"]
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst")
<< parseTypeCore: TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst"))
<< parseTypeCore: TFun (TCon "Type") (TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst")))
<< parsed type signature: unifyList :: TFun (TCon "Type") (TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst")))
<< returning DeclTypeSig: DeclTypeSig "unifyList" (TFun (TCon "Type") (TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst"))))
<< declBody: return DeclTypeSig "unifyList" (TFun (TCon "Type") (TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst"))))
<< decl next token: TokIdent "unifyList"
<< decl parser called
<< decl dispatch: TokIdent "unifyList"
<< funDecl: next token=TokIdent "unifyList"
<< funClause: next token=TokIdent "unifyList"
<< pPattern: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< parsed pattern: PVar "t"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "t",PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "unifyList"
<< infixOp: next token TokIdent "unifyList"
<< whereBlock: next tokenTokIdent "unifyList"
<< funClauseWithName: next token=TokIdent "unifyList"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "tElem"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tElem") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "t") [PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "sU"
<< pConstrOrVar: next token TokIdent "sU"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sU") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "tElem"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< declBody: return DeclFunGroup "unifyList" [FunClause [PVar "t",PList []] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing]
<< decl next token: TokIdent "unifyList"
<< decl parser called
<< decl dispatch: TokIdent "unifyList"
<< funDecl: next token=TokIdent "unifyList"
<< funClause: next token=TokIdent "unifyList"
<< pPattern: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< parsed pattern: PVar "t"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "tElem"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tElem") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])
<< parsed pattern: PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "t",PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "sU"
<< pConstrOrVar: next token TokIdent "sU"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sU") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "tElem"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
<< typeSigDecl: TokIdent "unifyList"
<< typeSigDecl:2 TokIdent "t"
<< valueDecl: TokIdent "unifyList"
<< pConstrOrVar: next token TokIdent "unifyList"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "tElem"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tElem") []
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "unifyList") [PVar "t",PCons (PApp (PTuple [PApp (PVar "s") [],PApp (PVar "tElem") []]) []) (PApp (PVar "rest") [])]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "sU"
<< pConstrOrVar: next token TokIdent "sU"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sU") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "tElem"
<< atomBaseCore next token: TokKeyword "of"
<< whereClause: next token TokKeyword "of"
<< infixOp: next token TokKeyword "of"
<< pConstrOrVar: next token TokTypeIdent "Left"
<< pConstrOrVar: next token TokIdent "uerr"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Left") [PVar "uerr"]
<< caseAlt: next token TokArrow PApp (PVar "Left") [PVar "uerr"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "su"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PVar "su"]
<< caseAlt: next token TokArrow PApp (PVar "Right") [PVar "su"]
<< caseAlt:2 next token TokArrow []
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokKeyword "let"
<< infixOp: next token TokKeyword "let"
Just ([DeclModule "TypeInference.Infer.Expr.ExprLiteral" (Just [ExportVar "inferInt",ExportVar "inferBool",ExportVar "inferString",ExportVar "inferTuple",ExportVar "inferList"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "mapM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclFunGroup "inferInt" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Int")]))) Nothing],DeclFunGroup "inferBool" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Bool")]))) Nothing],DeclFunGroup "inferString" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "String")]))) Nothing],DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferTuple" [FunClause [PVar "inferExprFn",PVar "env",PVar "es"] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),LetStmt [(PApp (PVar "substs") [],EApp (EApp (EVar "map") (EVar "fst")) (EVar "inferred"))],LetStmt [(PApp (PVar "types") [],EApp (EApp (EVar "map") (EVar "snd")) (EVar "inferred"))],LetStmt [(PApp (PVar "s") [],EApp (EApp (EApp (EVar "foldl") (EVar "composeSubst")) (EVar "emptySubst")) (EVar "substs"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TTuple") (EApp (EApp (EVar "map") (EApp (EVar "apply") (EVar "s"))) (EVar "types"))]))])) Nothing],DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferList" [FunClause [PVar "inferExprFn",PVar "env",PVar "es"] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),ExprStmt (ECase (EVar "inferred") [CaseAlt (PApp (PList []) []) (EDo [Bind (PApp (PVar "tv") []) (EVar "freshTypeVar"),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TList") (EVar "tv")]))]),CaseAlt (PApp (PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])) []) (EDo [Bind (PApp (PVar "sRest") []) (EApp (EApp (EVar "unifyList") (EVar "t1")) (EVar "rest")),LetStmt [(PApp (PVar "s") [],EApp (EApp (EVar "sRest") (EVar "`composeSubst`")) (EVar "s1"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TList") (EApp (EApp (EVar "apply") (EVar "s")) (EVar "t1"))]))])])])) Nothing],DeclTypeSig "unifyList" (TFun (TCon "Type") (TFun (TList (TTuple [TCon "Subst",TCon "Type"])) (TApp (TApp (TCon "Either") (TCon "InferError")) (TCon "Subst")))),DeclFunGroup "unifyList" [FunClause [PVar "t",PList []] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing]],[TokIdent "unifyList",TokIdent "t",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokIdent "tElem",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "sU",TokIdent "`composeSubst`",TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprSQL.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprSQL (inferSQL) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv

inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env params = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, _) <- inferExprFn envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferSQL",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferSQL",TokIdent "inferExprFn",TokIdent "env",TokIdent "params",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferSQL"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprSQL" (Just [ExportVar "inferSQL"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferSQL"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferSQL :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< pPattern: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< parsed pattern: PVar "inferExprFn"
<< pPattern: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "env"
<< parsed pattern: PVar "env"
<< pPattern: next token TokIdent "params"
<< pConstrOrVar: next token TokIdent "params"
<< parsed pattern: PVar "params"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "inferExprFn",PVar "env",PVar "params"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s") [],PApp (PVar "_") []]) []
<< expr dispatch: TokIdent "foldM"
<< exprCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "step"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "params"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "where"
<< expr dispatch: TokKeyword "where"
<< exprCore next token: TokKeyword "where"
<< atomBaseCore next token: TokKeyword "where"
<< typeSigDecl: TokIdent "inferSQL"
<< typeSigDecl:2 TokIdent "inferExprFn"
<< valueDecl: TokIdent "inferSQL"
<< pConstrOrVar: next token TokIdent "inferSQL"
<< pConstrOrVar: next token TokIdent "inferExprFn"
<< pConstrOrVar: next token TokIdent "env"
<< pConstrOrVar: next token TokIdent "params"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferSQL") [PVar "inferExprFn",PVar "env",PVar "params"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "s"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pConstrOrVar: next token TokIdent "_"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "_") []
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s") [],PApp (PVar "_") []]) []
<< expr dispatch: TokIdent "foldM"
<< exprCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "step"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "params"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "where"
<< expr dispatch: TokKeyword "where"
<< exprCore next token: TokKeyword "where"
<< atomBaseCore next token: TokKeyword "where"
Just ([DeclModule "TypeInference.Infer.Expr.ExprSQL" (Just [ExportVar "inferSQL"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))],[TokNewline,TokIdent "inferSQL",TokIdent "inferExprFn",TokIdent "env",TokIdent "params",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokIdent "`composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr.hs ===
-- Raw Source --
module TypeInference.Infer.Expr
  ( inferExpr,
    inferProgram,
    inferDecl,
  )
where

import AST.Decl (Decl (..))
import AST.Expr
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprDispatch (inferExpr)
import TypeInference.Infer.Expr.ExprSQL
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

-- declsはAST
inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- 仮の型を環境に入れる（再帰対応）
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)
  -- 各 clause の型を推論
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]
  -- unify して 1 つの型にまとめる
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)
  -- generalize
  let scheme = generalizeInfer env finalType
  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats Nothing (Just body) _) = do
  -- inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats
  -- ★ 関数型をここで作る
  let funType = foldr TArrow tBody argTypes
  Right (s, funType)

-- 宣言の型推論（まだ骨格だけ）
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats Nothing (Just body) _ -> do
    -- ガードなし、式あり
    (sPats, envPats, argTypes) <- inferPatterns pats
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body
    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)
    Right (extendEnv env name scheme, s)
  DeclFun _ _ (Just _) _ _ ->
    Left (InferOther "Guarded function inference not implemented yet")
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokVLBrace,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "_",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "_",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "_",TokIdent "_",TokSymbol "(",TokTypeIdent "Just",TokIdent "_",TokSymbol ")",TokIdent "_",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Guarded function inference not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokIdent "inferDecl"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr" (Just [ExportVar "inferExpr",ExportVar "inferProgram",ExportVar "inferDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Expr" (Just [ExportVar "inferExpr",ExportVar "inferProgram",ExportVar "inferDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "_",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "_",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "_",TokIdent "_",TokSymbol "(",TokTypeIdent "Just",TokIdent "_",TokSymbol ")",TokIdent "_",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Guarded function inference not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Pattern.hs ===
-- Raw Source --
module TypeInference.Infer.Pattern
  ( inferPattern,
    inferPatterns,
    inferPatternApp,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.Infer.Core
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- 変数パターン
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- 単一変数の PApp パターン（あなたのパーサーが生成する形）
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- ★ 追加：PApp の一般形（引数なし）
  PApp p [] -> inferPattern p
  -- 整数リテラル
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ワイルドカード
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- リストパターン [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- 全要素の型を t0 と unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- タプルパターン (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- コンストラクタパターン Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons パターン (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As パターン x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokVLBrace,TokSymbol "(",TokIdent "inferPattern",TokSymbol ",",TokIdent "inferPatterns",TokSymbol ",",TokIdent "inferPatternApp",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferPattern"
<< exportItem: next token=TokIdent "inferPatterns"
<< exportItem: next token=TokIdent "inferPatternApp"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Pattern" (Just [ExportVar "inferPattern",ExportVar "inferPatterns",ExportVar "inferPatternApp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Pattern" (Just [ExportVar "inferPattern",ExportVar "inferPatterns",ExportVar "inferPatternApp"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokIdent "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokIdent "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer.hs ===
-- Raw Source --
module TypeInference.Infer
  ( inferExpr,
    inferProgram,
    -- inferProgramPattern
  )
where

import TypeInference.Infer.Expr (inferExpr, inferProgram)

-- import TypeInference.Infer.Pattern
-- import TypeInference.Infer.Core


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokVLBrace,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer" (Just [ExportVar "inferExpr",ExportVar "inferProgram"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferExpr",ImportVar "inferProgram"]}
Just ([DeclModule "TypeInference.Infer" (Just [ExportVar "inferExpr",ExportVar "inferProgram"]),DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferExpr",ImportVar "inferProgram"]}],[TokNewline])

=== Running: src/TypeInference/Pretty.hs ===
-- Raw Source --
module TypeInference.Pretty (prettyType) where

-- import TypeInference.Subst
-- import TypeInference.Type (Type(..))
-- import qualified TypeInference.Type as TI

import AST.Type (Type(..))
import qualified AST.Type as TI

prettyType :: TI.Type -> String
prettyType ty = case ty of
  TVar v        -> v
  TCon c        -> c
  TUnit         -> "Unit"
  TArrow a b    -> "(" ++ prettyType a ++ " -> " ++ prettyType b ++ ")"
  TList t       -> "[" ++ prettyType t ++ "]"
  TApp a b      -> prettyType a ++ " " ++ prettyType b
  TForall vs t  -> "forall " ++ unwords vs ++ ". " ++ prettyType t
  TTuple ts     -> "(" ++ commaList (map prettyType ts) ++ ")"
  TConstraint cs t ->
      "(" ++ commaList (map show cs) ++ ") => " ++ prettyType t
  where
    commaList = foldr1 (\a b -> a ++ ", " ++ b)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Pretty",TokSymbol "(",TokIdent "prettyType",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokKeyword "as",TokTypeIdent "TI",TokNewline,TokIdent "prettyType",TokSymbol "::",TokTypeIdent "TI",TokDot,TokTypeIdent "Type",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokIdent "ty",TokSymbol "=",TokKeyword "case",TokIdent "ty",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "c",TokArrow,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokArrow,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "a",TokIdent "b",TokArrow,TokString "(",TokOperator "++",TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " -> ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TList",TokIdent "t",TokArrow,TokString "[",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokOperator "++",TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokIdent "a",TokIdent "b",TokArrow,TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t",TokArrow,TokString "forall ",TokOperator "++",TokIdent "unwords",TokIdent "vs",TokOperator "++",TokString ". ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t",TokArrow,TokVLBrace,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokOperator "++",TokString ") => ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "commaList",TokSymbol "=",TokIdent "foldr1",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "prettyType"
<< declBody: return DeclModule "TypeInference.Pretty" (Just [ExportVar "prettyType"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = True, importModule = "AST.Type", importAlias = Just "TI", importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "prettyType"
<< decl parser called
<< decl dispatch: TokIdent "prettyType"
<< funDecl: next token=TokIdent "prettyType"
<< funClause: next token=TokIdent "prettyType"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "prettyType"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "TI"
<< parseTypeCore: TCon "TI"
<< parsed type signature: prettyType :: TCon "TI"
<< returning DeclTypeSig: DeclTypeSig "prettyType" (TCon "TI")
<< declBody: return DeclTypeSig "prettyType" (TCon "TI")
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "TypeInference.Pretty" (Just [ExportVar "prettyType"]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "AST.Type", importAlias = Just "TI", importHiding = False, importItems = Nothing},DeclTypeSig "prettyType" (TCon "TI")],[TokDot,TokTypeIdent "Type",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokIdent "ty",TokSymbol "=",TokKeyword "case",TokIdent "ty",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "c",TokArrow,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokArrow,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "a",TokIdent "b",TokArrow,TokString "(",TokOperator "++",TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " -> ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TList",TokIdent "t",TokArrow,TokString "[",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokOperator "++",TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokIdent "a",TokIdent "b",TokArrow,TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t",TokArrow,TokString "forall ",TokOperator "++",TokIdent "unwords",TokIdent "vs",TokOperator "++",TokString ". ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t",TokArrow,TokVLBrace,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokOperator "++",TokString ") => ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "commaList",TokSymbol "=",TokIdent "foldr1",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/SQLInfer.hs ===
-- Raw Source --
module TypeInference.SQLInfer where

import AST.Decl (Decl (..))
import AST.Expr (CaseAlt (..), Expr (..), Name)
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import TypeInference.Error (InferError (..))
import TypeInference.Subst
import TypeInference.TypeEnv

data SQLInfo = SQLInfo
  { sqlText  :: String
  , sqlVars  :: [String]
  , sqlExprs :: [Expr]
  }

inferSQL :: String -> [Expr] -> SQLInfo
inferSQL sql args =
  SQLInfo
    { sqlText  = sql
    , sqlVars  = map getVarName args
    , sqlExprs = args
    }

getVarName :: Expr -> String
getVarName (EVar name) = name
getVarName _ = error "SQL arguments must be variables"

{-}
inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  String ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env sql args = do
  inferred <- mapM (inferExprFn env) args
  return (emptySubst, TUnit)
-}

{-}
inferSQL :: TypeEnv -> String -> [Expr] -> Either InferError (Subst, Type)
inferSQL env sql args = do
  -- args の型を推論
  argTypes <- mapM (inferExpr env) args

  -- SQLParam 型クラスに属するかチェック（任意）
  mapM_ ensureSQLParam (map snd argTypes)

  -- SQL 文自体の型は Unit でよい
  return (emptySubst, TUnit)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "data",TokTypeIdent "SQLInfo",TokSymbol "=",TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "::",TokTypeIdent "String",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "::",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline,TokIdent "inferSQL",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokTypeIdent "SQLInfo",TokNewline,TokIdent "inferSQL",TokKeyword "sql",TokIdent "args",TokSymbol "=",TokVLBrace,TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "=",TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "=",TokIdent "map",TokIdent "getVarName",TokIdent "args",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "=",TokIdent "args",TokSymbol ";",TokSymbol "}",TokVRBrace,TokVRBrace,TokNewline,TokIdent "getVarName",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokIdent "name",TokNewline,TokIdent "getVarName",TokIdent "_",TokSymbol "=",TokIdent "error",TokString "SQL arguments must be variables",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.SQLInfer" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "InferError"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokSymbol "{"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< dataConstrRecord: "SQLInfo" [Field "sqlExprs" (TList (TCon "Expr")),Field "sqlVars" (TList (TCon "String")),Field "sqlText" (TCon "String")]
<< declBody: return DeclData "SQLInfo" [] [ConstraintRecord "SQLInfo" [Field "sqlExprs" (TList (TCon "Expr")),Field "sqlVars" (TList (TCon "String")),Field "sqlText" (TCon "String")]] []
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferSQL"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "SQLInfo"
<< parseTypeCore: TFun (TList (TCon "Expr")) (TCon "SQLInfo")
<< parseTypeCore: TFun (TCon "String") (TFun (TList (TCon "Expr")) (TCon "SQLInfo"))
<< parsed type signature: inferSQL :: TFun (TCon "String") (TFun (TList (TCon "Expr")) (TCon "SQLInfo"))
<< returning DeclTypeSig: DeclTypeSig "inferSQL" (TFun (TCon "String") (TFun (TList (TCon "Expr")) (TCon "SQLInfo")))
<< declBody: return DeclTypeSig "inferSQL" (TFun (TCon "String") (TFun (TList (TCon "Expr")) (TCon "SQLInfo")))
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< pPattern: next token TokKeyword "sql"
<< funClause: args=[] t = TokKeyword "sql"
<< parseGuardedClause: next token=TokKeyword "sql"
<< guardedRhs: next token = TokKeyword "sql"
<< parseGuardLine: next token=TokKeyword "sql"
<< typeSigDecl: TokIdent "inferSQL"
<< typeSigDecl:2 TokKeyword "sql"
<< valueDecl: TokIdent "inferSQL"
<< pConstrOrVar: next token TokIdent "inferSQL"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferSQL") []
Just ([DeclModule "TypeInference.SQLInfer" Nothing,DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "InferError"]},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclData "SQLInfo" [] [ConstraintRecord "SQLInfo" [Field "sqlExprs" (TList (TCon "Expr")),Field "sqlVars" (TList (TCon "String")),Field "sqlText" (TCon "String")]] [],DeclTypeSig "inferSQL" (TFun (TCon "String") (TFun (TList (TCon "Expr")) (TCon "SQLInfo")))],[TokNewline,TokIdent "inferSQL",TokKeyword "sql",TokIdent "args",TokSymbol "=",TokVLBrace,TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "=",TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "=",TokIdent "map",TokIdent "getVarName",TokIdent "args",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "=",TokIdent "args",TokSymbol ";",TokSymbol "}",TokVRBrace,TokVRBrace,TokNewline,TokIdent "getVarName",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokIdent "name",TokNewline,TokIdent "getVarName",TokIdent "_",TokSymbol "=",TokIdent "error",TokString "SQL arguments must be variables",TokNewline])

=== Running: src/TypeInference/Subst.hs ===
-- Raw Source --
module TypeInference.Subst
  ( Subst,
    emptySubst,
    singletonSubst,
    composeSubst,
    apply,
  )
where

import AST.Type
import qualified Data.Map as M

-- 型代入：型変数名 → 型
type Subst = M.Map String Type

-- 空の代入
emptySubst :: Subst
emptySubst = M.empty

-- 単一代入
singletonSubst :: String -> Type -> Subst
singletonSubst = M.singleton

-- 代入の合成
-- s1 を先に適用し、その結果に s2 を適用する
composeSubst :: Subst -> Subst -> Subst
composeSubst s1 s2 =
  M.map (apply s1) s2 `M.union` s1

-- 型への代入適用
apply :: Subst -> Type -> Type
apply s t = case t of
  TUnit ->
    TUnit
  TVar v ->
    case M.lookup v s of
      Just t' -> t'
      Nothing -> TVar v
  TCon c ->
    TCon c
  TArrow t1 t2 ->
    TArrow (apply s t1) (apply s t2)
  TList t1 ->
    TList (apply s t1)
  TApp t1 t2 ->
    TApp (apply s t1) (apply s t2)
  TConstraint cs t1 ->
    TConstraint (map (applyConstraint s) cs) (apply s t1)
  TForall vars t1 ->
    -- Forall の束縛変数には代入を適用しない
    let s' = foldr M.delete s vars
     in TForall vars (apply s' t1)
  TTuple ts ->
    TTuple (map (apply s) ts)

-- 制約への代入適用
applyConstraint :: Subst -> Constraint -> Constraint
applyConstraint s (Constraint cls ts) =
  Constraint cls (map (apply s) ts)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokVLBrace,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "emptySubst",TokSymbol ",",TokIdent "singletonSubst",TokSymbol ",",TokIdent "composeSubst",TokSymbol ",",TokIdent "apply",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "type",TokTypeIdent "Subst",TokSymbol "=",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Type",TokNewline,TokIdent "emptySubst",TokSymbol "::",TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "singletonSubst",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokIdent "composeSubst",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokIdent "s1",TokIdent "s2",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "s2",TokIdent "`M",TokDot,TokIdent "union`",TokIdent "s1",TokVRBrace,TokNewline,TokIdent "apply",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TUnit",TokArrow,TokVLBrace,TokTypeIdent "TUnit",TokVRBrace,TokNewline,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokVLBrace,TokKeyword "case",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "v",TokIdent "s",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "t'",TokArrow,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "TVar",TokIdent "v",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TCon",TokIdent "c",TokArrow,TokVLBrace,TokTypeIdent "TCon",TokIdent "c",TokVRBrace,TokNewline,TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TList",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TApp",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vars",TokIdent "t1",TokArrow,TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "foldr",TokTypeIdent "M",TokDot,TokIdent "delete",TokIdent "s",TokIdent "vars",TokVLBrace,TokKeyword "in",TokTypeIdent "TForall",TokIdent "vars",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokVLBrace,TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyConstraint",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokIdent "s",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Subst"
<< exportItem: next token=TokIdent "emptySubst"
<< exportItem: next token=TokIdent "singletonSubst"
<< exportItem: next token=TokIdent "composeSubst"
<< exportItem: next token=TokIdent "apply"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Subst" (Just [ExportType "Subst" False,ExportVar "emptySubst",ExportVar "singletonSubst",ExportVar "composeSubst",ExportVar "apply"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "M"
<< parseTypeCore: TCon "M"
<< declBody: return DeclTypeAlias "Subst" [] (TCon "M")
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "TypeInference.Subst" (Just [ExportType "Subst" False,ExportVar "emptySubst",ExportVar "singletonSubst",ExportVar "composeSubst",ExportVar "apply"]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclTypeAlias "Subst" [] (TCon "M")],[TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Type",TokNewline,TokIdent "emptySubst",TokSymbol "::",TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "singletonSubst",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokIdent "composeSubst",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokIdent "s1",TokIdent "s2",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "s2",TokIdent "`M",TokDot,TokIdent "union`",TokIdent "s1",TokVRBrace,TokNewline,TokIdent "apply",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TUnit",TokArrow,TokVLBrace,TokTypeIdent "TUnit",TokVRBrace,TokNewline,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokVLBrace,TokKeyword "case",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "v",TokIdent "s",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "t'",TokArrow,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "TVar",TokIdent "v",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TCon",TokIdent "c",TokArrow,TokVLBrace,TokTypeIdent "TCon",TokIdent "c",TokVRBrace,TokNewline,TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TList",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TApp",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vars",TokIdent "t1",TokArrow,TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "foldr",TokTypeIdent "M",TokDot,TokIdent "delete",TokIdent "s",TokIdent "vars",TokVLBrace,TokKeyword "in",TokTypeIdent "TForall",TokIdent "vars",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokVLBrace,TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyConstraint",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokIdent "s",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Type.hs ===
-- Raw Source --
module TypeInference.Type where

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  deriving (Eq, Show)

-- Constraint の定義がまだ無い場合は仮で置く
data Constraint = Constraint String
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Type",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Type",TokVLBrace,TokSymbol "=",TokTypeIdent "TVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TCon",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TArrow",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TList",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TApp",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TForall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TTuple",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "TUnit",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Constraint",TokSymbol "=",TokTypeIdent "Constraint",TokTypeIdent "String",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.Type" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TVar" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "TCon" [TCon "String"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TArrow" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TList" [TCon "Type"]
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "TApp" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Constraint"
<< dataConstrNormal: "TConstraint" [TList (TCon "Constraint"),TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "String"
<< dataConstrNormal: "TForall" [TList (TCon "String"),TCon "Type"]
<< dataConstrRecord: TokSymbol "["
<< parseTypeCore: TCon "Type"
<< dataConstrNormal: "TTuple" [TList (TCon "Type")]
<< dataConstrRecord: TokKeyword "deriving"
<< dataConstrNormal: "TUnit" []
<< declBody: return DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" []] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "Constraint" [TCon "String"]
<< declBody: return DeclData "Constraint" [] [Constraint "Constraint" [TCon "String"]] []
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Type" Nothing,DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" []] ["Eq","Show"],DeclData "Constraint" [] [Constraint "Constraint" [TCon "String"]] []],[TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/TypeEnv.hs ===
-- Raw Source --
module TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    emptyEnv,
    extendEnv,
    lookupEnv,
    generalize,
    instantiate,
    applyEnv,
    freeTypeVarsScheme,
    freeTypeVarsEnv,
    freeTypeVars,
  )
where

import AST.Expr (Name)
import AST.Type
import AST.Type (Type (..))
import Data.List (nub, (\\))
import qualified Data.Map as M
import TypeInference.Error (InferError (..))
import TypeInference.Subst

-- 型スキーム：forall a b. t
data Scheme = Forall [String] Type
  deriving (Show, Eq)

-- 型環境：変数名 → 型スキーム
newtype TypeEnv = TypeEnv (M.Map String Scheme)
  deriving (Show, Eq)

{-}
emptyEnv :: TypeEnv
emptyEnv = TypeEnv M.empty
-}

ftv :: Type -> Subst
ftv TUnit = M.empty

emptyEnv :: TypeEnv
emptyEnv = primitiveEnv

extendEnv :: TypeEnv -> String -> Scheme -> TypeEnv
extendEnv (TypeEnv env) x s = TypeEnv (M.insert x s env)

lookupEnv :: TypeEnv -> String -> Maybe Scheme
lookupEnv (TypeEnv env) x = M.lookup x env

freeTypeVarsEnv :: TypeEnv -> [Name]
freeTypeVarsEnv (TypeEnv env) =
  nub (concatMap freeTypeVarsScheme (M.elems env))

freeTypeVarsScheme :: Scheme -> [Name]
freeTypeVarsScheme (Forall vars t) =
  freeTypeVars t \\ vars

-- 型の自由変数を集める
freeTypeVars :: Type -> [String]
freeTypeVars t = case t of
  TVar v -> [v]
  TCon _ -> []
  TArrow t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TList t1 -> freeTypeVars t1
  TApp t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TConstraint cs t1 ->
    concatMap freeConstraintVars cs ++ freeTypeVars t1
  TForall vs t1 ->
    filter (`notElem` vs) (freeTypeVars t1)

freeConstraintVars :: Constraint -> [String]
freeConstraintVars (Constraint _ ts) =
  concatMap freeTypeVars ts

-- 環境の自由型変数
freeEnvVars :: TypeEnv -> [String]
freeEnvVars (TypeEnv env) =
  concatMap (\(Forall _ t) -> freeTypeVars t) (M.elems env)

-- 一般化：env の自由変数を除いた型変数を forall で束縛する
generalize :: TypeEnv -> Type -> Scheme
generalize env t =
  let envVars = freeEnvVars env
      typeVars = freeTypeVars t
      vars = filter (`notElem` envVars) typeVars
   in Forall vars t

-- 特殊化：forall を外し、新しい型変数に置き換える
{-}
instantiate :: Scheme -> Type
instantiate (Forall vars t) =
  let fresh v = TVar (v ++ "'") -- 簡易的な新しい型変数
      s = M.fromList [(v, fresh v) | v <- vars]
   in apply s t
-}
instantiate :: Scheme -> Either InferError Type
instantiate (Forall vars t) =
  Right (freshen vars t)

freshen :: [String] -> Type -> Type
freshen vars t =
  let newVars = M.fromList [(v, TVar ("t_" ++ v)) | v <- vars]
   in apply newVars t

applyEnv :: Subst -> TypeEnv -> TypeEnv
applyEnv s (TypeEnv env) =
  TypeEnv (M.map (\(Forall vs t) -> Forall vs (apply s t)) env)

primitiveEnv :: TypeEnv
primitiveEnv =
  TypeEnv
    ( M.fromList
        [ ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("==", Forall ["a"] (TArrow (TVar "a") (TArrow (TVar "a") (TCon "Bool"))))
        ]
    )


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "freeTypeVarsScheme",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "Scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "newtype",TokTypeIdent "TypeEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ftv",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "emptyEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSymbol "=",TokIdent "primitiveEnv",TokNewline,TokIdent "extendEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Scheme",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokIdent "s",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokIdent "lookupEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "x",TokIdent "env",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "nub",TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "vars",TokVRBrace,TokNewline,TokIdent "freeTypeVars",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokIdent "_",TokArrow,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "concatMap",TokIdent "freeConstraintVars",TokIdent "cs",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t1",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "filter",TokSymbol "(",TokIdent "`notElem`",TokIdent "vs",TokSymbol ")",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "freeConstraintVars",TokSymbol "::",TokTypeIdent "Constraint",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokIdent "freeTypeVars",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "freeEnvVars",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalize",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "envVars",TokSymbol "=",TokIdent "freeEnvVars",TokIdent "env",TokVLBrace,TokIdent "typeVars",TokSymbol "=",TokIdent "freeTypeVars",TokIdent "t",TokSymbol ";",TokIdent "vars",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "`notElem`",TokIdent "envVars",TokSymbol ")",TokIdent "typeVars",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokNewline,TokIdent "instantiate",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshen",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "newVars",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSymbol "|",TokIdent "v",TokSymbol "<-",TokIdent "vars",TokSymbol "]",TokVLBrace,TokKeyword "in",TokIdent "apply",TokIdent "newVars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyEnv",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "primitiveEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Scheme"
<< exportItem: next token=TokTypeIdent "TypeEnv"
<< exportItem: next token=TokIdent "emptyEnv"
<< exportItem: next token=TokIdent "extendEnv"
<< exportItem: next token=TokIdent "lookupEnv"
<< exportItem: next token=TokIdent "generalize"
<< exportItem: next token=TokIdent "instantiate"
<< exportItem: next token=TokIdent "applyEnv"
<< exportItem: next token=TokIdent "freeTypeVarsScheme"
<< exportItem: next token=TokIdent "freeTypeVarsEnv"
<< exportItem: next token=TokIdent "freeTypeVars"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.TypeEnv" (Just [ExportType "Scheme" True,ExportType "TypeEnv" True,ExportVar "emptyEnv",ExportVar "extendEnv",ExportVar "lookupEnv",ExportVar "generalize",ExportVar "instantiate",ExportVar "applyEnv",ExportVar "freeTypeVarsScheme",ExportVar "freeTypeVarsEnv",ExportVar "freeTypeVars"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Name"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.TypeEnv" (Just [ExportType "Scheme" True,ExportType "TypeEnv" True,ExportVar "emptyEnv",ExportVar "extendEnv",ExportVar "lookupEnv",ExportVar "generalize",ExportVar "instantiate",ExportVar "applyEnv",ExportVar "freeTypeVarsScheme",ExportVar "freeTypeVarsEnv",ExportVar "freeTypeVars"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Name"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "Scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "newtype",TokTypeIdent "TypeEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ftv",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "emptyEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSymbol "=",TokIdent "primitiveEnv",TokNewline,TokIdent "extendEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Scheme",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokIdent "s",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokIdent "lookupEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "x",TokIdent "env",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "nub",TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "vars",TokVRBrace,TokNewline,TokIdent "freeTypeVars",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokIdent "_",TokArrow,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "concatMap",TokIdent "freeConstraintVars",TokIdent "cs",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t1",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "filter",TokSymbol "(",TokIdent "`notElem`",TokIdent "vs",TokSymbol ")",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "freeConstraintVars",TokSymbol "::",TokTypeIdent "Constraint",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokIdent "freeTypeVars",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "freeEnvVars",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalize",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "envVars",TokSymbol "=",TokIdent "freeEnvVars",TokIdent "env",TokVLBrace,TokIdent "typeVars",TokSymbol "=",TokIdent "freeTypeVars",TokIdent "t",TokSymbol ";",TokIdent "vars",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "`notElem`",TokIdent "envVars",TokSymbol ")",TokIdent "typeVars",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokNewline,TokIdent "instantiate",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshen",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "newVars",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSymbol "|",TokIdent "v",TokSymbol "<-",TokIdent "vars",TokSymbol "]",TokVLBrace,TokKeyword "in",TokIdent "apply",TokIdent "newVars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyEnv",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "primitiveEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Unify.hs ===
-- Raw Source --
module TypeInference.Unify (Subst, unify, UnifyError) where

import AST.Type
import Control.Monad (unless)
import qualified Data.Map as M
import TypeInference.Subst

-- 型の一致に失敗したときのエラー
data UnifyError
  = UnifyMismatch Type Type
  | UnifyOccursCheckFailed String Type
  deriving (Show, Eq)

-- 型の一致を試み、成功すれば代入を返す
{-}
unify :: Type -> Type -> Either UnifyError Subst
unify TUnit TUnit = Right emptySubst
unify (TArrow l1 r1) (TArrow l2 r2) = do
  s1 <- unify l1 l2
  s2 <- unify (apply s1 r1) (apply s1 r2)
  return (composeSubst s2 s1)
unify (TApp f1 a1) (TApp f2 a2) = do
  s1 <- unify f1 f2
  s2 <- unify (apply s1 a1) (apply s1 a2)
  return (composeSubst s2 s1)
unify (TList t1) (TList t2) =
  unify t1 t2
unify (TCon c1) (TCon c2)
  | c1 == c2 = return emptySubst
  | otherwise = Left (UnifyMismatch (TCon c1) (TCon c2))
unify (TVar v) t = bindVar v t
unify t (TVar v) = bindVar v t
-- その他の型構成子は未対応（TConstraint, TForall など）
unify t1 t2 = Left (UnifyMismatch t1 t2)
-}
unify :: Type -> Type -> Either UnifyError Subst

-- 型変数
unify (TVar a) t = varBind a t
unify t (TVar a) = varBind a t

-- Unit
unify TUnit TUnit = Right emptySubst

-- 型コンストラクタ
unify (TCon a) (TCon b)
  | a == b    = Right emptySubst
  | otherwise = Left (UnifyMismatch (TCon a) (TCon b))

-- 関数型
unify (TArrow a1 b1) (TArrow a2 b2) = do
  s1 <- unify a1 a2
  s2 <- unify (apply s1 b1) (apply s1 b2)
  Right (s2 `composeSubst` s1)

-- タプル
unify (TTuple xs) (TTuple ys)
  | length xs == length ys = unifyMany xs ys
  | otherwise = Left (UnifyMismatch (TTuple xs) (TTuple ys))

-- リスト
unify (TList a) (TList b) = unify a b

-- デフォルト
unify t1 t2 = Left (UnifyMismatch t1 t2)

varBind :: String -> Type -> Either UnifyError Subst
varBind a t
  | t == TVar a = Right emptySubst
  | occursCheck a t = Left (UnifyOccursCheckFailed a t)
  | otherwise = Right (M.singleton a t)


occursCheck :: String -> Type -> Bool
occursCheck a (TVar b)       = a == b
occursCheck a (TCon _)       = False
occursCheck a TUnit          = False
occursCheck a (TList t)      = occursCheck a t
occursCheck a (TTuple ts)    = any (occursCheck a) ts
occursCheck a (TArrow t1 t2) = occursCheck a t1 || occursCheck a t2

unifyMany :: [Type] -> [Type] -> Either UnifyError Subst
unifyMany [] [] = Right emptySubst
unifyMany (t1:ts1) (t2:ts2) = do
  s1 <- unify t1 t2
  s2 <- unifyMany (map (apply s1) ts1) (map (apply s1) ts2)
  Right (s2 `composeSubst` s1)
unifyMany ts1 ts2 =
  Left (UnifyMismatch (TTuple ts1) (TTuple ts2))

-- 型変数と型を結びつける（occurs check あり）
bindVar :: String -> Type -> Either UnifyError Subst
bindVar v t
  | t == TVar v = return emptySubst
  | v `occursIn` t = Left (UnifyOccursCheckFailed v t)
  | otherwise = return (singletonSubst v t)

-- 型変数 v が型 t の中に現れるか（無限型を防ぐ）
occursIn :: String -> Type -> Bool
occursIn v t = case t of
  TVar x -> x == v
  TCon _ -> False
  TArrow t1 t2 -> occursIn v t1 || occursIn v t2
  TList t1 -> occursIn v t1
  TApp t1 t2 -> occursIn v t1 || occursIn v t2
  TConstraint cs t1 -> any (occursInConstraint v) cs || occursIn v t1
  TForall vs t1 -> if v `elem` vs then False else occursIn v t1

occursInConstraint :: String -> Constraint -> Bool
occursInConstraint v (Constraint _ ts) =
  any (occursIn v) ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "unify",TokSymbol ",",TokTypeIdent "UnifyError",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "unless",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "UnifyError",TokVLBrace,TokSymbol "=",TokTypeIdent "UnifyMismatch",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "UnifyOccursCheckFailed",TokTypeIdent "String",TokTypeIdent "Type",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokIdent "t",TokSymbol "=",TokIdent "varBind",TokIdent "a",TokIdent "t",TokNewline,TokIdent "unify",TokIdent "t",TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSymbol "=",TokIdent "varBind",TokIdent "a",TokIdent "t",TokNewline,TokIdent "unify",TokTypeIdent "TUnit",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "a",TokOperator "==",TokIdent "b",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a2",TokIdent "b2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "a1",TokIdent "a2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "length",TokIdent "xs",TokOperator "==",TokIdent "length",TokIdent "ys",TokSymbol "=",TokIdent "unifyMany",TokIdent "xs",TokIdent "ys",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TList",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "unify",TokIdent "a",TokIdent "b",TokNewline,TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokNewline,TokIdent "varBind",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "varBind",TokIdent "a",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokTypeIdent "TVar",TokIdent "a",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursCheck",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "a",TokOperator "==",TokIdent "b",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TCon",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokIdent "any",TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokIdent "ts",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t2",TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t1",TokOperator ":",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "t2",TokOperator ":",TokIdent "ts2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unifyMany",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unifyMany",TokIdent "ts1",TokIdent "ts2",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "bindVar",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokIdent "v",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokTypeIdent "TVar",TokIdent "v",TokSymbol "=",TokKeyword "return",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "v",TokIdent "`occursIn`",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursIn",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokIdent "v",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "x",TokArrow,TokIdent "x",TokOperator "==",TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "_",TokArrow,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokIdent "any",TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokIdent "cs",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokKeyword "if",TokIdent "v",TokIdent "`elem`",TokIdent "vs",TokKeyword "then",TokTypeIdent "False",TokKeyword "else",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokVRBrace,TokNewline,TokIdent "occursInConstraint",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokIdent "v",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "any",TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokIdent "ts",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Subst"
<< exportItem: next token=TokIdent "unify"
<< exportItem: next token=TokTypeIdent "UnifyError"
<< declBody: return DeclModule "TypeInference.Unify" (Just [ExportType "Subst" False,ExportVar "unify",ExportType "UnifyError" False])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unless"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataConstrRecord: TokTypeIdent "Type"
<< dataConstrNormal: "UnifyMismatch" [TCon "Type",TCon "Type"]
<< dataConstrRecord: TokTypeIdent "String"
<< dataConstrNormal: "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]
<< declBody: return DeclData "UnifyError" [] [Constraint "UnifyMismatch" [TCon "Type",TCon "Type"],Constraint "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]] ["Show","Eq"]
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "unify"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")
<< parseTypeCore: TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))
<< parseTypeCore: TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< parsed type signature: unify :: TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< returning DeclTypeSig: DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< declBody: return DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TVar"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TVar") [PVar "a"]
<< parsed pattern: PApp (PVar "TVar") [PVar "a"]
<< pPattern: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< parsed pattern: PVar "t"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PApp (PVar "TVar") [PVar "a"],PVar "t"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "varBind"
<< expr dispatch: TokIdent "varBind"
<< exprCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "unify"
<< infixOp: next token TokIdent "unify"
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokTypeIdent "TVar"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TVar") [PVar "a"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "t") [PApp (PVar "TVar") [PVar "a"]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokIdent "varBind"
<< exprCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "unify"
<< infixOp: next token TokIdent "unify"
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokTypeIdent "TUnit"
<< pConstrOrVar: next token TokTypeIdent "TUnit"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "TUnit") [PVar "TUnit"]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "unify"
<< infixOp: next token TokIdent "unify"
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PVar "a"]
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokIdent "b"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PVar "b"]
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PApp (PVar "TCon") [PVar "a"]) [PApp (PVar "TCon") [PVar "b"]]
<< pConstrOrVar: next token TokVLBrace
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "unify" [FunClause [PApp (PVar "TVar") [PVar "a"],PVar "t"] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "t") [PApp (PVar "TVar") [PVar "a"]]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "TUnit") [PVar "TUnit"]] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing]
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PVar "a"]
<< parsed pattern: PApp (PVar "TCon") [PVar "a"]
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TCon"
<< pConstrOrVar: next token TokIdent "b"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TCon") [PVar "b"]
<< parsed pattern: PApp (PVar "TCon") [PVar "b"]
<< pPattern: next token TokVLBrace
<< pConstrOrVar: next token TokVLBrace
<< funClause: args=[PApp (PVar "TCon") [PVar "a"],PApp (PVar "TCon") [PVar "b"]] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "a"
<< exprCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokOperator "=="
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "otherwise"
<< exprCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< guardedRhs: next token = TokVRBrace
<< parseGuardLine: next token=TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokTypeIdent "TArrow"
<< pConstrOrVar: next token TokIdent "a1"
<< pConstrOrVar: next token TokIdent "b1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TArrow") [PVar "a1",PVar "b1"]
<< pConstrOrVar: next token TokTypeIdent "TArrow"
<< pConstrOrVar: next token TokIdent "a2"
<< pConstrOrVar: next token TokIdent "b2"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TArrow") [PVar "a2",PVar "b2"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PApp (PVar "TArrow") [PVar "a1",PVar "b1"]) [PApp (PVar "TArrow") [PVar "a2",PVar "b2"]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "s1"
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "a1"
<< atomBaseCore next token: TokIdent "a2"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "s2"
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b2"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b2"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "b2"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pConstrOrVar: next token TokTypeIdent "Right"
<< pConstrOrVar: next token TokIdent "s2"
<< pConstrOrVar: next token TokIdent "`composeSubst`"
<< pConstrOrVar: next token TokIdent "s1"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") [PVar "`composeSubst`",PVar "s1"]
<< pConstrOrVar: next token TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "Right") [PApp (PVar "s2") [PVar "`composeSubst`",PVar "s1"]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "`composeSubst`"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "unify"
<< infixOp: next token TokIdent "unify"
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "xs"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PVar "xs"]
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "ys"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PVar "ys"]
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PApp (PVar "TTuple") [PVar "xs"]) [PApp (PVar "TTuple") [PVar "ys"]]
<< pConstrOrVar: next token TokVLBrace
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "unify" [FunClause [PApp (PVar "TCon") [PVar "a"],PApp (PVar "TCon") [PVar "b"]] (Just [(EApp (EApp (EVar "a") (EVar "==")) (EVar "b"),EApp (EVarType "Right") (EVar "emptySubst")),(EVar "otherwise",EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EApp (EVarType "TCon") (EVar "a"))) (EApp (EVarType "TCon") (EVar "b"))))]) Nothing Nothing,FunClause [PApp (PApp (PVar "TArrow") [PVar "a1",PVar "b1"]) [PApp (PVar "TArrow") [PVar "a2",PVar "b2"]]] Nothing (Just (EDo [Bind (PApp (PVar "s1") []) (EApp (EApp (EVar "unify") (EVar "a1")) (EVar "a2")),Bind (PApp (PVar "s2") []) (EApp (EApp (EVar "unify") (EApp (EApp (EVar "apply") (EVar "s1")) (EVar "b1"))) (EApp (EApp (EVar "apply") (EVar "s1")) (EVar "b2"))),ExprStmt (EApp (EVarType "Right") (EApp (EApp (EVar "s2") (EVar "`composeSubst`")) (EVar "s1")))])) Nothing]
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "xs"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PVar "xs"]
<< parsed pattern: PApp (PVar "TTuple") [PVar "xs"]
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokTypeIdent "TTuple"
<< pConstrOrVar: next token TokIdent "ys"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TTuple") [PVar "ys"]
<< parsed pattern: PApp (PVar "TTuple") [PVar "ys"]
<< pPattern: next token TokVLBrace
<< pConstrOrVar: next token TokVLBrace
<< funClause: args=[PApp (PVar "TTuple") [PVar "xs"],PApp (PVar "TTuple") [PVar "ys"]] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "length"
<< exprCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokOperator "=="
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokIdent "unifyMany"
<< exprCore next token: TokIdent "unifyMany"
<< atomBaseCore next token: TokIdent "unifyMany"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "otherwise"
<< exprCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< guardedRhs: next token = TokVRBrace
<< parseGuardLine: next token=TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokTypeIdent "TList"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TList") [PVar "a"]
<< pConstrOrVar: next token TokTypeIdent "TList"
<< pConstrOrVar: next token TokIdent "b"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "TList") [PVar "b"]
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PApp (PVar "TList") [PVar "a"]) [PApp (PVar "TList") [PVar "b"]]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "unify"
<< infixOp: next token TokIdent "unify"
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pConstrOrVar: next token TokIdent "t1"
<< pConstrOrVar: next token TokIdent "t2"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "t1") [PVar "t2"]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokTypeIdent "UnifyMismatch"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "varBind"
<< infixOp: next token TokIdent "varBind"
<< whereBlock: next tokenTokIdent "varBind"
<< funClauseWithName: next token=TokIdent "varBind"
<< declBody: return DeclFunGroup "unify" [FunClause [PApp (PVar "TTuple") [PVar "xs"],PApp (PVar "TTuple") [PVar "ys"]] (Just [(EApp (EApp (EApp (EApp (EVar "length") (EVar "xs")) (EVar "==")) (EVar "length")) (EVar "ys"),EApp (EApp (EVar "unifyMany") (EVar "xs")) (EVar "ys")),(EVar "otherwise",EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EApp (EVarType "TTuple") (EVar "xs"))) (EApp (EVarType "TTuple") (EVar "ys"))))]) Nothing Nothing,FunClause [PApp (PApp (PVar "TList") [PVar "a"]) [PApp (PVar "TList") [PVar "b"]]] Nothing (Just (EApp (EApp (EVar "unify") (EVar "a")) (EVar "b"))) Nothing,FunClause [PApp (PVar "t1") [PVar "t2"]] Nothing (Just (EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EVar "t1")) (EVar "t2")))) Nothing]
<< decl next token: TokIdent "varBind"
<< decl parser called
<< decl dispatch: TokIdent "varBind"
<< funDecl: next token=TokIdent "varBind"
<< funClause: next token=TokIdent "varBind"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "varBind"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")
<< parseTypeCore: TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))
<< parseTypeCore: TFun (TCon "String") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< parsed type signature: varBind :: TFun (TCon "String") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< returning DeclTypeSig: DeclTypeSig "varBind" (TFun (TCon "String") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< declBody: return DeclTypeSig "varBind" (TFun (TCon "String") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< decl next token: TokIdent "varBind"
<< decl parser called
<< decl dispatch: TokIdent "varBind"
<< funDecl: next token=TokIdent "varBind"
<< funClause: next token=TokIdent "varBind"
<< pPattern: next token TokIdent "a"
<< pConstrOrVar: next token TokIdent "a"
<< parsed pattern: PVar "a"
<< pPattern: next token TokIdent "t"
<< pConstrOrVar: next token TokIdent "t"
<< parsed pattern: PVar "t"
<< pPattern: next token TokVLBrace
<< pConstrOrVar: next token TokVLBrace
<< funClause: args=[PVar "a",PVar "t"] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "t"
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokOperator "=="
<< atomBaseCore next token: TokTypeIdent "TVar"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "occursCheck"
<< exprCore next token: TokIdent "occursCheck"
<< atomBaseCore next token: TokIdent "occursCheck"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokTypeIdent "UnifyOccursCheckFailed"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "otherwise"
<< exprCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokIdent "otherwise"
<< atomBaseCore next token: TokSymbol "="
<< whereClause: next token TokSymbol "="
<< infixOp: next token TokSymbol "="
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokDot
<< exprCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokDot
<< exprCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokTypeIdent "M"
<< atomBaseCore next token: TokDot
<< atomBaseCore next token: TokSymbol "("
<< whereClause: next token TokSymbol "("
<< infixOp: next token TokSymbol "("
<< guardedRhs: next token = TokSymbol "("
<< parseGuardLine: next token=TokSymbol "("
<< whereBlock: next tokenTokSymbol "("
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "varBind"
<< typeSigDecl:2 TokIdent "a"
<< valueDecl: TokIdent "varBind"
<< pConstrOrVar: next token TokIdent "varBind"
<< pConstrOrVar: next token TokIdent "a"
<< pConstrOrVar: next token TokIdent "t"
<< pConstrOrVar: next token TokVLBrace
<< patternParser: (pAs <|> makeCons)PApp (PVar "varBind") [PVar "a",PVar "t"]
Just ([DeclModule "TypeInference.Unify" (Just [ExportType "Subst" False,ExportVar "unify",ExportType "UnifyError" False]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unless"]},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclData "UnifyError" [] [Constraint "UnifyMismatch" [TCon "Type",TCon "Type"],Constraint "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]] ["Show","Eq"],DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))),DeclFunGroup "unify" [FunClause [PApp (PVar "TVar") [PVar "a"],PVar "t"] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "t") [PApp (PVar "TVar") [PVar "a"]]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "TUnit") [PVar "TUnit"]] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing],DeclFunGroup "unify" [FunClause [PApp (PVar "TCon") [PVar "a"],PApp (PVar "TCon") [PVar "b"]] (Just [(EApp (EApp (EVar "a") (EVar "==")) (EVar "b"),EApp (EVarType "Right") (EVar "emptySubst")),(EVar "otherwise",EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EApp (EVarType "TCon") (EVar "a"))) (EApp (EVarType "TCon") (EVar "b"))))]) Nothing Nothing,FunClause [PApp (PApp (PVar "TArrow") [PVar "a1",PVar "b1"]) [PApp (PVar "TArrow") [PVar "a2",PVar "b2"]]] Nothing (Just (EDo [Bind (PApp (PVar "s1") []) (EApp (EApp (EVar "unify") (EVar "a1")) (EVar "a2")),Bind (PApp (PVar "s2") []) (EApp (EApp (EVar "unify") (EApp (EApp (EVar "apply") (EVar "s1")) (EVar "b1"))) (EApp (EApp (EVar "apply") (EVar "s1")) (EVar "b2"))),ExprStmt (EApp (EVarType "Right") (EApp (EApp (EVar "s2") (EVar "`composeSubst`")) (EVar "s1")))])) Nothing],DeclFunGroup "unify" [FunClause [PApp (PVar "TTuple") [PVar "xs"],PApp (PVar "TTuple") [PVar "ys"]] (Just [(EApp (EApp (EApp (EApp (EVar "length") (EVar "xs")) (EVar "==")) (EVar "length")) (EVar "ys"),EApp (EApp (EVar "unifyMany") (EVar "xs")) (EVar "ys")),(EVar "otherwise",EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EApp (EVarType "TTuple") (EVar "xs"))) (EApp (EVarType "TTuple") (EVar "ys"))))]) Nothing Nothing,FunClause [PApp (PApp (PVar "TList") [PVar "a"]) [PApp (PVar "TList") [PVar "b"]]] Nothing (Just (EApp (EApp (EVar "unify") (EVar "a")) (EVar "b"))) Nothing,FunClause [PApp (PVar "t1") [PVar "t2"]] Nothing (Just (EApp (EVarType "Left") (EApp (EApp (EVarType "UnifyMismatch") (EVar "t1")) (EVar "t2")))) Nothing],DeclTypeSig "varBind" (TFun (TCon "String") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))],[TokNewline,TokIdent "varBind",TokIdent "a",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokTypeIdent "TVar",TokIdent "a",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursCheck",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "a",TokOperator "==",TokIdent "b",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TCon",TokIdent "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokIdent "any",TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokIdent "ts",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t2",TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t1",TokOperator ":",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "t2",TokOperator ":",TokIdent "ts2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unifyMany",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokIdent "`composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unifyMany",TokIdent "ts1",TokIdent "ts2",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "bindVar",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokIdent "v",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokOperator "==",TokTypeIdent "TVar",TokIdent "v",TokSymbol "=",TokKeyword "return",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "v",TokIdent "`occursIn`",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursIn",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokIdent "v",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "x",TokArrow,TokIdent "x",TokOperator "==",TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "_",TokArrow,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokIdent "any",TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokIdent "cs",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokKeyword "if",TokIdent "v",TokIdent "`elem`",TokIdent "vs",TokKeyword "then",TokTypeIdent "False",TokKeyword "else",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokVRBrace,TokNewline,TokIdent "occursInConstraint",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokIdent "v",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "any",TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokIdent "ts",TokVRBrace,TokNewline])

=== Running: src/Utils/MyTrace.hs ===
-- Raw Source --
{- NOINLINE traceEnabled -}

module Utils.MyTrace (myTrace, myTraceIO, myTraceShowId, traceEnabled, setTrace) where

import Control.Monad (when)
import Data.IORef
import Debug.Trace (trace, traceIO, traceShowId)
import Parser.Core.Combinator (Parser (..))
import System.IO.Unsafe (unsafePerformIO)

traceEnabled :: IORef Bool
traceEnabled = unsafePerformIO (newIORef True)

setTrace :: Bool -> IO ()
setTrace b = writeIORef traceEnabled b

myTrace :: String -> Parser ()
myTrace msg = Parser $ \input -> unsafePerformIO $ do
  enabled <- readIORef traceEnabled
  when enabled (putStrLn msg)
  return (Just ((), input))

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: (Show a) => a -> a
myTraceShowId = traceShowId

{-}
#ifdef ENABLE_TRACE
myTrace :: String -> a -> a
myTrace = trace

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: Show a => a -> a
myTraceShowId = traceShowId
#else
myTrace :: String -> a -> a
myTrace _ x = x

myTraceIO :: String -> IO ()
myTraceIO _ = pure ()

myTraceShowId :: Show a => a -> a
myTraceShowId = id
#endif
-}

-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ",",TokIdent "myTraceIO",TokSymbol ",",TokIdent "myTraceShowId",TokSymbol ",",TokIdent "traceEnabled",TokSymbol ",",TokIdent "setTrace",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "when",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokIdent "traceEnabled",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Bool",TokNewline,TokIdent "traceEnabled",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokTypeIdent "True",TokSymbol ")",TokNewline,TokIdent "setTrace",TokSymbol "::",TokTypeIdent "Bool",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "setTrace",TokIdent "b",TokSymbol "=",TokIdent "writeIORef",TokIdent "traceEnabled",TokIdent "b",TokNewline,TokIdent "myTrace",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTrace",TokIdent "msg",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokIdent "unsafePerformIO",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "enabled",TokSymbol "<-",TokIdent "readIORef",TokIdent "traceEnabled",TokSymbol ";",TokIdent "when",TokIdent "enabled",TokSymbol "(",TokIdent "putStrLn",TokIdent "msg",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokSymbol "(",TokSymbol "(",TokSymbol ")",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "myTraceIO",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokSymbol ")",TokNewline,TokIdent "myTraceIO",TokSymbol "=",TokIdent "traceIO",TokNewline,TokIdent "myTraceShowId",TokSymbol "::",TokSymbol "(",TokTypeIdent "Show",TokIdent "a",TokSymbol ")",TokKeyword "=>",TokIdent "a",TokArrow,TokIdent "a",TokNewline,TokIdent "myTraceShowId",TokSymbol "=",TokIdent "traceShowId",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "myTrace"
<< exportItem: next token=TokIdent "myTraceIO"
<< exportItem: next token=TokIdent "myTraceShowId"
<< exportItem: next token=TokIdent "traceEnabled"
<< exportItem: next token=TokIdent "setTrace"
<< declBody: return DeclModule "Utils.MyTrace" (Just [ExportVar "myTrace",ExportVar "myTraceIO",ExportVar "myTraceShowId",ExportVar "traceEnabled",ExportVar "setTrace"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "when"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Debug"
<< declBody: return DeclImport {importQualified = False, importModule = "Debug.Trace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "trace",ImportVar "traceIO",ImportVar "traceShowId"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO.Unsafe", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unsafePerformIO"]}
<< decl next token: TokIdent "traceEnabled"
<< decl parser called
<< decl dispatch: TokIdent "traceEnabled"
<< funDecl: next token=TokIdent "traceEnabled"
<< funClause: next token=TokIdent "traceEnabled"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "traceEnabled"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "IORef"
<< parseTypeCore: TApp (TCon "IORef") (TCon "Bool")
<< parsed type signature: traceEnabled :: TApp (TCon "IORef") (TCon "Bool")
<< returning DeclTypeSig: DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool"))
<< declBody: return DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool"))
<< decl next token: TokIdent "traceEnabled"
<< decl parser called
<< decl dispatch: TokIdent "traceEnabled"
<< funDecl: next token=TokIdent "traceEnabled"
<< funClause: next token=TokIdent "traceEnabled"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "unsafePerformIO"
<< expr dispatch: TokIdent "unsafePerformIO"
<< exprCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokIdent "unsafePerformIO"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "setTrace"
<< infixOp: next token TokIdent "setTrace"
<< whereBlock: next tokenTokIdent "setTrace"
<< funClauseWithName: next token=TokIdent "setTrace"
<< declBody: return DeclFunGroup "traceEnabled" [FunClause [] Nothing (Just (EApp (EVar "unsafePerformIO") (EApp (EVar "newIORef") (EVarType "True")))) Nothing]
<< decl next token: TokIdent "setTrace"
<< decl parser called
<< decl dispatch: TokIdent "setTrace"
<< funDecl: next token=TokIdent "setTrace"
<< funClause: next token=TokIdent "setTrace"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "setTrace"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "Bool"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parseTypeCore: TFun (TCon "Bool") (TApp (TCon "IO") TUnit)
<< parsed type signature: setTrace :: TFun (TCon "Bool") (TApp (TCon "IO") TUnit)
<< returning DeclTypeSig: DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit))
<< declBody: return DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit))
<< decl next token: TokIdent "setTrace"
<< decl parser called
<< decl dispatch: TokIdent "setTrace"
<< funDecl: next token=TokIdent "setTrace"
<< funClause: next token=TokIdent "setTrace"
<< pPattern: next token TokIdent "b"
<< pConstrOrVar: next token TokIdent "b"
<< parsed pattern: PVar "b"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "b"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "writeIORef"
<< expr dispatch: TokIdent "writeIORef"
<< exprCore next token: TokIdent "writeIORef"
<< atomBaseCore next token: TokIdent "writeIORef"
<< atomBaseCore next token: TokIdent "traceEnabled"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "myTrace"
<< infixOp: next token TokIdent "myTrace"
<< whereBlock: next tokenTokIdent "myTrace"
<< funClauseWithName: next token=TokIdent "myTrace"
<< declBody: return DeclFunGroup "setTrace" [FunClause [PVar "b"] Nothing (Just (EApp (EApp (EVar "writeIORef") (EVar "traceEnabled")) (EVar "b"))) Nothing]
<< decl next token: TokIdent "myTrace"
<< decl parser called
<< decl dispatch: TokIdent "myTrace"
<< funDecl: next token=TokIdent "myTrace"
<< funClause: next token=TokIdent "myTrace"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "myTrace"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TCon "Parser") TUnit
<< parseTypeCore: TFun (TCon "String") (TApp (TCon "Parser") TUnit)
<< parsed type signature: myTrace :: TFun (TCon "String") (TApp (TCon "Parser") TUnit)
<< returning DeclTypeSig: DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit))
<< declBody: return DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit))
<< decl next token: TokIdent "myTrace"
<< decl parser called
<< decl dispatch: TokIdent "myTrace"
<< funDecl: next token=TokIdent "myTrace"
<< funClause: next token=TokIdent "myTrace"
<< pPattern: next token TokIdent "msg"
<< pConstrOrVar: next token TokIdent "msg"
<< parsed pattern: PVar "msg"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "msg"] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Parser"
<< expr dispatch: TokTypeIdent "Parser"
<< exprCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokOperator "$"
<< postfix: infix operator = "$"
<< expr dispatch: TokSymbol "\\"
<< exprCore next token: TokSymbol "\\"
<< pConstrOrVar: next token TokIdent "input"
<< pConstrOrVar: next token TokArrow
<< pattern1: (pAs <|> makeCons)PApp (PVar "input") []
<< exprCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokOperator "$"
<< postfix: infix operator = "$"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "enabled"
<< pConstrOrVar: next token TokIdent "enabled"
<< pConstrOrVar: next token TokSymbol "<-"
<< pattern1: (pAs <|> makeCons)PApp (PVar "enabled") []
<< expr dispatch: TokIdent "readIORef"
<< exprCore next token: TokIdent "readIORef"
<< atomBaseCore next token: TokIdent "readIORef"
<< atomBaseCore next token: TokIdent "traceEnabled"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokIdent "when"
<< pConstrOrVar: next token TokIdent "when"
<< pConstrOrVar: next token TokIdent "enabled"
<< pConstrOrVar: next token TokIdent "putStrLn"
<< pConstrOrVar: next token TokIdent "msg"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "putStrLn") [PVar "msg"]
<< pConstrOrVar: next token TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "when") [PVar "enabled",PApp (PVar "putStrLn") [PVar "msg"]]
<< expr dispatch: TokIdent "when"
<< exprCore next token: TokIdent "when"
<< atomBaseCore next token: TokIdent "when"
<< atomBaseCore next token: TokIdent "enabled"
<< exprCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "msg"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "msg"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "msg"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "input"
<< atomBaseCore next token: TokIdent "input"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "input"
<< atomBaseCore next token: TokIdent "input"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "input"
<< atomBaseCore next token: TokIdent "input"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereClause: next token TokIdent "myTraceIO"
<< infixOp: next token TokIdent "myTraceIO"
<< whereClause: next token TokIdent "myTraceIO"
<< infixOp: next token TokIdent "myTraceIO"
<< whereClause: next token TokIdent "myTraceIO"
<< infixOp: next token TokIdent "myTraceIO"
<< whereBlock: next tokenTokIdent "myTraceIO"
<< funClauseWithName: next token=TokIdent "myTraceIO"
<< declBody: return DeclFunGroup "myTrace" [FunClause [PVar "msg"] Nothing (Just (EApp (EApp (EVar "$") (EVarType "Parser")) (EApp (EApp (EVar "$") (ELam (PApp (PVar "input") []) (EVar "unsafePerformIO"))) (EDo [Bind (PApp (PVar "enabled") []) (EApp (EVar "readIORef") (EVar "traceEnabled")),ExprStmt (EApp (EApp (EVar "when") (EVar "enabled")) (EApp (EVar "putStrLn") (EVar "msg"))),ExprStmt (EReturn (EApp (EVarType "Just") (ETuple [EUnit,EVar "input"])))])))) Nothing]
<< decl next token: TokIdent "myTraceIO"
<< decl parser called
<< decl dispatch: TokIdent "myTraceIO"
<< funDecl: next token=TokIdent "myTraceIO"
<< funClause: next token=TokIdent "myTraceIO"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "myTraceIO"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parseTypeCore: TFun (TCon "String") (TApp (TCon "IO") TUnit)
<< parsed type signature: myTraceIO :: TFun (TCon "String") (TApp (TCon "IO") TUnit)
<< returning DeclTypeSig: DeclTypeSig "myTraceIO" (TFun (TCon "String") (TApp (TCon "IO") TUnit))
<< declBody: return DeclTypeSig "myTraceIO" (TFun (TCon "String") (TApp (TCon "IO") TUnit))
<< decl next token: TokIdent "myTraceIO"
<< decl parser called
<< decl dispatch: TokIdent "myTraceIO"
<< funDecl: next token=TokIdent "myTraceIO"
<< funClause: next token=TokIdent "myTraceIO"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "traceIO"
<< expr dispatch: TokIdent "traceIO"
<< exprCore next token: TokIdent "traceIO"
<< atomBaseCore next token: TokIdent "traceIO"
<< atomBaseCore next token: TokNewline
<< whereClause: next token TokIdent "myTraceShowId"
<< infixOp: next token TokIdent "myTraceShowId"
<< whereBlock: next tokenTokIdent "myTraceShowId"
<< funClauseWithName: next token=TokIdent "myTraceShowId"
<< declBody: return DeclFunGroup "myTraceIO" [FunClause [] Nothing (Just (EVar "traceIO")) Nothing]
<< decl next token: TokIdent "myTraceShowId"
<< decl parser called
<< decl dispatch: TokIdent "myTraceShowId"
<< funDecl: next token=TokIdent "myTraceShowId"
<< funClause: next token=TokIdent "myTraceShowId"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "myTraceShowId"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokSymbol "("
<< parseTypeCore: TApp (TCon "Show") (TVar "a")
<< parseTypeCore: TApp (TCon "Show") (TVar "a")
<< parseTypeCore: TVar "a"
<< parseTypeCore: TFun (TVar "a") (TVar "a")
<< parsed type signature: myTraceShowId :: TConstraint [Constraint "Show" [TVar "a"]] (TFun (TVar "a") (TVar "a"))
<< returning DeclTypeSig: DeclTypeSig "myTraceShowId" (TConstraint [Constraint "Show" [TVar "a"]] (TFun (TVar "a") (TVar "a")))
<< declBody: return DeclTypeSig "myTraceShowId" (TConstraint [Constraint "Show" [TVar "a"]] (TFun (TVar "a") (TVar "a")))
<< decl next token: TokIdent "myTraceShowId"
<< decl parser called
<< decl dispatch: TokIdent "myTraceShowId"
<< funDecl: next token=TokIdent "myTraceShowId"
<< funClause: next token=TokIdent "myTraceShowId"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "traceShowId"
<< expr dispatch: TokIdent "traceShowId"
<< exprCore next token: TokIdent "traceShowId"
<< atomBaseCore next token: TokIdent "traceShowId"
<< atomBaseCore next token: TokNewline
<< typeSigDecl: TokIdent "myTraceShowId"
<< typeSigDecl:2 TokSymbol "="
<< valueDecl: TokIdent "myTraceShowId"
<< pConstrOrVar: next token TokIdent "myTraceShowId"
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "myTraceShowId") []
<< expr dispatch: TokIdent "traceShowId"
<< exprCore next token: TokIdent "traceShowId"
<< atomBaseCore next token: TokIdent "traceShowId"
<< atomBaseCore next token: TokNewline
Just ([DeclModule "Utils.MyTrace" (Just [ExportVar "myTrace",ExportVar "myTraceIO",ExportVar "myTraceShowId",ExportVar "traceEnabled",ExportVar "setTrace"]),DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "when"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Debug.Trace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "trace",ImportVar "traceIO",ImportVar "traceShowId"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser"]},DeclImport {importQualified = False, importModule = "System.IO.Unsafe", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unsafePerformIO"]},DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool")),DeclFunGroup "traceEnabled" [FunClause [] Nothing (Just (EApp (EVar "unsafePerformIO") (EApp (EVar "newIORef") (EVarType "True")))) Nothing],DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit)),DeclFunGroup "setTrace" [FunClause [PVar "b"] Nothing (Just (EApp (EApp (EVar "writeIORef") (EVar "traceEnabled")) (EVar "b"))) Nothing],DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit)),DeclFunGroup "myTrace" [FunClause [PVar "msg"] Nothing (Just (EApp (EApp (EVar "$") (EVarType "Parser")) (EApp (EApp (EVar "$") (ELam (PApp (PVar "input") []) (EVar "unsafePerformIO"))) (EDo [Bind (PApp (PVar "enabled") []) (EApp (EVar "readIORef") (EVar "traceEnabled")),ExprStmt (EApp (EApp (EVar "when") (EVar "enabled")) (EApp (EVar "putStrLn") (EVar "msg"))),ExprStmt (EReturn (EApp (EVarType "Just") (ETuple [EUnit,EVar "input"])))])))) Nothing],DeclTypeSig "myTraceIO" (TFun (TCon "String") (TApp (TCon "IO") TUnit)),DeclFunGroup "myTraceIO" [FunClause [] Nothing (Just (EVar "traceIO")) Nothing],DeclTypeSig "myTraceShowId" (TConstraint [Constraint "Show" [TVar "a"]] (TFun (TVar "a") (TVar "a")))],[TokNewline,TokIdent "myTraceShowId",TokSymbol "=",TokIdent "traceShowId",TokNewline])

=== Running: src/Utils/SQLUtils.hs ===
-- Raw Source --
module Utils.SQLUtils (extractSQLVars) where

extractSQLVars :: String -> (String, [String])
extractSQLVars = go "" [] ""
  where
    go acc vars current [] =
      (acc, reverse vars)

    go acc vars current ('{':xs) =
      let (var, rest) = span (/= '}') xs
      in go (acc ++ "?") (var : vars) "" (drop 1 rest)

    go acc vars current (x:xs) =
      go (acc ++ [x]) vars current xs


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokSymbol "(",TokIdent "extractSQLVars",TokSymbol ")",TokKeyword "where",TokNewline,TokIdent "extractSQLVars",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "extractSQLVars",TokSymbol "=",TokIdent "go",TokString "",TokSymbol "[",TokSymbol "]",TokString "",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokChar '{',TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokOperator "/=",TokChar '}',TokSymbol ")",TokIdent "xs",TokSymbol ";",TokKeyword "in",TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSymbol "(",TokIdent "var",TokOperator ":",TokIdent "vars",TokSymbol ")",TokString "",TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokIdent "vars",TokIdent "current",TokIdent "xs",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "extractSQLVars"
<< declBody: return DeclModule "Utils.SQLUtils" (Just [ExportVar "extractSQLVars"])
<< decl next token: TokIdent "extractSQLVars"
<< decl parser called
<< decl dispatch: TokIdent "extractSQLVars"
<< funDecl: next token=TokIdent "extractSQLVars"
<< funClause: next token=TokIdent "extractSQLVars"
<< pPattern: next token TokSymbol "::"
<< pConstrOrVar: next token TokSymbol "::"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "extractSQLVars"
<< typeSigDecl:2 TokSymbol "::"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TList (TCon "String")
<< parseTypeCore: TTuple [TCon "String",TList (TCon "String")]
<< parseTypeCore: TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])
<< parsed type signature: extractSQLVars :: TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])
<< returning DeclTypeSig: DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")]))
<< declBody: return DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")]))
<< decl next token: TokIdent "extractSQLVars"
<< decl parser called
<< decl dispatch: TokIdent "extractSQLVars"
<< funDecl: next token=TokIdent "extractSQLVars"
<< funClause: next token=TokIdent "extractSQLVars"
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokString ""
<< atomBaseCore next token: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< atomBaseCore next token: TokString ""
<< atomBaseCore next token: TokVLBrace
<< whereClause: next token TokVLBrace
<< infixOp: next token TokVLBrace
<< whereBlock: next tokenTokKeyword "where"
<< whereBlock:2 next tokenTokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokIdent "acc"
<< pConstrOrVar: next token TokIdent "acc"
<< parsed pattern: PVar "acc"
<< pPattern: next token TokIdent "vars"
<< pConstrOrVar: next token TokIdent "vars"
<< parsed pattern: PVar "vars"
<< pPattern: next token TokIdent "current"
<< pConstrOrVar: next token TokIdent "current"
<< parsed pattern: PVar "current"
<< pPattern: next token TokSymbol "["
<< pConstrOrVar: next token TokSymbol "]"
<< parsed pattern: PList []
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "acc",PVar "vars",PVar "current",PList []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "acc"
<< atomBaseCore next token: TokIdent "acc"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "acc"
<< atomBaseCore next token: TokIdent "acc"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "reverse"
<< atomBaseCore next token: TokIdent "reverse"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereClause: next token TokVRBrace
<< infixOp: next token TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pConstrOrVar: next token TokIdent "acc"
<< pConstrOrVar: next token TokIdent "vars"
<< pConstrOrVar: next token TokIdent "current"
<< pConstrOrVar: next token TokChar '{'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "xs"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])
<< pConstrOrVar: next token TokSymbol "="
<< patternParser: (pAs <|> makeCons)PApp (PVar "acc") [PVar "vars",PVar "current",PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])]
<< pConstrOrVar: next token TokSymbol "="
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "var"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "var") []
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "var") [],PApp (PVar "rest") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar '}'
<< atomBaseCore next token: TokChar '}'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< valueBinding next token: TokKeyword "in"
<< funBinding next token: TokKeyword "in"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< whereBlock: next tokenTokSymbol ";"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pPattern: next token TokIdent "acc"
<< pConstrOrVar: next token TokIdent "acc"
<< parsed pattern: PVar "acc"
<< pPattern: next token TokIdent "vars"
<< pConstrOrVar: next token TokIdent "vars"
<< parsed pattern: PVar "vars"
<< pPattern: next token TokIdent "current"
<< pConstrOrVar: next token TokIdent "current"
<< parsed pattern: PVar "current"
<< pPattern: next token TokSymbol "("
<< pConstrOrVar: next token TokChar '{'
<< pConstrOrVar: next token TokOperator ":"
<< pConstrOrVar: next token TokIdent "xs"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])
<< parsed pattern: PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])
<< pPattern: next token TokSymbol "="
<< pConstrOrVar: next token TokSymbol "="
<< funClause: args=[PVar "acc",PVar "vars",PVar "current",PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pConstrOrVar: next token TokIdent "var"
<< pConstrOrVar: next token TokSymbol ","
<< pattern1: (pAs <|> makeCons)PApp (PVar "var") []
<< pConstrOrVar: next token TokIdent "rest"
<< pConstrOrVar: next token TokSymbol ")"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< pConstrOrVar: next token TokSymbol "="
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "var") [],PApp (PVar "rest") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar '}'
<< atomBaseCore next token: TokChar '}'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< valueBinding next token: TokKeyword "in"
<< funBinding next token: TokKeyword "in"
<< whereClause: next token TokSymbol ";"
<< infixOp: next token TokSymbol ";"
<< whereBlock: next tokenTokSymbol ";"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "extractSQLVars" [FunClause [] Nothing (Just (EApp (EApp (EApp (EVar "go") (EString "")) (EList [])) (EString ""))) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Utils.SQLUtils" (Just [ExportVar "extractSQLVars"]),DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])),DeclFunGroup "extractSQLVars" [FunClause [] Nothing (Just (EApp (EApp (EApp (EVar "go") (EString "")) (EList [])) (EString ""))) Nothing]],[TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokChar '{',TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokOperator "/=",TokChar '}',TokSymbol ")",TokIdent "xs",TokSymbol ";",TokKeyword "in",TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSymbol "(",TokIdent "var",TokOperator ":",TokIdent "vars",TokSymbol ")",TokString "",TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokIdent "vars",TokIdent "current",TokIdent "xs",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

