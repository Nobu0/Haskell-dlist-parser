=== Running Parser Test Suite ===

-- Simple let-return --
-- Input: do { let x = 1; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EReturn (EVar "x"))])

-- Multiple lets --
-- Input: do { let x = 1; let y = 2; return (x + y) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "let",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator "+",TokIdent "y",TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],LetStmt [(PVar "y",EInt 2)],ExprStmt (EReturn (EBinOp "+" (EVar "x") (EVar "y")))])

-- If in do --
-- Input: do { let x = 10; if x > 5 then return x else return 0 }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 10,TokSymbol ";",TokKeyword "if",TokIdent "x",TokOperator ">",TokNumber 5,TokKeyword "then",TokKeyword "return",TokIdent "x",TokKeyword "else",TokKeyword "return",TokNumber 0,TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 10)],ExprStmt (EIf (EBinOp ">" (EVar "x") (EInt 5)) (EReturn (EVar "x")) (EReturn (EInt 0)))])

-- Nested do --
-- Input: do { let x = 1; do { let y = x + 1; return y } }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EDo [LetStmt [(PVar "y",EBinOp "+" (EVar "x") (EInt 1))],ExprStmt (EReturn (EVar "y"))])])

-- Do in if --
-- Input: if cond then do { let x = 1; return x } else return 0
Tokens: [TokKeyword "if",TokIdent "cond",TokKeyword "then",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}",TokKeyword "else",TokKeyword "return",TokNumber 0]
Just (EIf (EVar "cond") (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EReturn (EVar "x"))]) (EReturn (EInt 0)))

-- Let with lambda --
-- Input: do { let f = \x -> x + 1 * 2; return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "\\",TokIdent "x",TokArrow,TokIdent "x",TokOperator "+",TokNumber 1,TokOperator "*",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "f",ELam "x" (EBinOp "+" (EVar "x") (EBinOp "*" (EInt 1) (EInt 2))))],ExprStmt (EReturn (EApp (EVar "f") (EInt 10)))])

-- Let without semicolon --
-- Input: do { let x = 1 return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokKeyword "return",TokIdent "x",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EReturn (EVar "x"))])

-- Do in case --
-- Input: case v of Just x -> do { let y = x + 1; return y }; Nothing -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "x",TokArrow,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokNumber 0]
Just (ECase (EVar "v") [CaseAlt (PApp (PConstr "Just" []) (PVar "x")) (EDo [LetStmt [(PVar "y",EBinOp "+" (EVar "x") (EInt 1))],ExprStmt (EReturn (EVar "y"))]),CaseAlt (PConstr "Nothing" []) (EReturn (EInt 0))])

-- Empty do --
-- Input: do { }
Tokens: [TokKeyword "do",TokSymbol "{",TokSymbol "}"]
Just (EDo [])

-- Case with as-pattern --
-- Input: case v of x@(Just y) -> return x _ -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokIdent "x",TokSymbol "@",TokSymbol "(",TokTypeIdent "Just",TokIdent "y",TokSymbol ")",TokArrow,TokKeyword "return",TokIdent "x",TokSymbol "_",TokArrow,TokKeyword "return",TokNumber 0]
Just (ECase (EVar "v") [CaseAlt (PAs "x" (PApp (PConstr "Just" []) (PVar "y"))) (EReturn (EVar "x")),CaseAlt PWildcard (EReturn (EInt 0))])

-- x; y; z statements --
-- Input: x; y; z
Tokens: [TokIdent "x",TokSymbol ";",TokIdent "y",TokSymbol ";",TokIdent "z"]
Just (ESeq [EVar "x",EVar "y",EVar "z"])

-- Let with case --
-- Input: do { let x = case v of Just n -> n; Nothing -> 0; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "n",TokArrow,TokIdent "n",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokNumber 0,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",ECase (EVar "v") [CaseAlt (PApp (PConstr "Just" []) (PVar "n")) (EVar "n"),CaseAlt (PConstr "Nothing" []) (EInt 0)])],ExprStmt (EReturn (EVar "x"))])

-- simple --
-- Input: { x = 1 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}"]
Just (ERecord [("x",EInt 1)])

-- 2 --
-- Input: { x = 1, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

-- tag --
-- Input: r { x = 3 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3)]))

-- nest --
-- Input: { a = { b = 3 } }
Tokens: [TokSymbol "{",TokIdent "a",TokSymbol "=",TokSymbol "{",TokIdent "b",TokSymbol "=",TokNumber 3,TokSymbol "}",TokSymbol "}"]
Just (ERecord [("a",ERecord [("b",EInt 3)])])

-- 2 equation --
-- Input: { x = 1 + 2, y = f 3 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ",",TokIdent "y",TokSymbol "=",TokIdent "f",TokNumber 3,TokSymbol "}"]
Just (ERecord [("x",EBinOp "+" (EInt 1) (EInt 2)),("y",EApp (EVar "f") (EInt 3))])

-- space --
-- Input: {  x=1 , y =2}
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

--  --
-- Input: r { x = 3, y = 4 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 4,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3),("y",EInt 4)]))

--  --
-- Input: (f x) { y = 10 }
Tokens: [TokSymbol "(",TokIdent "f",TokIdent "x",TokSymbol ")",TokSymbol "{",TokIdent "y",TokSymbol "=",TokNumber 10,TokSymbol "}"]
Just (EApp (EApp (EVar "f") (EVar "x")) (ERecord [("y",EInt 10)]))

--  --
-- Input: { x = 1, y = 2 } { x = 9 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 9,TokSymbol "}"]
Just (EApp (ERecord [("x",EInt 1),("y",EInt 2)]) (ERecord [("x",EInt 9)]))

--  --
-- Input: (+ 1)
Tokens: [TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: (1 +)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (EInt 1) "+")

--  --
-- Input: (* 2) (2 *) (> 3) (3 >)
Tokens: [TokSymbol "(",TokOperator "*",TokNumber 2,TokSymbol ")",TokSymbol "(",TokNumber 2,TokOperator "*",TokSymbol ")",TokSymbol "(",TokOperator ">",TokNumber 3,TokSymbol ")",TokSymbol "(",TokNumber 3,TokOperator ">",TokSymbol ")"]
Just (EApp (EApp (EApp (EOpSectionL "*" (EInt 2)) (EOpSectionR (EInt 2) "*")) (EOpSectionL ">" (EInt 3))) (EOpSectionR (EInt 3) ">"))

--  --
-- Input: ((+ 1))
Tokens: [TokSymbol "(",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: { f = (+ 1) }
Tokens: [TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol "}"]
Just (ERecord [("f",EOpSectionL "+" (EInt 1))])

--  --
-- Input: r { f = (1 +) }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")",TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("f",EOpSectionR (EInt 1) "+")]))

--  --
-- Input: ({ x = 1 } +)
Tokens: [TokSymbol "(",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (ERecord [("x",EInt 1)]) "+")

--  --
-- Input: do { let r = { x = 1 }; return r }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokIdent "r",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "r",ERecord [("x",EInt 1)])],ExprStmt (EReturn (EVar "r"))])

--  --
-- Input: do { let r = { x = 1 }; return (r { x = 2 }) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "r",ERecord [("x",EInt 1)])],ExprStmt (EReturn (EApp (EVar "r") (ERecord [("x",EInt 2)])))])

--  --
-- Input: do { let f = (+ 1); return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "f",EOpSectionL "+" (EInt 1))],ExprStmt (EReturn (EApp (EVar "f") (EInt 10)))])

-- error1 --
-- Input: { = 1 }
Tokens: [TokSymbol "{",TokSymbol "=",TokNumber 1,TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
Nothing

-- error2 --
-- Input: { x = 1,, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokNumber 1
<< atomBase next token: TokNumber 1
<< int: 1
<< atomBase next token: TokSymbol ","
<< expr next token: TokSymbol "{"
<< atomBase next token: TokSymbol "{"
<< expr next token: TokNumber 1
<< atomBase next token: TokNumber 1
<< int: 1
<< atomBase next token: TokSymbol ","
Nothing

-- error3 --
-- Input: ()
Tokens: [TokSymbol "(",TokSymbol ")"]
XX Parser failed! Re-running with trace:
>> exprSeq
<< expr next token: TokSymbol "("
<< atomBase next token: TokSymbol ")"
<< expr next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol "("
<< expr next token: TokSymbol "("
<< atomBase next token: TokSymbol ")"
<< expr next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol ")"
<< atomBase next token: TokSymbol "("
Nothing

-- error4 Ok --
-- Input: (1 + 2)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ")"]
Just (EBinOp "+" (EInt 1) (EInt 2))

-- case gard1 --
-- Input: case x of { p | cond1 -> e1; p2 | cond2 -> e2; p3 -> e3 }
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokSymbol "{",TokIdent "p",TokSymbol "|",TokIdent "cond1",TokArrow,TokIdent "e1",TokSymbol ";",TokIdent "p2",TokSymbol "|",TokIdent "cond2",TokArrow,TokIdent "e2",TokSymbol ";",TokIdent "p3",TokArrow,TokIdent "e3",TokSymbol "}"]
Just (ECase (EVar "x") [CaseAltGuard (PVar "p") [(EVar "cond1",EVar "e1")],CaseAltGuard (PVar "p2") [(EVar "cond2",EVar "e2")],CaseAlt (PVar "p3") (EVar "e3")])

-- case gard2 --
-- Input: case x of n | n < 0 -> 1 
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt 1)]])

-- case gard3 --
-- Input: case x of n | n < 0 -> -1 | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt (-1)),(EBinOp ">" (EVar "n") (EInt 0),EInt 1)]])

-- case gard4 --
-- Input: case x of n | n < 0 -> -1
  0 -> 0
  n | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokNewline,TokNumber 0,TokArrow,TokNumber 0,TokNewline,TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
Just (ECase (EVar "x") [CaseAltGuard (PVar "n") [(EBinOp "<" (EVar "n") (EInt 0),EInt (-1))],CaseAlt (PInt 0) (EInt 0),CaseAltGuard (PVar "n") [(EBinOp ">" (EVar "n") (EInt 0),EInt 1)]])
