=== Running: src/AST/Decl.hs ===
-- Raw Source --
module AST.Decl where

import AST.Expr
import AST.Pattern (Pattern)
import AST.Type (Constraint, Type)

-- DeclFun Name [Pattern] (Maybe [(Expr, Expr)]) (Maybe Expr) (Maybe [Decl])

data Decl
  = DeclFunGroup Name [FunClause]
  | DeclValue Pattern Expr
  | DeclTypeSig Name Type
  | DeclData Name [Name] [Constraint] [Name]
  | DeclNewtype Name [Name] Constraint
  | DeclModule String (Maybe [Export])
  | DeclClass String [String] [Decl]
  | DeclInstance (Maybe [Constraint]) String [Type] [Decl]
  | DeclTypeAlias String [String] Type
  | DeclImport
      { importQualified :: Bool,
        importModule :: Name,
        importAlias :: Maybe Name,
        importHiding :: Bool,
        importItems :: Maybe [ImportItem]
      }
  deriving (Show, Eq)

data FunClause
  = FunClause
      [Pattern]
      (Maybe [(Expr, Expr)])
      (Maybe Expr)
      (Maybe [Decl])
  deriving (Show, Eq)

data ImportItem
  = ImportVar Name
  | ImportTypeAll Name
  | ImportTypeSome Name [Name]
  | ImportAllItems -- Å© í«â¡ÅI
  deriving (Show, Eq)

data Export
  = ExportVar String -- foo
  | ExportType String Bool -- Bar or Bar(..)
  deriving (Show, Eq)

-- data Constr = Constr Name [Type]
--  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "Decl",TokVLBrace,TokSymbol "=",TokTypeIdent "DeclFunGroup",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "FunClause",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclValue",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclTypeSig",TokTypeIdent "Name",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclData",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclNewtype",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokTypeIdent "Constraint",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclModule",TokTypeIdent "String",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclClass",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclInstance",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokSymbol ")",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclTypeAlias",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "DeclImport",TokVLBrace,TokSymbol "{",TokIdent "importQualified",TokSymbol "::",TokTypeIdent "Bool",TokSymbol ",",TokVLBrace,TokIdent "importModule",TokSymbol "::",TokTypeIdent "Name",TokSymbol ",",TokSymbol ";",TokIdent "importAlias",TokSymbol "::",TokTypeIdent "Maybe",TokTypeIdent "Name",TokSymbol ",",TokSymbol ";",TokIdent "importHiding",TokSymbol "::",TokTypeIdent "Bool",TokSymbol ",",TokSymbol ";",TokIdent "importItems",TokSymbol "::",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "ImportItem",TokSymbol "]",TokVRBrace,TokNewline,TokSymbol "}",TokVRBrace,TokNewline,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "=",TokTypeIdent "FunClause",TokVLBrace,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "ImportItem",TokVLBrace,TokSymbol "=",TokTypeIdent "ImportVar",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeAll",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportTypeSome",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ImportAllItems",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Export",TokVLBrace,TokSymbol "=",TokTypeIdent "ExportVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "ExportType",TokTypeIdent "String",TokTypeIdent "Bool",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Decl" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Constraint",ImportVar "Type"]}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "DeclFunGroup"
<< constrS: next token TokTypeIdent "DeclFunGroup"
<< dataConstr: next token TokTypeIdent "DeclFunGroup"
<< parseTypeCore: TCon "FunClause"
<< dataConstr:2 [TCon "Name",TList (TCon "FunClause")]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "Constraint"
<< parseTypeCore: TCon "Name"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Name"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Export"
<< parseTypeCore: TApp (TCon "Maybe") (TList (TCon "Export"))
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Decl"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "("
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Constraint"
<< parseTypeCore: TApp (TCon "Maybe") (TList (TCon "Constraint"))
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TCon "Decl"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokVLBrace
<< typeDef: next token TokIdent "importQualified"
<< typeDef: next token TokIdent "importModule"
<< typeDef: next token TokIdent "importAlias"
<< typeDef: next token TokIdent "importHiding"
<< typeDef: next token TokIdent "importItems"
<< parseTypeCore: TCon "ImportItem"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")],Constraint "DeclValue" [TCon "Pattern",TCon "Expr"],Constraint "DeclTypeSig" [TCon "Name",TCon "Type"],Constraint "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")],Constraint "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"],Constraint "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))],Constraint "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")],Constraint "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")],Constraint "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"],ConstraintRecord "DeclImport" [Field "importQualified" (TCon "Bool"),Field "importModule" (TCon "Name"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importHiding" (TCon "Bool"),Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem")))]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "Decl" [] [Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")],Constraint "DeclValue" [TCon "Pattern",TCon "Expr"],Constraint "DeclTypeSig" [TCon "Name",TCon "Type"],Constraint "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")],Constraint "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"],Constraint "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))],Constraint "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")],Constraint "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")],Constraint "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"],ConstraintRecord "DeclImport" [Field "importQualified" (TCon "Bool"),Field "importModule" (TCon "Name"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importHiding" (TCon "Bool"),Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem")))]] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "FunClause"
<< constrS: next token TokTypeIdent "FunClause"
<< dataConstr: next token TokTypeIdent "FunClause"
<< dataConstr:2 []
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "FunClause" []
<< constrS:2 next token TokSymbol "["
<< dataConstrRc: next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "["
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "FunClause"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Expr",TCon "Expr"]
<< parseTypeCore: TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"]))
<< parseTypeCore: TApp (TCon "Maybe") (TCon "Expr")
<< parseTypeCore: TCon "Decl"
<< parseTypeCore: TApp (TCon "Maybe") (TList (TCon "Decl"))
<< dataConstrOne:2 [TList (TCon "Pattern"),TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"])),TApp (TCon "Maybe") (TCon "Expr"),TApp (TCon "Maybe") (TList (TCon "Decl"))]
<< dataConstrOne:3 next token TokVRBrace
<< constrOne: next token TokKeyword "deriving" Constraint "FunClause" [TList (TCon "Pattern"),TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"])),TApp (TCon "Maybe") (TCon "Expr"),TApp (TCon "Maybe") (TList (TCon "Decl"))]
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "FunClause" [TList (TCon "Pattern"),TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"])),TApp (TCon "Maybe") (TCon "Expr"),TApp (TCon "Maybe") (TList (TCon "Decl"))]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "FunClause" [] [Constraint "FunClause" [TList (TCon "Pattern"),TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"])),TApp (TCon "Maybe") (TCon "Expr"),TApp (TCon "Maybe") (TList (TCon "Decl"))]] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "ImportVar"
<< constrS: next token TokTypeIdent "ImportVar"
<< dataConstr: next token TokTypeIdent "ImportVar"
<< dataConstr:2 [TCon "Name"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "ImportVar" [TCon "Name"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Name"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "ImportVar" [TCon "Name"],Constraint "ImportTypeAll" [TCon "Name"],Constraint "ImportTypeSome" [TCon "Name",TList (TCon "Name")],Constraint "ImportAllItems" []]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "ImportItem" [] [Constraint "ImportVar" [TCon "Name"],Constraint "ImportTypeAll" [TCon "Name"],Constraint "ImportTypeSome" [TCon "Name",TList (TCon "Name")],Constraint "ImportAllItems" []] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "ExportVar"
<< constrS: next token TokTypeIdent "ExportVar"
<< dataConstr: next token TokTypeIdent "ExportVar"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "ExportVar" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "ExportVar" [TCon "String"],Constraint "ExportType" [TCon "String",TCon "Bool"]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "Export" [] [Constraint "ExportVar" [TCon "String"],Constraint "ExportType" [TCon "String",TCon "Bool"]] ["Show","Eq"]
Just ([DeclModule "AST.Decl" Nothing,DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Constraint",ImportVar "Type"]},DeclData "Decl" [] [Constraint "DeclFunGroup" [TCon "Name",TList (TCon "FunClause")],Constraint "DeclValue" [TCon "Pattern",TCon "Expr"],Constraint "DeclTypeSig" [TCon "Name",TCon "Type"],Constraint "DeclData" [TCon "Name",TList (TCon "Name"),TList (TCon "Constraint"),TList (TCon "Name")],Constraint "DeclNewtype" [TCon "Name",TList (TCon "Name"),TCon "Constraint"],Constraint "DeclModule" [TCon "String",TApp (TCon "Maybe") (TList (TCon "Export"))],Constraint "DeclClass" [TCon "String",TList (TCon "String"),TList (TCon "Decl")],Constraint "DeclInstance" [TApp (TCon "Maybe") (TList (TCon "Constraint")),TCon "String",TList (TCon "Type"),TList (TCon "Decl")],Constraint "DeclTypeAlias" [TCon "String",TList (TCon "String"),TCon "Type"],ConstraintRecord "DeclImport" [Field "importQualified" (TCon "Bool"),Field "importModule" (TCon "Name"),Field "importAlias" (TApp (TCon "Maybe") (TCon "Name")),Field "importHiding" (TCon "Bool"),Field "importItems" (TApp (TCon "Maybe") (TList (TCon "ImportItem")))]] ["Show","Eq"],DeclData "FunClause" [] [Constraint "FunClause" [TList (TCon "Pattern"),TApp (TCon "Maybe") (TList (TTuple [TCon "Expr",TCon "Expr"])),TApp (TCon "Maybe") (TCon "Expr"),TApp (TCon "Maybe") (TList (TCon "Decl"))]] ["Show","Eq"],DeclData "ImportItem" [] [Constraint "ImportVar" [TCon "Name"],Constraint "ImportTypeAll" [TCon "Name"],Constraint "ImportTypeSome" [TCon "Name",TList (TCon "Name")],Constraint "ImportAllItems" []] ["Show","Eq"],DeclData "Export" [] [Constraint "ExportVar" [TCon "String"],Constraint "ExportType" [TCon "String",TCon "Bool"]] ["Show","Eq"]],[TokNewline])

=== Running: src/AST/Expr.hs ===
-- Raw Source --
module AST.Expr where

import AST.Pattern (Pattern)
import AST.Type (Type)

type Name = String

-- Binding
type Binding = (Pattern, Expr)

-- CaseAlt
data CaseAlt
  = CaseAlt Pattern Expr
  | CaseAltGuard Pattern [(Expr, Expr)]
  deriving (Eq, Show)

-- Stmt
data Stmt
  = Bind Pattern Expr
  | ExprStmt Expr
  | LetStmt [(Pattern, Expr)]
  deriving (Eq, Show)

-- Qualifier
data Qualifier
  = QGenerator Pattern Expr
  | QLet [(Pattern, Expr)]
  | QGuard Expr
  deriving (Eq, Show)

-- Expr ñ{ëÃ
data Expr
  = EVar String
  | EVarType String
  | EInt Int
  | EString String
  | EChar Char
  | EBinOp BinOp Expr Expr
  | EBool Bool
  | ELet Pattern Expr Expr
  | ELetBlock [(Pattern, Expr)] Expr
  | EIf Expr Expr Expr
  | ELam Pattern Expr
  | EApp Expr Expr
  | ECase Expr [CaseAlt]
  | EList [Expr]
  | ETuple [Expr]
  | ERange Expr Expr
  | ERangeStep Expr Expr Expr
  | EListComp Expr [Qualifier]
  | EAnn Expr Type
  | EDo [Stmt]
  | ESeq [Expr]
  | EReturn Expr
  | ERecord [(String, Expr)]
  | ERecordUpdate Expr [(String, Expr)]
  | EOpSectionL String Expr
  | EOpSectionR Expr String
  | EPlaceholder
  | EWhere Expr [Binding]
  | ESQL String [Expr]
  deriving (Eq, Show)

data BinOp
  = Add
  | Sub
  | Mul
  | Div
  | And
  | Or
  | Eq
  | Neq
  | Lt
  | Gt
  | Le
  | Ge
  | Concat
  | Cons
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "type",TokTypeIdent "Binding",TokSymbol "=",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "CaseAlt",TokVLBrace,TokSymbol "=",TokTypeIdent "CaseAlt",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "CaseAltGuard",TokTypeIdent "Pattern",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Stmt",TokVLBrace,TokSymbol "=",TokTypeIdent "Bind",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ExprStmt",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "LetStmt",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Qualifier",TokVLBrace,TokSymbol "=",TokTypeIdent "QGenerator",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "QLet",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "QGuard",TokTypeIdent "Expr",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Expr",TokVLBrace,TokSymbol "=",TokTypeIdent "EVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EVarType",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "EString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "EBinOp",TokTypeIdent "BinOp",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EBool",TokTypeIdent "Bool",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELet",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELetBlock",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EIf",TokTypeIdent "Expr",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ELam",TokTypeIdent "Pattern",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EApp",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ECase",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EList",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ETuple",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERange",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERangeStep",TokTypeIdent "Expr",TokTypeIdent "Expr",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EListComp",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "Qualifier",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EAnn",TokTypeIdent "Expr",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "EDo",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ESeq",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EReturn",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERecord",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ERecordUpdate",TokTypeIdent "Expr",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "EOpSectionL",TokTypeIdent "String",TokTypeIdent "Expr",TokSymbol ";",TokSymbol "|",TokTypeIdent "EOpSectionR",TokTypeIdent "Expr",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "EPlaceholder",TokSymbol ";",TokSymbol "|",TokTypeIdent "EWhere",TokTypeIdent "Expr",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ESQL",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "BinOp",TokVLBrace,TokSymbol "=",TokTypeIdent "Add",TokSymbol ";",TokSymbol "|",TokTypeIdent "Sub",TokSymbol ";",TokSymbol "|",TokTypeIdent "Mul",TokSymbol ";",TokSymbol "|",TokTypeIdent "Div",TokSymbol ";",TokSymbol "|",TokTypeIdent "And",TokSymbol ";",TokSymbol "|",TokTypeIdent "Or",TokSymbol ";",TokSymbol "|",TokTypeIdent "Eq",TokSymbol ";",TokSymbol "|",TokTypeIdent "Neq",TokSymbol ";",TokSymbol "|",TokTypeIdent "Lt",TokSymbol ";",TokSymbol "|",TokTypeIdent "Gt",TokSymbol ";",TokSymbol "|",TokTypeIdent "Le",TokSymbol ";",TokSymbol "|",TokTypeIdent "Ge",TokSymbol ";",TokSymbol "|",TokTypeIdent "Concat",TokSymbol ";",TokSymbol "|",TokTypeIdent "Cons",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Expr" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Type"]}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokSymbol "("
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< declBody: return DeclTypeAlias "Binding" [] (TTuple [TCon "Pattern",TCon "Expr"])
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "CaseAlt"
<< constrS: next token TokTypeIdent "CaseAlt"
<< dataConstr: next token TokTypeIdent "CaseAlt"
<< dataConstr:2 [TCon "Pattern",TCon "Expr"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Expr",TCon "Expr"]
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"],Constraint "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "CaseAlt" [] [Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"],Constraint "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Bind"
<< constrS: next token TokTypeIdent "Bind"
<< dataConstr: next token TokTypeIdent "Bind"
<< dataConstr:2 [TCon "Pattern",TCon "Expr"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "Bind" [TCon "Pattern",TCon "Expr"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "Bind" [TCon "Pattern",TCon "Expr"],Constraint "ExprStmt" [TCon "Expr"],Constraint "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "Stmt" [] [Constraint "Bind" [TCon "Pattern",TCon "Expr"],Constraint "ExprStmt" [TCon "Expr"],Constraint "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "QGenerator"
<< constrS: next token TokTypeIdent "QGenerator"
<< dataConstr: next token TokTypeIdent "QGenerator"
<< dataConstr:2 [TCon "Pattern",TCon "Expr"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "QGenerator" [TCon "Pattern",TCon "Expr"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "QGenerator" [TCon "Pattern",TCon "Expr"],Constraint "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])],Constraint "QGuard" [TCon "Expr"]]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "Qualifier" [] [Constraint "QGenerator" [TCon "Pattern",TCon "Expr"],Constraint "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])],Constraint "QGuard" [TCon "Expr"]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "EVar"
<< constrS: next token TokTypeIdent "EVar"
<< dataConstr: next token TokTypeIdent "EVar"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "EVar" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Int"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Char"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "BinOp"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Bool"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Pattern",TCon "Expr"]
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "CaseAlt"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Expr"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Expr"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Qualifier"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Stmt"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Expr"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "String",TCon "Expr"]
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "String",TCon "Expr"]
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Expr"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Binding"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Expr"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "EVar" [TCon "String"],Constraint "EVarType" [TCon "String"],Constraint "EInt" [TCon "Int"],Constraint "EString" [TCon "String"],Constraint "EChar" [TCon "Char"],Constraint "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"],Constraint "EBool" [TCon "Bool"],Constraint "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"],Constraint "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"],Constraint "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "ELam" [TCon "Pattern",TCon "Expr"],Constraint "EApp" [TCon "Expr",TCon "Expr"],Constraint "ECase" [TCon "Expr",TList (TCon "CaseAlt")],Constraint "EList" [TList (TCon "Expr")],Constraint "ETuple" [TList (TCon "Expr")],Constraint "ERange" [TCon "Expr",TCon "Expr"],Constraint "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "EListComp" [TCon "Expr",TList (TCon "Qualifier")],Constraint "EAnn" [TCon "Expr",TCon "Type"],Constraint "EDo" [TList (TCon "Stmt")],Constraint "ESeq" [TList (TCon "Expr")],Constraint "EReturn" [TCon "Expr"],Constraint "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])],Constraint "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])],Constraint "EOpSectionL" [TCon "String",TCon "Expr"],Constraint "EOpSectionR" [TCon "Expr",TCon "String"],Constraint "EPlaceholder" [],Constraint "EWhere" [TCon "Expr",TList (TCon "Binding")],Constraint "ESQL" [TCon "String",TList (TCon "Expr")]]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "Expr" [] [Constraint "EVar" [TCon "String"],Constraint "EVarType" [TCon "String"],Constraint "EInt" [TCon "Int"],Constraint "EString" [TCon "String"],Constraint "EChar" [TCon "Char"],Constraint "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"],Constraint "EBool" [TCon "Bool"],Constraint "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"],Constraint "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"],Constraint "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "ELam" [TCon "Pattern",TCon "Expr"],Constraint "EApp" [TCon "Expr",TCon "Expr"],Constraint "ECase" [TCon "Expr",TList (TCon "CaseAlt")],Constraint "EList" [TList (TCon "Expr")],Constraint "ETuple" [TList (TCon "Expr")],Constraint "ERange" [TCon "Expr",TCon "Expr"],Constraint "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "EListComp" [TCon "Expr",TList (TCon "Qualifier")],Constraint "EAnn" [TCon "Expr",TCon "Type"],Constraint "EDo" [TList (TCon "Stmt")],Constraint "ESeq" [TList (TCon "Expr")],Constraint "EReturn" [TCon "Expr"],Constraint "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])],Constraint "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])],Constraint "EOpSectionL" [TCon "String",TCon "Expr"],Constraint "EOpSectionR" [TCon "Expr",TCon "String"],Constraint "EPlaceholder" [],Constraint "EWhere" [TCon "Expr",TList (TCon "Binding")],Constraint "ESQL" [TCon "String",TList (TCon "Expr")]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Add"
<< constrS: next token TokTypeIdent "Add"
<< dataConstr: next token TokTypeIdent "Add"
<< dataConstr:2 []
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "Add" []
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "Add" [],Constraint "Sub" [],Constraint "Mul" [],Constraint "Div" [],Constraint "And" [],Constraint "Or" [],Constraint "Eq" [],Constraint "Neq" [],Constraint "Lt" [],Constraint "Gt" [],Constraint "Le" [],Constraint "Ge" [],Constraint "Concat" [],Constraint "Cons" []]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "BinOp" [] [Constraint "Add" [],Constraint "Sub" [],Constraint "Mul" [],Constraint "Div" [],Constraint "And" [],Constraint "Or" [],Constraint "Eq" [],Constraint "Neq" [],Constraint "Lt" [],Constraint "Gt" [],Constraint "Le" [],Constraint "Ge" [],Constraint "Concat" [],Constraint "Cons" []] ["Eq","Show"]
Just ([DeclModule "AST.Expr" Nothing,DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Type"]},DeclTypeAlias "Name" [] (TCon "String"),DeclTypeAlias "Binding" [] (TTuple [TCon "Pattern",TCon "Expr"]),DeclData "CaseAlt" [] [Constraint "CaseAlt" [TCon "Pattern",TCon "Expr"],Constraint "CaseAltGuard" [TCon "Pattern",TList (TTuple [TCon "Expr",TCon "Expr"])]] ["Eq","Show"],DeclData "Stmt" [] [Constraint "Bind" [TCon "Pattern",TCon "Expr"],Constraint "ExprStmt" [TCon "Expr"],Constraint "LetStmt" [TList (TTuple [TCon "Pattern",TCon "Expr"])]] ["Eq","Show"],DeclData "Qualifier" [] [Constraint "QGenerator" [TCon "Pattern",TCon "Expr"],Constraint "QLet" [TList (TTuple [TCon "Pattern",TCon "Expr"])],Constraint "QGuard" [TCon "Expr"]] ["Eq","Show"],DeclData "Expr" [] [Constraint "EVar" [TCon "String"],Constraint "EVarType" [TCon "String"],Constraint "EInt" [TCon "Int"],Constraint "EString" [TCon "String"],Constraint "EChar" [TCon "Char"],Constraint "EBinOp" [TCon "BinOp",TCon "Expr",TCon "Expr"],Constraint "EBool" [TCon "Bool"],Constraint "ELet" [TCon "Pattern",TCon "Expr",TCon "Expr"],Constraint "ELetBlock" [TList (TTuple [TCon "Pattern",TCon "Expr"]),TCon "Expr"],Constraint "EIf" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "ELam" [TCon "Pattern",TCon "Expr"],Constraint "EApp" [TCon "Expr",TCon "Expr"],Constraint "ECase" [TCon "Expr",TList (TCon "CaseAlt")],Constraint "EList" [TList (TCon "Expr")],Constraint "ETuple" [TList (TCon "Expr")],Constraint "ERange" [TCon "Expr",TCon "Expr"],Constraint "ERangeStep" [TCon "Expr",TCon "Expr",TCon "Expr"],Constraint "EListComp" [TCon "Expr",TList (TCon "Qualifier")],Constraint "EAnn" [TCon "Expr",TCon "Type"],Constraint "EDo" [TList (TCon "Stmt")],Constraint "ESeq" [TList (TCon "Expr")],Constraint "EReturn" [TCon "Expr"],Constraint "ERecord" [TList (TTuple [TCon "String",TCon "Expr"])],Constraint "ERecordUpdate" [TCon "Expr",TList (TTuple [TCon "String",TCon "Expr"])],Constraint "EOpSectionL" [TCon "String",TCon "Expr"],Constraint "EOpSectionR" [TCon "Expr",TCon "String"],Constraint "EPlaceholder" [],Constraint "EWhere" [TCon "Expr",TList (TCon "Binding")],Constraint "ESQL" [TCon "String",TList (TCon "Expr")]] ["Eq","Show"],DeclData "BinOp" [] [Constraint "Add" [],Constraint "Sub" [],Constraint "Mul" [],Constraint "Div" [],Constraint "And" [],Constraint "Or" [],Constraint "Eq" [],Constraint "Neq" [],Constraint "Lt" [],Constraint "Gt" [],Constraint "Le" [],Constraint "Ge" [],Constraint "Concat" [],Constraint "Cons" []] ["Eq","Show"]],[TokNewline])

=== Running: src/AST/Module.hs ===
-- Raw Source --
module AST.Module where

import AST.Type
import AST.Decl (Decl)

type Name = String

data Module = Module
  { moduleName :: Name
  , moduleImports :: [Import]
  , moduleDecls :: [Decl]
  }
  deriving (Show, Eq)

data Import = Import
  { importName :: Name
  }
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Module",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "data",TokTypeIdent "Module",TokSymbol "=",TokTypeIdent "Module",TokVLBrace,TokSymbol "{",TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol ",",TokIdent "moduleImports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Import",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "moduleDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Import",TokSymbol "=",TokTypeIdent "Import",TokVLBrace,TokSymbol "{",TokIdent "importName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Module" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Decl"]}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Module"
<< constrS: next token TokTypeIdent "Module"
<< dataConstr: next token TokTypeIdent "Module"
<< dataConstr:2 []
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "Module" []
<< constrS:2 next token TokSymbol "{"
<< dataConstrRc: next token TokSymbol "{"
<< dataConstrNx: next token TokSymbol "{"
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "Module"
Just ([DeclModule "AST.Module" Nothing,DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Decl"]},DeclTypeAlias "Name" [] (TCon "String")],[TokNewline,TokKeyword "data",TokTypeIdent "Module",TokSymbol "=",TokTypeIdent "Module",TokVLBrace,TokSymbol "{",TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol ",",TokIdent "moduleImports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Import",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "moduleDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Import",TokSymbol "=",TokTypeIdent "Import",TokVLBrace,TokSymbol "{",TokIdent "importName",TokSymbol "::",TokTypeIdent "Name",TokSymbol ";",TokSymbol "}",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/AST/Pattern.hs ===
-- Raw Source --
module AST.Pattern where

-- import AST.Type (Type)
-- import AST.Module (Name)
-- import AST.Pattern (Pattern)
-- import AST.Expr (Expr)

type Name = String

data Pattern
  = PVar Name
  | PInt Int
  | PChar Char
  | PString String
  | PWildcard
  | PCons Pattern Pattern
  | PList [Pattern]
  | PTuple [Pattern]
  | PConstr Name [Pattern]
  | PAs Name Pattern -- Å© í«â¡ÅI
  | PApp Pattern [Pattern] -- Åö èCê≥
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokKeyword "where",TokNewline,TokKeyword "type",TokTypeIdent "Name",TokSymbol "=",TokTypeIdent "String",TokNewline,TokKeyword "data",TokTypeIdent "Pattern",TokVLBrace,TokSymbol "=",TokTypeIdent "PVar",TokTypeIdent "Name",TokSymbol ";",TokSymbol "|",TokTypeIdent "PInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "PChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "PString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "PWildcard",TokSymbol ";",TokSymbol "|",TokTypeIdent "PCons",TokTypeIdent "Pattern",TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokTypeIdent "PList",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PTuple",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PConstr",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "PAs",TokTypeIdent "Name",TokTypeIdent "Pattern",TokSymbol ";",TokSymbol "|",TokTypeIdent "PApp",TokTypeIdent "Pattern",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Pattern" Nothing
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< declBody: return DeclTypeAlias "Name" [] (TCon "String")
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "PVar"
<< constrS: next token TokTypeIdent "PVar"
<< dataConstr: next token TokTypeIdent "PVar"
<< dataConstr:2 [TCon "Name"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "PVar" [TCon "Name"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Int"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Char"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Name"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Pattern"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Pattern"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "PVar" [TCon "Name"],Constraint "PInt" [TCon "Int"],Constraint "PChar" [TCon "Char"],Constraint "PString" [TCon "String"],Constraint "PWildcard" [],Constraint "PCons" [TCon "Pattern",TCon "Pattern"],Constraint "PList" [TList (TCon "Pattern")],Constraint "PTuple" [TList (TCon "Pattern")],Constraint "PConstr" [TCon "Name",TList (TCon "Pattern")],Constraint "PAs" [TCon "Name",TCon "Pattern"],Constraint "PApp" [TCon "Pattern",TList (TCon "Pattern")]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "Pattern" [] [Constraint "PVar" [TCon "Name"],Constraint "PInt" [TCon "Int"],Constraint "PChar" [TCon "Char"],Constraint "PString" [TCon "String"],Constraint "PWildcard" [],Constraint "PCons" [TCon "Pattern",TCon "Pattern"],Constraint "PList" [TList (TCon "Pattern")],Constraint "PTuple" [TList (TCon "Pattern")],Constraint "PConstr" [TCon "Name",TList (TCon "Pattern")],Constraint "PAs" [TCon "Name",TCon "Pattern"],Constraint "PApp" [TCon "Pattern",TList (TCon "Pattern")]] ["Show","Eq"]
Just ([DeclModule "AST.Pattern" Nothing,DeclTypeAlias "Name" [] (TCon "String"),DeclData "Pattern" [] [Constraint "PVar" [TCon "Name"],Constraint "PInt" [TCon "Int"],Constraint "PChar" [TCon "Char"],Constraint "PString" [TCon "String"],Constraint "PWildcard" [],Constraint "PCons" [TCon "Pattern",TCon "Pattern"],Constraint "PList" [TList (TCon "Pattern")],Constraint "PTuple" [TList (TCon "Pattern")],Constraint "PConstr" [TCon "Name",TList (TCon "Pattern")],Constraint "PAs" [TCon "Name",TCon "Pattern"],Constraint "PApp" [TCon "Pattern",TList (TCon "Pattern")]] ["Show","Eq"]],[TokNewline])

=== Running: src/AST/Program.hs ===
-- Raw Source --
module AST.Program where


data Program = Program
  { moduleDecl :: Maybe Decl
  , imports    :: [Decl]
  , decls      :: [Decl]
  }


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Program",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Program",TokSymbol "=",TokTypeIdent "Program",TokVLBrace,TokSymbol "{",TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Maybe",TokTypeIdent "Decl",TokSymbol ";",TokSymbol ",",TokIdent "imports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "decls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Program" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Program"
<< constrS: next token TokTypeIdent "Program"
<< dataConstr: next token TokTypeIdent "Program"
<< dataConstr:2 []
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "Program" []
<< constrS:2 next token TokSymbol "{"
<< dataConstrRc: next token TokSymbol "{"
<< dataConstrNx: next token TokSymbol "{"
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "Program"
Just ([DeclModule "AST.Program" Nothing],[TokNewline,TokKeyword "data",TokTypeIdent "Program",TokSymbol "=",TokTypeIdent "Program",TokVLBrace,TokSymbol "{",TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Maybe",TokTypeIdent "Decl",TokSymbol ";",TokSymbol ",",TokIdent "imports",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "decls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline])

=== Running: src/AST/Type.hs ===
-- Raw Source --
module AST.Type where

-- import AST.Expr (Name)

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  | TFun Type Type
  deriving (Eq, Show)

data Constraint
  = Constraint String [Type] -- í èÌÇÃÉRÉìÉXÉgÉâÉNÉ^
  | ConstraintRecord String [Field] -- ÉåÉRÅ[Éhç\ï∂ÇÃÉRÉìÉXÉgÉâÉNÉ^
  deriving (Show, Eq)

data Field = Field String Type
  deriving (Show, Eq)

-- data Constraint = Constraint String [Type]
--  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Type",TokVLBrace,TokSymbol "=",TokTypeIdent "TVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TCon",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TArrow",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TList",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TApp",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TForall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TTuple",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "TUnit",TokSymbol ";",TokSymbol "|",TokTypeIdent "TFun",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Constraint",TokVLBrace,TokSymbol "=",TokTypeIdent "Constraint",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "ConstraintRecord",TokTypeIdent "String",TokSymbol "[",TokTypeIdent "Field",TokSymbol "]",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Field",TokSymbol "=",TokTypeIdent "Field",TokTypeIdent "String",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "AST.Type" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "TVar"
<< constrS: next token TokTypeIdent "TVar"
<< dataConstr: next token TokTypeIdent "TVar"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "TVar" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Constraint"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Type"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" [],Constraint "TFun" [TCon "Type",TCon "Type"]]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" [],Constraint "TFun" [TCon "Type",TCon "Type"]] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Constraint"
<< constrS: next token TokTypeIdent "Constraint"
<< dataConstr: next token TokTypeIdent "Constraint"
<< parseTypeCore: TCon "Type"
<< dataConstr:2 [TCon "String",TList (TCon "Type")]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "Constraint" [TCon "String",TList (TCon "Type")]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Field"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "Constraint" [TCon "String",TList (TCon "Type")],Constraint "ConstraintRecord" [TCon "String",TList (TCon "Field")]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "Constraint" [] [Constraint "Constraint" [TCon "String",TList (TCon "Type")],Constraint "ConstraintRecord" [TCon "String",TList (TCon "Field")]] ["Show","Eq"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Field"
<< constrS: next token TokTypeIdent "Field"
<< dataConstr: next token TokTypeIdent "Field"
<< dataConstr:2 [TCon "String",TCon "Type"]
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "Field" [TCon "String",TCon "Type"]
<< constrS:2 next token TokKeyword "deriving"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "Field"
<< dataConstrOne:2 [TCon "String"]
<< dataConstrOne:3 next token TokTypeIdent "Type"
<< constrOne: next token TokTypeIdent "Type" Constraint "Field" [TCon "String"]
<< dataDecl:2 next token TokTypeIdent "Type"[Constraint "Field" [TCon "String"]]
<< dataDecl:4 next token []
<< declBody: return DeclData "Field" [] [Constraint "Field" [TCon "String"]] []
<< decl next token: TokTypeIdent "Type"
<< decl parser called
<< decl dispatch: TokTypeIdent "Type"
<< unknown token in decl: TokTypeIdent "Type"
Just ([DeclModule "AST.Type" Nothing,DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" [],Constraint "TFun" [TCon "Type",TCon "Type"]] ["Eq","Show"],DeclData "Constraint" [] [Constraint "Constraint" [TCon "String",TList (TCon "Type")],Constraint "ConstraintRecord" [TCon "String",TList (TCon "Field")]] ["Show","Eq"],DeclData "Field" [] [Constraint "Field" [TCon "String"]] []],[TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Data.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Data (dataDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type -- (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)

import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

dataDecl :: Parser Decl
dataDecl = do
  keyword "data"
  typeName <- identI
  typeVars <- many identI
  bracesV3 $ do
    t <- lookAhead anyToken
    myTrace ("<< dataDecl: next token " ++ show t)
    -- bracesV3 $ do
    symbol "="
    t2 <- lookAhead anyToken
    myTrace ("<< dataDecl:2 next token " ++ show t2)
    constr <- constrs
    t3 <- lookAhead anyToken
    myTrace ("<< dataDecl:2 next token " ++ show t3 ++ show constr)
    -- restConstrs <- restBlock

    -- bracesV3 $ do
    -- restConstrs <- many (try dataConstrNx <|> dataConstrRc)
    -- restConstrs <- restBlock
    -- myTrace ("<< dataDecl:3 next token" ++ show restConstrs)
    derivs <- option [] derivingClause
    myTrace ("<< dataDecl:4 next token " ++ show derivs)
    return $ DeclData typeName typeVars constr derivs

constrs = do
  constrS <|> try constrOne

-- constrs :: Parser [Type]
constrS = do
  t <- lookAhead anyToken
  myTrace ("<< constrS: next token " ++ show t)
  firstConstr <- dataConstr
  t <- lookAhead anyToken
  myTrace ("<< constrS:1 next token " ++ show t ++ " " ++ show firstConstr)
  bracesV3 $ do
    t2 <- lookAhead anyToken
    myTrace ("<< constrS:2 next token " ++ show t2)
    case t2 of
      TokVLBrace -> do empty
      _ -> do
        -- bracesV3 $ do
        -- restConstrs <- many (try dataConstrNx <|> dataConstrRc)
        restConstrs <- many (try dataConstrRc <|> dataConstrNx <|> empty)
        return (firstConstr : restConstrs)

constrOne = do
  firstConstr <- dataConstrOne
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< constrOne: next token " ++ show t ++ " " ++ show firstConstr)
  return (firstConstr : [])

derivingClause :: Parser [Name]
derivingClause = do
  keyword "deriving"
  parens (sepBy1 typeIdent (symbol ",")) <|> fmap pure typeIdent

dataConstr :: Parser Constraint
dataConstr = do
  t <- lookAhead anyToken
  myTrace ("<< dataConstr: next token " ++ show t)
  name <- identI
  args <- many typeAtom
  -- case args of
  --  [] -> do empty
  --  _ -> do
  myTrace ("<< dataConstr:2 " ++ show args)
  optional (symbol ";")
  t <- lookAhead anyToken
  myTrace ("<< dataConstr:3 next token " ++ show t)
  return $ Constraint name args

dataConstrOne :: Parser Constraint
dataConstrOne = do
  t <- lookAhead anyToken
  myTrace ("<< dataConstrOne: next token " ++ show t)
  name <- identI
  bracesV3 $ do
    args <- sepBy1 typeAtom (symbol ";")
    myTrace ("<< dataConstrOne:2 " ++ show args)
    t <- lookAhead anyToken
    myTrace ("<< dataConstrOne:3 next token " ++ show t)
    skipNewlines
    return $ Constraint name args

dataConstrN1 :: String -> Parser Constraint
dataConstrN1 name = do
  t <- lookAhead anyToken
  myTrace ("<< dataConstrN1: next token " ++ show t)
  -- name <- identI
  braces $ do
    args <- sepBy1 typeAtom (symbol ";")
    myTrace ("<< dataConstrN1:2 next token " ++ show args)
    return $ Constraint name args

dataConstrNx :: Parser Constraint
dataConstrNx = do
  t <- lookAhead anyToken
  myTrace ("<< dataConstrNx: next token " ++ show t)
  symbol "|"
  name <- identI
  args <- many typeAtom
  optional (symbol ";")
  return $ Constraint name args

dataConstrRc :: Parser Constraint
dataConstrRc = do
  t <- lookAhead anyToken
  myTrace ("<< dataConstrRc: next token " ++ show t)
  symbol "|"
  name <- identI
  rt <- dataConstrRc2 name
  -- t2 <- lookAhead anyToken
  -- myTrace ("<< dataConstrRc:2 next token" ++ show t2)
  skipNewlines
  return rt

dataConstrRc2 :: String -> Parser Constraint
dataConstrRc2 name = do
  t2 <- lookAhead anyToken
  myTrace ("<< dataConstrRc:2 next token " ++ show t2)
  bracesv $ do
    symbol "{"
    arg <- typeDef
    args <- bracesv $ sepBy1 typeDef (symbol ";")
    skipNewlines
    symbol "}"
    return $ ConstraintRecord name (arg : args)

-- skipNewlines

typeDef :: Parser Field
typeDef = do
  t <- lookAhead anyToken
  myTrace ("<< typeDef: next token " ++ show t)
  name <- identI
  symbol "::"
  ty <- typeExpr
  optional (symbol ",")
  return $ Field name ty

{-}
typeAtom :: Parser Type
typeAtom =
  TyVar <$> identI
    <|> TyCon <$> typeIdent
    <|> parens typeExpr
-}

typeExpr :: Parser Type
typeExpr = do
  ts <- some typeAtom
  return $ foldl1 TApp ts


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Data",TokSymbol "(",TokIdent "dataDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "dataDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "dataDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "data",TokSymbol ";",TokIdent "typeName",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "typeVars",TokSymbol "<-",TokIdent "many",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokIdent "constr",TokSymbol "<-",TokIdent "constrs",TokSymbol ";",TokIdent "t3",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t3",TokOperator "++",TokIdent "show",TokIdent "constr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "derivs",TokSymbol "<-",TokIdent "option",TokSymbol "[",TokSymbol "]",TokIdent "derivingClause",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:4 next token ",TokOperator "++",TokIdent "show",TokIdent "derivs",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclData",TokIdent "typeName",TokIdent "typeVars",TokIdent "constr",TokIdent "derivs",TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "constrS",TokOperator "<|>",TokIdent "try",TokIdent "constrOne",TokVRBrace,TokNewline,TokIdent "constrS",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "firstConstr",TokSymbol "<-",TokIdent "dataConstr",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS:1 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "firstConstr",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t2",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokKeyword "do",TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "restConstrs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokIdent "dataConstrRc",TokOperator "<|>",TokIdent "dataConstrNx",TokOperator "<|>",TokIdent "empty",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "firstConstr",TokOperator ":",TokIdent "restConstrs",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrOne",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "firstConstr",TokSymbol "<-",TokIdent "dataConstrOne",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrOne: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "firstConstr",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "firstConstr",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "derivingClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "derivingClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "deriving",TokSymbol ";",TokIdent "parens",TokSymbol "(",TokIdent "sepBy1",TokIdent "typeIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokOperator "<|>",TokIdent "fmap",TokIdent "pure",TokIdent "typeIdent",TokVRBrace,TokNewline,TokIdent "dataConstr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr:2 ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr:3 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrOne",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrOne",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "sepBy1",TokIdent "typeAtom",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne:2 ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne:3 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstrN1",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrN1",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrN1: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "braces",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "sepBy1",TokIdent "typeAtom",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrN1:2 next token ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstrNx",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrNx",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrNx: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrRc",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRc: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "rt",TokSymbol "<-",TokIdent "dataConstrRc2",TokIdent "name",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokKeyword "return",TokIdent "rt",TokVRBrace,TokNewline,TokIdent "dataConstrRc2",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRc2",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRc:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokIdent "bracesv",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "typeDef",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "bracesv",TokOperator "$",TokIdent "sepBy1",TokIdent "typeDef",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ConstraintRecord",TokIdent "name",TokSymbol "(",TokIdent "arg",TokOperator ":",TokIdent "args",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeDef",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Field",TokNewline,TokIdent "typeDef",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokVRBrace,TokNewline,TokIdent "typeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "dataDecl"
<< declBody: return DeclModule "Decl.DeclParser.Data" (Just [ExportVar "dataDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "dataDecl"
<< decl parser called
<< decl dispatch: TokIdent "dataDecl"
<< funDecl: next token=TokIdent "dataDecl"
<< funClause: next token=TokIdent "dataDecl"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "dataDecl"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parsed type signature: dataDecl :: TApp (TCon "Parser") (TCon "Decl")
<< returning DeclTypeSig: DeclTypeSig "dataDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< declBody: return DeclTypeSig "dataDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< decl next token: TokIdent "dataDecl"
<< decl parser called
<< decl dispatch: TokIdent "dataDecl"
<< funDecl: next token=TokIdent "dataDecl"
<< funClause: next token=TokIdent "dataDecl"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "data"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "data"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "typeName"
<< pattern1: (pAs <|> makeCons)PApp (PVar "typeName") []
<< expr dispatch: TokIdent "identI"
<< exprCore next token: TokIdent "identI"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "typeVars"
<< pattern1: (pAs <|> makeCons)PApp (PVar "typeVars") []
<< expr dispatch: TokIdent "many"
<< exprCore next token: TokIdent "many"
<< atomBaseCore next token: TokIdent "many"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "bracesV3"
<< pattern1: (pAs <|> makeCons)PApp (PVar "bracesV3") []
<< expr dispatch: TokIdent "bracesV3"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokKeyword "do"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "keyword"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "dataDecl" [FunClause [] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Decl.DeclParser.Data" (Just [ExportVar "dataDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "dataDecl" (TApp (TCon "Parser") (TCon "Decl")),DeclFunGroup "dataDecl" [FunClause [] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "keyword",TokString "data",TokSymbol ";",TokIdent "typeName",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "typeVars",TokSymbol "<-",TokIdent "many",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokIdent "constr",TokSymbol "<-",TokIdent "constrs",TokSymbol ";",TokIdent "t3",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t3",TokOperator "++",TokIdent "show",TokIdent "constr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "derivs",TokSymbol "<-",TokIdent "option",TokSymbol "[",TokSymbol "]",TokIdent "derivingClause",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataDecl:4 next token ",TokOperator "++",TokIdent "show",TokIdent "derivs",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclData",TokIdent "typeName",TokIdent "typeVars",TokIdent "constr",TokIdent "derivs",TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "constrS",TokOperator "<|>",TokIdent "try",TokIdent "constrOne",TokVRBrace,TokNewline,TokIdent "constrS",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "firstConstr",TokSymbol "<-",TokIdent "dataConstr",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS:1 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "firstConstr",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrS:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t2",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokKeyword "do",TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "restConstrs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokIdent "dataConstrRc",TokOperator "<|>",TokIdent "dataConstrNx",TokOperator "<|>",TokIdent "empty",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "firstConstr",TokOperator ":",TokIdent "restConstrs",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrOne",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "firstConstr",TokSymbol "<-",TokIdent "dataConstrOne",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< constrOne: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokOperator "++",TokString " ",TokOperator "++",TokIdent "show",TokIdent "firstConstr",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "firstConstr",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "derivingClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "derivingClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "deriving",TokSymbol ";",TokIdent "parens",TokSymbol "(",TokIdent "sepBy1",TokIdent "typeIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokOperator "<|>",TokIdent "fmap",TokIdent "pure",TokIdent "typeIdent",TokVRBrace,TokNewline,TokIdent "dataConstr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr:2 ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstr:3 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrOne",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrOne",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "sepBy1",TokIdent "typeAtom",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne:2 ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrOne:3 next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstrN1",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrN1",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrN1: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "braces",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "sepBy1",TokIdent "typeAtom",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrN1:2 next token ",TokOperator "++",TokIdent "show",TokIdent "args",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "dataConstrNx",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrNx",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrNx: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeAtom",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "name",TokIdent "args",TokVRBrace,TokNewline,TokIdent "dataConstrRc",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRc: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "rt",TokSymbol "<-",TokIdent "dataConstrRc2",TokIdent "name",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokKeyword "return",TokIdent "rt",TokVRBrace,TokNewline,TokIdent "dataConstrRc2",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "dataConstrRc2",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t2",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< dataConstrRc:2 next token ",TokOperator "++",TokIdent "show",TokIdent "t2",TokSymbol ")",TokSymbol ";",TokIdent "bracesv",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "typeDef",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "bracesv",TokOperator "$",TokIdent "sepBy1",TokIdent "typeDef",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "ConstraintRecord",TokIdent "name",TokSymbol "(",TokIdent "arg",TokOperator ":",TokIdent "args",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeDef",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Field",TokNewline,TokIdent "typeDef",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeDef: next token ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "identI",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeExpr",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Field",TokIdent "name",TokIdent "ty",TokVRBrace,TokNewline,TokIdent "typeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Fun.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Fun (funDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)

import Control.Monad (guard)
import Data.List (intercalate)
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

mkSimpleClause :: [Pattern] -> Expr -> Maybe [Decl] -> FunClause
mkSimpleClause pats body whereDecls =
  FunClause pats Nothing (Just body) whereDecls

mkGuardedClause :: [Pattern] -> [(Expr, Expr)] -> Maybe [Decl] -> FunClause
mkGuardedClause pats guards whereDecls =
  FunClause pats (Just guards) Nothing whereDecls

-- ä÷êîêÈåæ
funDecl :: Parser Decl
funDecl = do
  t <- lookAhead anyToken
  myTrace ("<< funDecl: next token=" ++ show t)
  (name, clause1) <- funClause -- funDecl
  rest <- many (try (funClauseWithName name))
  return (DeclFunGroup name (clause1 : rest))

funClause :: Parser (Name, FunClause)
funClause = do
  t0 <- lookAhead anyToken
  myTrace ("<< funClause: next token=" ++ show t0)
  name <- ident
  args <- many patternParser
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funClause: args=" ++ show args ++ " t = " ++ show t)
  case t of
    TokSymbol "=" -> parseSimpleClause name args
    TokSymbol "|" -> parseGuardedClause name args
    _ -> parseGuardedClause name args

parseSimpleClause :: Name -> [Pattern] -> Parser (Name, FunClause)
parseSimpleClause name args = do
  symbol "="
  t <- lookAhead anyToken
  myTrace ("<< parseSimpleClause:2 next token=" ++ show t)
  bracesV3 $ do
    skipSeparators
    e <- expr
    w <- optional (bracesV3 (whereBlock))
    return (name, mkSimpleClause args e w)

parseGuardedClause :: Name -> [Pattern] -> Parser (Name, FunClause)
parseGuardedClause name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedClause: next token=" ++ show t)
  bracesV3 $ do
    skipSeparators
    guards <- guardedRhs
    w <- optional (whereBlock)
    return (name, mkGuardedClause args guards w)

funDeclGroup :: Parser Decl
funDeclGroup = do
  t <- lookAhead anyToken
  myTrace ("<< funDeclGroup: next token=" ++ show t)
  (name1, clause1) <- funClause
  rest <- many (try (funClauseWithName name1))
  return (DeclFunGroup name1 (clause1 : rest))

-- ìØÇ∂ñºëOÇÃä÷êîÇÉOÉãÅ[ÉvâªÇ∑ÇÈ
funClauseWithName :: Name -> Parser FunClause
funClauseWithName name = try $ do
  skipSeparators
  -- skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funClauseWithName: next token=" ++ show t)
  name' <- ident
  guard (name == name')
  args <- many patternParser
  -- skipSeparators
  t <- lookAhead anyToken
  case t of
    TokSymbol "=" -> do
      symbol "="
      bracesV3 $ do
        skipSeparators
        e <- expr
        -- w <- optional (bracesV3 (whereBlock))
        w <- optional whereBlock
        return (mkSimpleClause args e w)
    TokSymbol "|" -> do
      guards <- guardedRhs
      w <- optional whereBlock
      return (mkGuardedClause args guards w)
    _ -> bracesV3 $ do
      skipSeparators
      e <- expr
      -- w <- optional (bracesV3 (whereBlock))
      w <- optional whereBlock
      return (mkSimpleClause args e w)

--  guards <- guardedRhs
--  w <- optional whereBlock
-- return (mkGuardedClause args guards w)

whereBlock :: Parser [Decl]
whereBlock = do
  t0 <- lookAhead anyToken
  myTrace ("<< whereBlock: next token" ++ show t0)
  keyword "where"
  t <- lookAhead anyToken
  myTrace ("<< whereBlock:2 next token" ++ show t)
  bracesV $ do
    decls <- many1 $ do
      skipSeparators
      funDecl
    return decls

guardedRhsM :: Parser [(Expr, Expr)]
guardedRhsM = many1 parseGuardLine

parseGuardLine :: Parser (Expr, Expr)
parseGuardLine = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardLine: next token=" ++ show t)
  symbol "|"
  cond <- expr
  symbol "="
  body <- expr
  return (cond, body)

guardedRhs :: Parser [(Expr, Expr)]
guardedRhs = do
  many1 $ do
    skipSeparators
    t <- lookAhead anyToken
    myTrace ("<< guardedRhs: next token = " ++ show t)
    parseGuardLine

-- sepBy1 parseGuardLine (symbol ";")

funHead :: Parser (Name, [Pattern])
funHead = do
  p <- pattern
  myTrace ("<< funHead pattern: " ++ show p)
  case p of
    PVar name -> do
      args <- many pattern
      return (name, args)
    PApp (PVar name) args -> do
      moreArgs <- many pattern
      return (name, args ++ moreArgs)
    _ -> do
      myTrace "Function definition must start with a variable name"
      empty

{-}
parseGuardedClauseV :: Name -> [Pattern] -> Parser (Name, FunClause)
parseGuardedClauseV name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedClauseV: next token=" ++ show t)
  guards <- guardedRhs
  w <- optional (whereBlockV)
  return (name, mkGuardedClause args guards w)
-}

{-}
whereBlockV :: Parser [Decl]
whereBlockV = do
  t0 <- lookAhead anyToken
  myTrace ("<< whereBlockV: next token" ++ show t0)
  keyword "where"
  t <- lookAhead anyToken
  myTrace ("<< whereBlockV:2 next token" ++ show t)
  decls <- many funDecl
  return decls
-}

{-}
funDecl :: Parser Decl -> Parser Decl
funDecl decl = do
  t0 <- lookAhead anyToken
  myTrace ("<< funDecl: next token=" ++ show t0)
  name <- ident
  args <- many patternParser
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< funDecl: args=" ++ show args ++ " t = " ++ show t)
  case t of
    TokSymbol "=" -> parseSimple decl name args
    TokSymbol "|" -> parseGuarded decl name args
    TokVLBrace -> bracesV (parseGuardedV decl name args)
    _ -> empty

parseSimple :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseSimple decl name args = do
  t0 <- lookAhead anyToken
  myTrace ("<< parseSimple: next token" ++ show t0)
  symbol "="
  t <- lookAhead anyToken
  myTrace ("<< parseSimple: next token" ++ show t)
  case t of
    TokVLBrace -> do
      token TokVLBrace
      e <- expr
      w <- optional (bracesV (whereBlock decl))
      token TokVRBrace
      return (DeclFun name args Nothing (Just e) w)
    _ -> do
      e <- expr
      w <- optional (bracesV (whereBlock decl))
      return (DeclFun name args Nothing (Just e) w)

parseGuardedV :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseGuardedV decl name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuardedV: next token" ++ show t)
  -- guards <- bracesV
  guards <- guardedRhs
  w <- optional (whereBlockV decl)
  return (DeclFun name args (Just guards) Nothing w)

parseGuarded :: Parser Decl -> Name -> [Pattern] -> Parser Decl
parseGuarded decl name args = do
  t <- lookAhead anyToken
  myTrace ("<< parseGuarded: next token" ++ show t)
  guards <- guardedRhsM
  w <- optional (whereBlock decl)
  return (DeclFun name args (Just guards) Nothing w)

-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Fun",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "mkSimpleClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkSimpleClause",TokIdent "pats",TokIdent "body",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "mkGuardedClause",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "FunClause",TokNewline,TokIdent "mkGuardedClause",TokIdent "pats",TokIdent "guards",TokIdent "whereDecls",TokSymbol "=",TokVLBrace,TokTypeIdent "FunClause",TokIdent "pats",TokSymbol "(",TokTypeIdent "Just",TokIdent "guards",TokSymbol ")",TokTypeIdent "Nothing",TokIdent "whereDecls",TokVRBrace,TokNewline,TokIdent "funDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDecl: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "funClause",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "patternParser",TokSymbol ";",TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClause: args=",TokOperator "++",TokIdent "show",TokIdent "args",TokOperator "++",TokString " t = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseSimpleClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseSimpleClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseSimpleClause:2 next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseGuardedClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardedClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funDeclGroup",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDeclGroup",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDeclGroup: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name1",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name1",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClauseWithName",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokTypeIdent "Parser",TokTypeIdent "FunClause",TokNewline,TokIdent "funClauseWithName",TokIdent "name",TokSymbol "=",TokIdent "try",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClauseWithName: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name'",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "guard",TokSymbol "(",TokIdent "name",TokSymbol "==",TokIdent "name'",TokSymbol ")",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "patternParser",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "whereBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock: next token",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock:2 next token",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "decls",TokSymbol "<-",TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "funDecl",TokVRBrace,TokNewline,TokKeyword "return",TokIdent "decls",TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardedRhsM",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhsM",TokSymbol "=",TokIdent "many1",TokIdent "parseGuardLine",TokNewline,TokIdent "parseGuardLine",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "parseGuardLine",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardLine: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardedRhs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< guardedRhs: next token = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "parseGuardLine",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funHead",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funHead pattern: ",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "p",TokKeyword "of",TokVLBrace,TokTypeIdent "PVar",TokIdent "name",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "moreArgs",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "funDecl"
<< declBody: return DeclModule "Decl.DeclParser.Fun" (Just [ExportVar "funDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "guard"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "mkSimpleClause"
<< decl parser called
<< decl dispatch: TokIdent "mkSimpleClause"
<< funDecl: next token=TokIdent "mkSimpleClause"
<< funClause: next token=TokIdent "mkSimpleClause"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "mkSimpleClause"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Decl"
<< parseTypeCore: TCon "FunClause"
<< parseTypeCore: TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")
<< parseTypeCore: TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))
<< parseTypeCore: TFun (TList (TCon "Pattern")) (TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))
<< parsed type signature: mkSimpleClause :: TFun (TList (TCon "Pattern")) (TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))
<< returning DeclTypeSig: DeclTypeSig "mkSimpleClause" (TFun (TList (TCon "Pattern")) (TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))))
<< declBody: return DeclTypeSig "mkSimpleClause" (TFun (TList (TCon "Pattern")) (TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))))
<< decl next token: TokIdent "mkSimpleClause"
<< decl parser called
<< decl dispatch: TokIdent "mkSimpleClause"
<< funDecl: next token=TokIdent "mkSimpleClause"
<< funClause: next token=TokIdent "mkSimpleClause"
<< patternParser: (pAs <|> makeCons)PApp (PVar "pats") [PVar "body",PVar "whereDecls"]
<< funClause: args=[PApp (PVar "pats") [PVar "body",PVar "whereDecls"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokTypeIdent "FunClause"
<< exprCore next token: TokTypeIdent "FunClause"
<< atomBaseCore next token: TokTypeIdent "FunClause"
<< atomBaseCore next token: TokIdent "pats"
<< atomBaseCore next token: TokTypeIdent "Nothing"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "whereDecls"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "mkGuardedClause"
<< declBody: return DeclFunGroup "mkSimpleClause" [FunClause [PApp (PVar "pats") [PVar "body",PVar "whereDecls"]] Nothing (Just (EApp (EApp (EApp (EApp (EVarType "FunClause") (EVar "pats")) (EVarType "Nothing")) (EApp (EVarType "Just") (EVar "body"))) (EVar "whereDecls"))) Nothing]
<< decl next token: TokIdent "mkGuardedClause"
<< decl parser called
<< decl dispatch: TokIdent "mkGuardedClause"
<< funDecl: next token=TokIdent "mkGuardedClause"
<< funClause: next token=TokIdent "mkGuardedClause"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "mkGuardedClause"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TTuple [TCon "Expr",TCon "Expr"]
<< parseTypeCore: TCon "Decl"
<< parseTypeCore: TCon "FunClause"
<< parseTypeCore: TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")
<< parseTypeCore: TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))
<< parseTypeCore: TFun (TList (TCon "Pattern")) (TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))
<< parsed type signature: mkGuardedClause :: TFun (TList (TCon "Pattern")) (TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))
<< returning DeclTypeSig: DeclTypeSig "mkGuardedClause" (TFun (TList (TCon "Pattern")) (TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))))
<< declBody: return DeclTypeSig "mkGuardedClause" (TFun (TList (TCon "Pattern")) (TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause"))))
<< decl next token: TokIdent "mkGuardedClause"
<< decl parser called
<< decl dispatch: TokIdent "mkGuardedClause"
<< funDecl: next token=TokIdent "mkGuardedClause"
<< funClause: next token=TokIdent "mkGuardedClause"
<< patternParser: (pAs <|> makeCons)PApp (PVar "pats") [PVar "guards",PVar "whereDecls"]
<< funClause: args=[PApp (PVar "pats") [PVar "guards",PVar "whereDecls"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokTypeIdent "FunClause"
<< exprCore next token: TokTypeIdent "FunClause"
<< atomBaseCore next token: TokTypeIdent "FunClause"
<< atomBaseCore next token: TokIdent "pats"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "guards"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "guards"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "guards"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokTypeIdent "Nothing"
<< atomBaseCore next token: TokIdent "whereDecls"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "funDecl"
<< declBody: return DeclFunGroup "mkGuardedClause" [FunClause [PApp (PVar "pats") [PVar "guards",PVar "whereDecls"]] Nothing (Just (EApp (EApp (EApp (EApp (EVarType "FunClause") (EVar "pats")) (EApp (EVarType "Just") (EVar "guards"))) (EVarType "Nothing")) (EVar "whereDecls"))) Nothing]
<< decl next token: TokIdent "funDecl"
<< decl parser called
<< decl dispatch: TokIdent "funDecl"
<< funDecl: next token=TokIdent "funDecl"
<< funClause: next token=TokIdent "funDecl"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "funDecl"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parsed type signature: funDecl :: TApp (TCon "Parser") (TCon "Decl")
<< returning DeclTypeSig: DeclTypeSig "funDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< declBody: return DeclTypeSig "funDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< decl next token: TokIdent "funDecl"
<< decl parser called
<< decl dispatch: TokIdent "funDecl"
<< funDecl: next token=TokIdent "funDecl"
<< funClause: next token=TokIdent "funDecl"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< funDecl: next token=") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokString "<< funDecl: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "name") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "clause1") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "name") [],PApp (PVar "clause1") []]) []
<< expr dispatch: TokIdent "funClause"
<< exprCore next token: TokIdent "funClause"
<< atomBaseCore next token: TokIdent "funClause"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "rest"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< expr dispatch: TokIdent "many"
<< exprCore next token: TokIdent "many"
<< atomBaseCore next token: TokIdent "many"
<< exprCore next token: TokIdent "try"
<< atomBaseCore next token: TokIdent "try"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "try"
<< atomBaseCore next token: TokIdent "try"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "try"
<< atomBaseCore next token: TokIdent "try"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "funClauseWithName"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokIdent "name"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokIdent "name"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokTypeIdent "DeclFunGroup"
<< atomBaseCore next token: TokIdent "name"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokIdent "clause1"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "funClause"
<< funClauseWithName: next token=TokIdent "funClause"
<< declBody: return DeclFunGroup "funDecl" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< funDecl: next token=") (EVar "++")) (EVar "show")) (EVar "t"))),Bind (PApp (PTuple [PApp (PVar "name") [],PApp (PVar "clause1") []]) []) (EVar "funClause"),Bind (PApp (PVar "rest") []) (EApp (EVar "many") (EApp (EVar "try") (EApp (EVar "funClauseWithName") (EVar "name")))),ExprStmt (EReturn (EApp (EApp (EVarType "DeclFunGroup") (EVar "name")) (EApp (EApp (EVar "clause1") (EVar ":")) (EVar "rest"))))])) Nothing]
<< decl next token: TokIdent "funClause"
<< decl parser called
<< decl dispatch: TokIdent "funClause"
<< funDecl: next token=TokIdent "funClause"
<< funClause: next token=TokIdent "funClause"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "funClause"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "FunClause"
<< parseTypeCore: TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])
<< parsed type signature: funClause :: TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])
<< returning DeclTypeSig: DeclTypeSig "funClause" (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"]))
<< declBody: return DeclTypeSig "funClause" (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"]))
<< decl next token: TokIdent "funClause"
<< decl parser called
<< decl dispatch: TokIdent "funClause"
<< funDecl: next token=TokIdent "funClause"
<< funClause: next token=TokIdent "funClause"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t0"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t0") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< funClause: next token=") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t0"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t0"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokString "<< funClause: next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t0"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "name"
<< pattern1: (pAs <|> makeCons)PApp (PVar "name") []
<< expr dispatch: TokIdent "ident"
<< exprCore next token: TokIdent "ident"
<< atomBaseCore next token: TokIdent "ident"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "args"
<< pattern1: (pAs <|> makeCons)PApp (PVar "args") []
<< expr dispatch: TokIdent "many"
<< exprCore next token: TokIdent "many"
<< atomBaseCore next token: TokIdent "many"
<< atomBaseCore next token: TokIdent "patternParser"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "skipNewlines"
<< pattern1: (pAs <|> makeCons)PApp (PVar "skipNewlines") []
<< expr dispatch: TokIdent "skipNewlines"
<< exprCore next token: TokIdent "skipNewlines"
<< atomBaseCore next token: TokIdent "skipNewlines"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< funClause: args=") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokString " t = "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokString " t = "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokString "<< funClause: args="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokString " t = "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "t"
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TokSymbol" []) [PString "="]
<< expr dispatch: TokIdent "parseSimpleClause"
<< exprCore next token: TokIdent "parseSimpleClause"
<< atomBaseCore next token: TokIdent "parseSimpleClause"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TokSymbol" []) [PString "|"]
<< expr dispatch: TokIdent "parseGuardedClause"
<< exprCore next token: TokIdent "parseGuardedClause"
<< atomBaseCore next token: TokIdent "parseGuardedClause"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokIdent "parseGuardedClause"
<< exprCore next token: TokIdent "parseGuardedClause"
<< atomBaseCore next token: TokIdent "parseGuardedClause"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "parseSimpleClause"
<< funClauseWithName: next token=TokIdent "parseSimpleClause"
<< declBody: return DeclFunGroup "funClause" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t0") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< funClause: next token=") (EVar "++")) (EVar "show")) (EVar "t0"))),Bind (PApp (PVar "name") []) (EVar "ident"),Bind (PApp (PVar "args") []) (EApp (EVar "many") (EVar "patternParser")),ExprStmt (EVar "skipNewlines"),Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EApp (EApp (EApp (EApp (EApp (EString "<< funClause: args=") (EVar "++")) (EVar "show")) (EVar "args")) (EVar "++")) (EString " t = ")) (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PConstr "TokSymbol" []) [PString "="]) (EApp (EApp (EVar "parseSimpleClause") (EVar "name")) (EVar "args")),CaseAlt (PApp (PConstr "TokSymbol" []) [PString "|"]) (EApp (EApp (EVar "parseGuardedClause") (EVar "name")) (EVar "args")),CaseAlt (PApp PWildcard []) (EApp (EApp (EVar "parseGuardedClause") (EVar "name")) (EVar "args"))])])) Nothing]
<< decl next token: TokIdent "parseSimpleClause"
<< decl parser called
<< decl dispatch: TokIdent "parseSimpleClause"
<< funDecl: next token=TokIdent "parseSimpleClause"
<< funClause: next token=TokIdent "parseSimpleClause"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseSimpleClause"
<< parseType dispatch: TokTypeIdent "Name"
<< parseTypeCore: TCon "Pattern"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "Name"
<< parseTypeCore: TCon "FunClause"
<< parseTypeCore: TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])
<< parseTypeCore: TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"]))
<< parseTypeCore: TFun (TCon "Name") (TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])))
<< parsed type signature: parseSimpleClause :: TFun (TCon "Name") (TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])))
<< returning DeclTypeSig: DeclTypeSig "parseSimpleClause" (TFun (TCon "Name") (TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"]))))
<< declBody: return DeclTypeSig "parseSimpleClause" (TFun (TCon "Name") (TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"]))))
<< decl next token: TokIdent "parseSimpleClause"
<< decl parser called
<< decl dispatch: TokIdent "parseSimpleClause"
<< funDecl: next token=TokIdent "parseSimpleClause"
<< funClause: next token=TokIdent "parseSimpleClause"
<< patternParser: (pAs <|> makeCons)PApp (PVar "name") [PVar "args"]
<< funClause: args=[PApp (PVar "name") [PVar "args"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "="]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "="
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< parseSimpleClause:2 next token=") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokString "<< parseSimpleClause:2 next token="
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "bracesV3"
<< pattern1: (pAs <|> makeCons)PApp (PVar "bracesV3") []
<< expr dispatch: TokIdent "bracesV3"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokKeyword "do"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "symbol"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "parseSimpleClause" [FunClause [PApp (PVar "name") [PVar "args"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Decl.DeclParser.Fun" (Just [ExportVar "funDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "guard"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "mkSimpleClause" (TFun (TList (TCon "Pattern")) (TFun (TCon "Expr") (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))),DeclFunGroup "mkSimpleClause" [FunClause [PApp (PVar "pats") [PVar "body",PVar "whereDecls"]] Nothing (Just (EApp (EApp (EApp (EApp (EVarType "FunClause") (EVar "pats")) (EVarType "Nothing")) (EApp (EVarType "Just") (EVar "body"))) (EVar "whereDecls"))) Nothing],DeclTypeSig "mkGuardedClause" (TFun (TList (TCon "Pattern")) (TFun (TList (TTuple [TCon "Expr",TCon "Expr"])) (TFun (TApp (TCon "Maybe") (TList (TCon "Decl"))) (TCon "FunClause")))),DeclFunGroup "mkGuardedClause" [FunClause [PApp (PVar "pats") [PVar "guards",PVar "whereDecls"]] Nothing (Just (EApp (EApp (EApp (EApp (EVarType "FunClause") (EVar "pats")) (EApp (EVarType "Just") (EVar "guards"))) (EVarType "Nothing")) (EVar "whereDecls"))) Nothing],DeclTypeSig "funDecl" (TApp (TCon "Parser") (TCon "Decl")),DeclFunGroup "funDecl" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< funDecl: next token=") (EVar "++")) (EVar "show")) (EVar "t"))),Bind (PApp (PTuple [PApp (PVar "name") [],PApp (PVar "clause1") []]) []) (EVar "funClause"),Bind (PApp (PVar "rest") []) (EApp (EVar "many") (EApp (EVar "try") (EApp (EVar "funClauseWithName") (EVar "name")))),ExprStmt (EReturn (EApp (EApp (EVarType "DeclFunGroup") (EVar "name")) (EApp (EApp (EVar "clause1") (EVar ":")) (EVar "rest"))))])) Nothing],DeclTypeSig "funClause" (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])),DeclFunGroup "funClause" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t0") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< funClause: next token=") (EVar "++")) (EVar "show")) (EVar "t0"))),Bind (PApp (PVar "name") []) (EVar "ident"),Bind (PApp (PVar "args") []) (EApp (EVar "many") (EVar "patternParser")),ExprStmt (EVar "skipNewlines"),Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EApp (EApp (EApp (EApp (EApp (EString "<< funClause: args=") (EVar "++")) (EVar "show")) (EVar "args")) (EVar "++")) (EString " t = ")) (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PConstr "TokSymbol" []) [PString "="]) (EApp (EApp (EVar "parseSimpleClause") (EVar "name")) (EVar "args")),CaseAlt (PApp (PConstr "TokSymbol" []) [PString "|"]) (EApp (EApp (EVar "parseGuardedClause") (EVar "name")) (EVar "args")),CaseAlt (PApp PWildcard []) (EApp (EApp (EVar "parseGuardedClause") (EVar "name")) (EVar "args"))])])) Nothing],DeclTypeSig "parseSimpleClause" (TFun (TCon "Name") (TFun (TList (TCon "Pattern")) (TApp (TCon "Parser") (TTuple [TCon "Name",TCon "FunClause"])))),DeclFunGroup "parseSimpleClause" [FunClause [PApp (PVar "name") [PVar "args"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseSimpleClause:2 next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseGuardedClause",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "FunClause",TokSymbol ")",TokNewline,TokIdent "parseGuardedClause",TokIdent "name",TokIdent "args",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardedClause: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "whereBlock",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funDeclGroup",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "funDeclGroup",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funDeclGroup: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "name1",TokSymbol ",",TokIdent "clause1",TokSymbol ")",TokSymbol "<-",TokIdent "funClause",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "funClauseWithName",TokIdent "name1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclFunGroup",TokIdent "name1",TokSymbol "(",TokIdent "clause1",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "funClauseWithName",TokSymbol "::",TokTypeIdent "Name",TokArrow,TokTypeIdent "Parser",TokTypeIdent "FunClause",TokNewline,TokIdent "funClauseWithName",TokIdent "name",TokSymbol "=",TokIdent "try",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funClauseWithName: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name'",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "guard",TokSymbol "(",TokIdent "name",TokSymbol "==",TokIdent "name'",TokSymbol ")",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "patternParser",TokSymbol ";",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "=",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TokSymbol",TokString "|",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "guardedRhs",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkGuardedClause",TokIdent "args",TokIdent "guards",TokIdent "w",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "w",TokSymbol "<-",TokIdent "optional",TokIdent "whereBlock",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "mkSimpleClause",TokIdent "args",TokIdent "e",TokIdent "w",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "whereBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t0",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock: next token",TokOperator "++",TokIdent "show",TokIdent "t0",TokSymbol ")",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< whereBlock:2 next token",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "decls",TokSymbol "<-",TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "funDecl",TokVRBrace,TokNewline,TokKeyword "return",TokIdent "decls",TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardedRhsM",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhsM",TokSymbol "=",TokIdent "many1",TokIdent "parseGuardLine",TokNewline,TokIdent "parseGuardLine",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "parseGuardLine",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseGuardLine: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardedRhs",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "guardedRhs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many1",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "skipSeparators",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< guardedRhs: next token = ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "parseGuardLine",TokVRBrace,TokVRBrace,TokNewline,TokIdent "funHead",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "funHead",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funHead pattern: ",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "p",TokKeyword "of",TokVLBrace,TokTypeIdent "PVar",TokIdent "name",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "moreArgs",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "args",TokOperator "++",TokIdent "moreArgs",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "Function definition must start with a variable name",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Import.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Import (importDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)

import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

-- import ï∂
importDecl :: Parser Decl
importDecl = do
  myTrace "<< importDecl parser called"
  _ <- keyword "import"
  isQual <- option False (True <$ keyword "qualified")
  t <- lookAhead anyToken
  myTrace ("<< importDecl: " ++ show t)
  modName <- moduleName
  alias <- optional (keyword "as" *> identI)
  isHiding <- option False (True <$ keyword "hiding")
  items <- optional importList
  return $ DeclImport isQual modName alias isHiding items

importList :: Parser [ImportItem]
importList =
  parens $
    pure ImportAllItems <$ symbol ".."
      <|> sepBy1 importIdent (symbol ",")

{-}
importIdent :: Parser ImportItem
importIdent = do
  name <- identI
  m <-
    optional $
      parensI $
        (ImportTypeAll name <$ symbol "..")
          <|> (ImportTypeSome name <$> sepBy1 identI (symbol ","))
  return $ case m of
    Just x -> x
    Nothing -> ImportVar name
-}
importIdent :: Parser ImportItem
importIdent = do
  name <- identI <|> parens operatorI
  m <-
    optional $
      parensI $
        (ImportTypeAll name <$ symbol "..")
          <|> (ImportTypeSome name <$> sepBy1 identI (symbol ","))
  return $ case m of
    Just x -> x
    Nothing -> ImportVar name

{-}
operatorI :: Parser Name
operatorI = do
  TokOperator op <- token satisfyOperator
  return op

satisfyOperator :: Token -> Bool
satisfyOperator (TokOperator _) = True
satisfyOperator _ = False
-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Import",TokSymbol "(",TokIdent "importDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "importDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "importDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< importDecl parser called",TokSymbol ";",TokSymbol "_",TokSymbol "<-",TokIdent "keyword",TokString "import",TokSymbol ";",TokIdent "isQual",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "qualified",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< importDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "modName",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "alias",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "as",TokOperator "*>",TokIdent "identI",TokSymbol ")",TokSymbol ";",TokIdent "isHiding",TokSymbol "<-",TokIdent "option",TokTypeIdent "False",TokSymbol "(",TokTypeIdent "True",TokOperator "<",TokOperator "$",TokIdent "keyword",TokString "hiding",TokSymbol ")",TokSymbol ";",TokIdent "items",TokSymbol "<-",TokIdent "optional",TokIdent "importList",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclImport",TokIdent "isQual",TokIdent "modName",TokIdent "alias",TokIdent "isHiding",TokIdent "items",TokVRBrace,TokNewline,TokIdent "importList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "ImportItem",TokSymbol "]",TokNewline,TokIdent "importList",TokSymbol "=",TokVLBrace,TokIdent "parens",TokOperator "$",TokVLBrace,TokIdent "pure",TokTypeIdent "ImportAllItems",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokIdent "importIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "importIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "ImportItem",TokNewline,TokIdent "importIdent",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokOperator "<|>",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokIdent "m",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokOperator "$",TokVLBrace,TokIdent "parensI",TokOperator "$",TokVLBrace,TokSymbol "(",TokTypeIdent "ImportTypeAll",TokIdent "name",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "ImportTypeSome",TokIdent "name",TokOperator "<$>",TokIdent "sepBy1",TokIdent "identI",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "m",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokIdent "x",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "ImportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "importDecl"
<< declBody: return DeclModule "Decl.DeclParser.Import" (Just [ExportVar "importDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "importDecl"
<< decl parser called
<< decl dispatch: TokIdent "importDecl"
<< funDecl: next token=TokIdent "importDecl"
<< funClause: next token=TokIdent "importDecl"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "importDecl"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parsed type signature: importDecl :: TApp (TCon "Parser") (TCon "Decl")
<< returning DeclTypeSig: DeclTypeSig "importDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< declBody: return DeclTypeSig "importDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< decl next token: TokIdent "importDecl"
<< decl parser called
<< decl dispatch: TokIdent "importDecl"
<< funDecl: next token=TokIdent "importDecl"
<< funClause: next token=TokIdent "importDecl"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") [PString "<< importDecl parser called"]
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokString "<< importDecl parser called"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol "_"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "import"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "isQual"
<< pattern1: (pAs <|> makeCons)PApp (PVar "isQual") []
<< expr dispatch: TokIdent "option"
<< exprCore next token: TokIdent "option"
<< atomBaseCore next token: TokIdent "option"
<< atomBaseCore next token: TokTypeIdent "False"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "qualified"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "qualified"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "qualified"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< importDecl: ") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokString "<< importDecl: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "modName"
<< pattern1: (pAs <|> makeCons)PApp (PVar "modName") []
<< expr dispatch: TokIdent "moduleName"
<< exprCore next token: TokIdent "moduleName"
<< atomBaseCore next token: TokIdent "moduleName"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "alias"
<< pattern1: (pAs <|> makeCons)PApp (PVar "alias") []
<< expr dispatch: TokIdent "optional"
<< exprCore next token: TokIdent "optional"
<< atomBaseCore next token: TokIdent "optional"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "as"
<< atomBaseCore next token: TokOperator "*>"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "as"
<< atomBaseCore next token: TokOperator "*>"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "as"
<< atomBaseCore next token: TokOperator "*>"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "isHiding"
<< pattern1: (pAs <|> makeCons)PApp (PVar "isHiding") []
<< expr dispatch: TokIdent "option"
<< exprCore next token: TokIdent "option"
<< atomBaseCore next token: TokIdent "option"
<< atomBaseCore next token: TokTypeIdent "False"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "hiding"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "hiding"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokOperator "<"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "hiding"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "items"
<< pattern1: (pAs <|> makeCons)PApp (PVar "items") []
<< expr dispatch: TokIdent "optional"
<< exprCore next token: TokIdent "optional"
<< atomBaseCore next token: TokIdent "optional"
<< atomBaseCore next token: TokIdent "importList"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokOperator "$"
<< exprCore next token: TokOperator "$"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokTypeIdent "DeclImport"
<< atomBaseCore next token: TokIdent "isQual"
<< atomBaseCore next token: TokIdent "modName"
<< atomBaseCore next token: TokIdent "alias"
<< atomBaseCore next token: TokIdent "isHiding"
<< atomBaseCore next token: TokIdent "items"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "importList"
<< funClauseWithName: next token=TokIdent "importList"
<< declBody: return DeclFunGroup "importDecl" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "myTrace") (EString "<< importDecl parser called")),Bind (PApp PWildcard []) (EApp (EVar "keyword") (EString "import")),Bind (PApp (PVar "isQual") []) (EApp (EApp (EVar "option") (EVarType "False")) (EApp (EApp (EApp (EApp (EVarType "True") (EVar "<")) (EVar "$")) (EVar "keyword")) (EString "qualified"))),Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< importDecl: ") (EVar "++")) (EVar "show")) (EVar "t"))),Bind (PApp (PVar "modName") []) (EVar "moduleName"),Bind (PApp (PVar "alias") []) (EApp (EVar "optional") (EApp (EApp (EApp (EVar "keyword") (EString "as")) (EVar "*>")) (EVar "identI"))),Bind (PApp (PVar "isHiding") []) (EApp (EApp (EVar "option") (EVarType "False")) (EApp (EApp (EApp (EApp (EVarType "True") (EVar "<")) (EVar "$")) (EVar "keyword")) (EString "hiding"))),Bind (PApp (PVar "items") []) (EApp (EVar "optional") (EVar "importList")),ExprStmt (EReturn (EApp (EApp (EApp (EApp (EApp (EApp (EVar "$") (EVarType "DeclImport")) (EVar "isQual")) (EVar "modName")) (EVar "alias")) (EVar "isHiding")) (EVar "items")))])) Nothing]
<< decl next token: TokIdent "importList"
<< decl parser called
<< decl dispatch: TokIdent "importList"
<< funDecl: next token=TokIdent "importList"
<< funClause: next token=TokIdent "importList"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "importList"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TCon "ImportItem"
<< parseTypeCore: TApp (TCon "Parser") (TList (TCon "ImportItem"))
<< parsed type signature: importList :: TApp (TCon "Parser") (TList (TCon "ImportItem"))
<< returning DeclTypeSig: DeclTypeSig "importList" (TApp (TCon "Parser") (TList (TCon "ImportItem")))
<< declBody: return DeclTypeSig "importList" (TApp (TCon "Parser") (TList (TCon "ImportItem")))
<< decl next token: TokIdent "importList"
<< decl parser called
<< decl dispatch: TokIdent "importList"
<< funDecl: next token=TokIdent "importList"
<< funClause: next token=TokIdent "importList"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokIdent "parens"
<< exprCore next token: TokIdent "parens"
<< atomBaseCore next token: TokIdent "parens"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "pure"
<< whereBlock: next tokenTokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< typeSigDecl: TokIdent "importList"
<< valueDecl: TokIdent "importList"
<< patternParser: (pAs <|> makeCons)PApp (PVar "importList") []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
Just ([DeclModule "Decl.DeclParser.Import" (Just [ExportVar "importDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "importDecl" (TApp (TCon "Parser") (TCon "Decl")),DeclFunGroup "importDecl" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "myTrace") (EString "<< importDecl parser called")),Bind (PApp PWildcard []) (EApp (EVar "keyword") (EString "import")),Bind (PApp (PVar "isQual") []) (EApp (EApp (EVar "option") (EVarType "False")) (EApp (EApp (EApp (EApp (EVarType "True") (EVar "<")) (EVar "$")) (EVar "keyword")) (EString "qualified"))),Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< importDecl: ") (EVar "++")) (EVar "show")) (EVar "t"))),Bind (PApp (PVar "modName") []) (EVar "moduleName"),Bind (PApp (PVar "alias") []) (EApp (EVar "optional") (EApp (EApp (EApp (EVar "keyword") (EString "as")) (EVar "*>")) (EVar "identI"))),Bind (PApp (PVar "isHiding") []) (EApp (EApp (EVar "option") (EVarType "False")) (EApp (EApp (EApp (EApp (EVarType "True") (EVar "<")) (EVar "$")) (EVar "keyword")) (EString "hiding"))),Bind (PApp (PVar "items") []) (EApp (EVar "optional") (EVar "importList")),ExprStmt (EReturn (EApp (EApp (EApp (EApp (EApp (EApp (EVar "$") (EVarType "DeclImport")) (EVar "isQual")) (EVar "modName")) (EVar "alias")) (EVar "isHiding")) (EVar "items")))])) Nothing],DeclTypeSig "importList" (TApp (TCon "Parser") (TList (TCon "ImportItem")))],[TokNewline,TokIdent "importList",TokSymbol "=",TokVLBrace,TokIdent "parens",TokOperator "$",TokVLBrace,TokIdent "pure",TokTypeIdent "ImportAllItems",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokIdent "importIdent",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "importIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "ImportItem",TokNewline,TokIdent "importIdent",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "identI",TokOperator "<|>",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokIdent "m",TokSymbol "<-",TokVLBrace,TokIdent "optional",TokOperator "$",TokVLBrace,TokIdent "parensI",TokOperator "$",TokVLBrace,TokSymbol "(",TokTypeIdent "ImportTypeAll",TokIdent "name",TokOperator "<",TokOperator "$",TokIdent "symbol",TokString "..",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "ImportTypeSome",TokIdent "name",TokOperator "<$>",TokIdent "sepBy1",TokIdent "identI",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "m",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokIdent "x",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "ImportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Decl/DeclParser/Instance.hs ===
-- Raw Source --


-- Tokens from Lexer --
[]

-- Parsing --

-- Parsed AST --
Just ([],[])

=== Running: src/Decl/DeclParser/Module.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Module (moduleDecl) where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)

import Data.Char (isUpper)
import Data.List (intercalate)
import Decl.DeclParser.Util
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

moduleDecl :: Parser Decl
moduleDecl = do
  keyword "module"
  name <- moduleName
  try (exportWhere name) <|> exportWhere2 name

exportWhere :: String -> Parser Decl
exportWhere name = do
  exports <- optional (bracesV3 exportList)
  skipSeparators
  keyword "where"
  return (DeclModule name exports)

exportWhere2 :: String -> Parser Decl
exportWhere2 name = do
  bracesV $ do
    exports <- optional exportList
    skipSeparators
    keyword "where"
    return (DeclModule name exports)

exportItem :: Parser Export
exportItem = do
  t <- lookAhead anyToken
  myTrace ("<< exportItem: next token=" ++ show t)
  name <- typeIdent <|> ident <|> parens operatorI
  hasAll <- optional (parens (symbol ".."))
  return $ case hasAll of
    Just _ -> ExportType name True
    Nothing ->
      if isUpper (head name)
        then ExportType name False
        else ExportVar name

exportList :: Parser [Export]
exportList = parens (exportItem `sepEndBy` symbol ",")


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Module",TokSymbol "(",TokIdent "moduleDecl",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "moduleDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "moduleDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "module",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "moduleName",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "exportWhere",TokIdent "name",TokSymbol ")",TokOperator "<|>",TokIdent "exportWhere2",TokIdent "name",TokVRBrace,TokNewline,TokIdent "exportWhere",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "bracesV3",TokIdent "exportList",TokSymbol ")",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exportWhere2",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "exportWhere2",TokIdent "name",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokIdent "exportList",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportItem",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Export",TokNewline,TokIdent "exportItem",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exportItem: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokIdent "hasAll",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "symbol",TokString "..",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "hasAll",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "_",TokArrow,TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "True",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokVLBrace,TokKeyword "then",TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "False",TokSymbol ";",TokKeyword "else",TokTypeIdent "ExportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokNewline,TokIdent "exportList",TokSymbol "=",TokIdent "parens",TokSymbol "(",TokIdent "exportItem",TokUnknown '`',TokIdent "sepEndBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "moduleDecl"
<< declBody: return DeclModule "Decl.DeclParser.Module" (Just [ExportVar "moduleDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "moduleDecl"
<< decl parser called
<< decl dispatch: TokIdent "moduleDecl"
<< funDecl: next token=TokIdent "moduleDecl"
<< funClause: next token=TokIdent "moduleDecl"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "moduleDecl"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parsed type signature: moduleDecl :: TApp (TCon "Parser") (TCon "Decl")
<< returning DeclTypeSig: DeclTypeSig "moduleDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< declBody: return DeclTypeSig "moduleDecl" (TApp (TCon "Parser") (TCon "Decl"))
<< decl next token: TokIdent "moduleDecl"
<< decl parser called
<< decl dispatch: TokIdent "moduleDecl"
<< funDecl: next token=TokIdent "moduleDecl"
<< funClause: next token=TokIdent "moduleDecl"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "module"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "module"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "name"
<< pattern1: (pAs <|> makeCons)PApp (PVar "name") []
<< expr dispatch: TokIdent "moduleName"
<< exprCore next token: TokIdent "moduleName"
<< atomBaseCore next token: TokIdent "moduleName"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "try"
<< pattern1: (pAs <|> makeCons)PApp (PVar "exportWhere") [PVar "name"]
<< pattern1: (pAs <|> makeCons)PApp (PVar "try") [PApp (PVar "exportWhere") [PVar "name"]]
<< expr dispatch: TokIdent "try"
<< exprCore next token: TokIdent "try"
<< atomBaseCore next token: TokIdent "try"
<< exprCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "exportWhere"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "exportWhere2"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "exportWhere"
<< funClauseWithName: next token=TokIdent "exportWhere"
<< declBody: return DeclFunGroup "moduleDecl" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "keyword") (EString "module")),Bind (PApp (PVar "name") []) (EVar "moduleName"),ExprStmt (EApp (EApp (EApp (EApp (EVar "try") (EApp (EVar "exportWhere") (EVar "name"))) (EVar "<|>")) (EVar "exportWhere2")) (EVar "name"))])) Nothing]
<< decl next token: TokIdent "exportWhere"
<< decl parser called
<< decl dispatch: TokIdent "exportWhere"
<< funDecl: next token=TokIdent "exportWhere"
<< funClause: next token=TokIdent "exportWhere"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "exportWhere"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parseTypeCore: TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))
<< parsed type signature: exportWhere :: TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))
<< returning DeclTypeSig: DeclTypeSig "exportWhere" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl")))
<< declBody: return DeclTypeSig "exportWhere" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl")))
<< decl next token: TokIdent "exportWhere"
<< decl parser called
<< decl dispatch: TokIdent "exportWhere"
<< funDecl: next token=TokIdent "exportWhere"
<< funClause: next token=TokIdent "exportWhere"
<< patternParser: (pAs <|> makeCons)PApp (PVar "name") []
<< funClause: args=[PApp (PVar "name") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "exports"
<< pattern1: (pAs <|> makeCons)PApp (PVar "exports") []
<< expr dispatch: TokIdent "optional"
<< exprCore next token: TokIdent "optional"
<< atomBaseCore next token: TokIdent "optional"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "exportList"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "exportList"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "exportList"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "skipSeparators"
<< pattern1: (pAs <|> makeCons)PApp (PVar "skipSeparators") []
<< expr dispatch: TokIdent "skipSeparators"
<< exprCore next token: TokIdent "skipSeparators"
<< atomBaseCore next token: TokIdent "skipSeparators"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "where"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "where"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "exports"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "exports"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokTypeIdent "DeclModule"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "exports"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "exportWhere2"
<< funClauseWithName: next token=TokIdent "exportWhere2"
<< declBody: return DeclFunGroup "exportWhere" [FunClause [PApp (PVar "name") []] Nothing (Just (EDo [Bind (PApp (PVar "exports") []) (EApp (EVar "optional") (EApp (EVar "bracesV3") (EVar "exportList"))),ExprStmt (EVar "skipSeparators"),ExprStmt (EApp (EVar "keyword") (EString "where")),ExprStmt (EReturn (EApp (EApp (EVarType "DeclModule") (EVar "name")) (EVar "exports")))])) Nothing]
<< decl next token: TokIdent "exportWhere2"
<< decl parser called
<< decl dispatch: TokIdent "exportWhere2"
<< funDecl: next token=TokIdent "exportWhere2"
<< funClause: next token=TokIdent "exportWhere2"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "exportWhere2"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Decl")
<< parseTypeCore: TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))
<< parsed type signature: exportWhere2 :: TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))
<< returning DeclTypeSig: DeclTypeSig "exportWhere2" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl")))
<< declBody: return DeclTypeSig "exportWhere2" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl")))
<< decl next token: TokIdent "exportWhere2"
<< decl parser called
<< decl dispatch: TokIdent "exportWhere2"
<< funDecl: next token=TokIdent "exportWhere2"
<< funClause: next token=TokIdent "exportWhere2"
<< patternParser: (pAs <|> makeCons)PApp (PVar "name") []
<< funClause: args=[PApp (PVar "name") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "bracesV"
<< pattern1: (pAs <|> makeCons)PApp (PVar "bracesV") []
<< expr dispatch: TokIdent "bracesV"
<< exprCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokKeyword "do"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "bracesV"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "exportWhere2" [FunClause [PApp (PVar "name") []] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Decl.DeclParser.Module" (Just [ExportVar "moduleDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Util", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "moduleDecl" (TApp (TCon "Parser") (TCon "Decl")),DeclFunGroup "moduleDecl" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "keyword") (EString "module")),Bind (PApp (PVar "name") []) (EVar "moduleName"),ExprStmt (EApp (EApp (EApp (EApp (EVar "try") (EApp (EVar "exportWhere") (EVar "name"))) (EVar "<|>")) (EVar "exportWhere2")) (EVar "name"))])) Nothing],DeclTypeSig "exportWhere" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))),DeclFunGroup "exportWhere" [FunClause [PApp (PVar "name") []] Nothing (Just (EDo [Bind (PApp (PVar "exports") []) (EApp (EVar "optional") (EApp (EVar "bracesV3") (EVar "exportList"))),ExprStmt (EVar "skipSeparators"),ExprStmt (EApp (EVar "keyword") (EString "where")),ExprStmt (EReturn (EApp (EApp (EVarType "DeclModule") (EVar "name")) (EVar "exports")))])) Nothing],DeclTypeSig "exportWhere2" (TFun (TCon "String") (TApp (TCon "Parser") (TCon "Decl"))),DeclFunGroup "exportWhere2" [FunClause [PApp (PVar "name") []] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "bracesV",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "exports",TokSymbol "<-",TokIdent "optional",TokIdent "exportList",TokSymbol ";",TokIdent "skipSeparators",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclModule",TokIdent "name",TokIdent "exports",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportItem",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Export",TokNewline,TokIdent "exportItem",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exportItem: next token=",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "parens",TokIdent "operatorI",TokSymbol ";",TokIdent "hasAll",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "symbol",TokString "..",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "hasAll",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "_",TokArrow,TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "True",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokVLBrace,TokKeyword "then",TokTypeIdent "ExportType",TokIdent "name",TokTypeIdent "False",TokSymbol ";",TokKeyword "else",TokTypeIdent "ExportVar",TokIdent "name",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "exportList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Export",TokSymbol "]",TokNewline,TokIdent "exportList",TokSymbol "=",TokIdent "parens",TokSymbol "(",TokIdent "exportItem",TokUnknown '`',TokIdent "sepEndBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline])

=== Running: src/Decl/DeclParser/Type.hs ===
-- Raw Source --


-- Tokens from Lexer --
[]

-- Parsing --

-- Parsed AST --
Just ([],[])

=== Running: src/Decl/DeclParser/Util.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParser.Util
  ( parensI,
    identI,
    moduleName,
    tokdot,
    operatorI,
  )
where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

identI :: Parser String
identI = ident <|> typeIdent

parensI :: Parser a -> Parser a
parensI p = symbol "(" *> p <* symbol ")"

moduleName :: Parser String
moduleName = intercalate "." <$> sepBy1 identI tokdot

tokdot :: Parser String
tokdot = token TokDot *> pure "."

operatorI :: Parser Name
operatorI = satisfyToken isOp
  where
    isOp (TokOperator s) = Just s
    isOp _ = Nothing


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Util",TokVLBrace,TokSymbol "(",TokIdent "parensI",TokSymbol ",",TokIdent "identI",TokSymbol ",",TokIdent "moduleName",TokSymbol ",",TokIdent "tokdot",TokSymbol ",",TokIdent "operatorI",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "identI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "identI",TokSymbol "=",TokIdent "ident",TokOperator "<|>",TokIdent "typeIdent",TokNewline,TokIdent "parensI",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parensI",TokIdent "p",TokSymbol "=",TokIdent "symbol",TokString "(",TokOperator "*>",TokIdent "p",TokOperator "<*",TokIdent "symbol",TokString ")",TokNewline,TokIdent "moduleName",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "moduleName",TokSymbol "=",TokIdent "intercalate",TokString ".",TokOperator "<$>",TokIdent "sepBy1",TokIdent "identI",TokIdent "tokdot",TokNewline,TokIdent "tokdot",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "tokdot",TokSymbol "=",TokIdent "token",TokTypeIdent "TokDot",TokOperator "*>",TokIdent "pure",TokString ".",TokNewline,TokIdent "operatorI",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Name",TokNewline,TokIdent "operatorI",TokSymbol "=",TokIdent "satisfyToken",TokIdent "isOp",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "isOp",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parensI"
<< exportItem: next token=TokIdent "identI"
<< exportItem: next token=TokIdent "moduleName"
<< exportItem: next token=TokIdent "tokdot"
<< exportItem: next token=TokIdent "operatorI"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Decl.DeclParser.Util" (Just [ExportVar "parensI",ExportVar "identI",ExportVar "moduleName",ExportVar "tokdot",ExportVar "operatorI"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "identI"
<< decl parser called
<< decl dispatch: TokIdent "identI"
<< funDecl: next token=TokIdent "identI"
<< funClause: next token=TokIdent "identI"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "identI"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "String")
<< parsed type signature: identI :: TApp (TCon "Parser") (TCon "String")
<< returning DeclTypeSig: DeclTypeSig "identI" (TApp (TCon "Parser") (TCon "String"))
<< declBody: return DeclTypeSig "identI" (TApp (TCon "Parser") (TCon "String"))
<< decl next token: TokIdent "identI"
<< decl parser called
<< decl dispatch: TokIdent "identI"
<< funDecl: next token=TokIdent "identI"
<< funClause: next token=TokIdent "identI"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "ident"
<< expr dispatch: TokIdent "ident"
<< exprCore next token: TokIdent "ident"
<< atomBaseCore next token: TokIdent "ident"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "typeIdent"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "parensI"
<< funClauseWithName: next token=TokIdent "parensI"
<< declBody: return DeclFunGroup "identI" [FunClause [] Nothing (Just (EApp (EApp (EVar "ident") (EVar "<|>")) (EVar "typeIdent"))) Nothing]
<< decl next token: TokIdent "parensI"
<< decl parser called
<< decl dispatch: TokIdent "parensI"
<< funDecl: next token=TokIdent "parensI"
<< funClause: next token=TokIdent "parensI"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parensI"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TVar "a")
<< parseTypeCore: TFun (TApp (TCon "Parser") (TVar "a")) (TApp (TCon "Parser") (TVar "a"))
<< parsed type signature: parensI :: TFun (TApp (TCon "Parser") (TVar "a")) (TApp (TCon "Parser") (TVar "a"))
<< returning DeclTypeSig: DeclTypeSig "parensI" (TFun (TApp (TCon "Parser") (TVar "a")) (TApp (TCon "Parser") (TVar "a")))
<< declBody: return DeclTypeSig "parensI" (TFun (TApp (TCon "Parser") (TVar "a")) (TApp (TCon "Parser") (TVar "a")))
<< decl next token: TokIdent "parensI"
<< decl parser called
<< decl dispatch: TokIdent "parensI"
<< funDecl: next token=TokIdent "parensI"
<< funClause: next token=TokIdent "parensI"
<< patternParser: (pAs <|> makeCons)PApp (PVar "p") []
<< funClause: args=[PApp (PVar "p") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "symbol"
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "("
<< atomBaseCore next token: TokOperator "*>"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokOperator "<*"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ")"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "moduleName"
<< funClauseWithName: next token=TokIdent "moduleName"
<< declBody: return DeclFunGroup "parensI" [FunClause [PApp (PVar "p") []] Nothing (Just (EApp (EApp (EApp (EApp (EApp (EApp (EVar "symbol") (EString "(")) (EVar "*>")) (EVar "p")) (EVar "<*")) (EVar "symbol")) (EString ")"))) Nothing]
<< decl next token: TokIdent "moduleName"
<< decl parser called
<< decl dispatch: TokIdent "moduleName"
<< funDecl: next token=TokIdent "moduleName"
<< funClause: next token=TokIdent "moduleName"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "moduleName"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "String")
<< parsed type signature: moduleName :: TApp (TCon "Parser") (TCon "String")
<< returning DeclTypeSig: DeclTypeSig "moduleName" (TApp (TCon "Parser") (TCon "String"))
<< declBody: return DeclTypeSig "moduleName" (TApp (TCon "Parser") (TCon "String"))
<< decl next token: TokIdent "moduleName"
<< decl parser called
<< decl dispatch: TokIdent "moduleName"
<< funDecl: next token=TokIdent "moduleName"
<< funClause: next token=TokIdent "moduleName"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "intercalate"
<< expr dispatch: TokIdent "intercalate"
<< exprCore next token: TokIdent "intercalate"
<< atomBaseCore next token: TokIdent "intercalate"
<< atomBaseCore next token: TokString "."
<< atomBaseCore next token: TokOperator "<$>"
<< atomBaseCore next token: TokIdent "sepBy1"
<< atomBaseCore next token: TokIdent "identI"
<< atomBaseCore next token: TokIdent "tokdot"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "tokdot"
<< funClauseWithName: next token=TokIdent "tokdot"
<< declBody: return DeclFunGroup "moduleName" [FunClause [] Nothing (Just (EApp (EApp (EApp (EApp (EApp (EVar "intercalate") (EString ".")) (EVar "<$>")) (EVar "sepBy1")) (EVar "identI")) (EVar "tokdot"))) Nothing]
<< decl next token: TokIdent "tokdot"
<< decl parser called
<< decl dispatch: TokIdent "tokdot"
<< funDecl: next token=TokIdent "tokdot"
<< funClause: next token=TokIdent "tokdot"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "tokdot"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "String")
<< parsed type signature: tokdot :: TApp (TCon "Parser") (TCon "String")
<< returning DeclTypeSig: DeclTypeSig "tokdot" (TApp (TCon "Parser") (TCon "String"))
<< declBody: return DeclTypeSig "tokdot" (TApp (TCon "Parser") (TCon "String"))
<< decl next token: TokIdent "tokdot"
<< decl parser called
<< decl dispatch: TokIdent "tokdot"
<< funDecl: next token=TokIdent "tokdot"
<< funClause: next token=TokIdent "tokdot"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "token"
<< expr dispatch: TokIdent "token"
<< exprCore next token: TokIdent "token"
<< atomBaseCore next token: TokIdent "token"
<< atomBaseCore next token: TokTypeIdent "TokDot"
<< atomBaseCore next token: TokOperator "*>"
<< atomBaseCore next token: TokIdent "pure"
<< atomBaseCore next token: TokString "."
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "operatorI"
<< funClauseWithName: next token=TokIdent "operatorI"
<< declBody: return DeclFunGroup "tokdot" [FunClause [] Nothing (Just (EApp (EApp (EApp (EApp (EVar "token") (EVarType "TokDot")) (EVar "*>")) (EVar "pure")) (EString "."))) Nothing]
<< decl next token: TokIdent "operatorI"
<< decl parser called
<< decl dispatch: TokIdent "operatorI"
<< funDecl: next token=TokIdent "operatorI"
<< funClause: next token=TokIdent "operatorI"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "operatorI"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Name")
<< parsed type signature: operatorI :: TApp (TCon "Parser") (TCon "Name")
<< returning DeclTypeSig: DeclTypeSig "operatorI" (TApp (TCon "Parser") (TCon "Name"))
<< declBody: return DeclTypeSig "operatorI" (TApp (TCon "Parser") (TCon "Name"))
<< decl next token: TokIdent "operatorI"
<< decl parser called
<< decl dispatch: TokIdent "operatorI"
<< funDecl: next token=TokIdent "operatorI"
<< funClause: next token=TokIdent "operatorI"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "satisfyToken"
<< expr dispatch: TokIdent "satisfyToken"
<< exprCore next token: TokIdent "satisfyToken"
<< atomBaseCore next token: TokIdent "satisfyToken"
<< atomBaseCore next token: TokIdent "isOp"
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokKeyword "where"
<< whereBlock:2 next tokenTokVLBrace
<< funDecl: next token=TokIdent "isOp"
<< funClause: next token=TokIdent "isOp"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TokOperator" []) [PVar "s"]
<< patternParser: (pAs <|> makeCons)PApp (PApp (PConstr "TokOperator" []) [PVar "s"]) []
<< funClause: args=[PApp (PApp (PConstr "TokOperator" []) [PVar "s"]) []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Just"
<< expr dispatch: TokTypeIdent "Just"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ";"
<< whereBlock: next tokenTokSymbol ";"
<< funClauseWithName: next token=TokIdent "isOp"
<< patternParser: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokTypeIdent "Nothing"
<< exprCore next token: TokTypeIdent "Nothing"
<< atomBaseCore next token: TokTypeIdent "Nothing"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokVRBrace
<< funDecl: next token=TokVRBrace
<< funClause: next token=TokVRBrace
<< declBody: return DeclFunGroup "operatorI" [FunClause [] Nothing (Just (EApp (EVar "satisfyToken") (EVar "isOp"))) (Just [DeclFunGroup "isOp" [FunClause [PApp (PApp (PConstr "TokOperator" []) [PVar "s"]) []] Nothing (Just (EApp (EVarType "Just") (EVar "s"))) Nothing,FunClause [PApp PWildcard []] Nothing (Just (EVarType "Nothing")) Nothing]])]
Just ([DeclModule "Decl.DeclParser.Util" (Just [ExportVar "parensI",ExportVar "identI",ExportVar "moduleName",ExportVar "tokdot",ExportVar "operatorI"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "identI" (TApp (TCon "Parser") (TCon "String")),DeclFunGroup "identI" [FunClause [] Nothing (Just (EApp (EApp (EVar "ident") (EVar "<|>")) (EVar "typeIdent"))) Nothing],DeclTypeSig "parensI" (TFun (TApp (TCon "Parser") (TVar "a")) (TApp (TCon "Parser") (TVar "a"))),DeclFunGroup "parensI" [FunClause [PApp (PVar "p") []] Nothing (Just (EApp (EApp (EApp (EApp (EApp (EApp (EVar "symbol") (EString "(")) (EVar "*>")) (EVar "p")) (EVar "<*")) (EVar "symbol")) (EString ")"))) Nothing],DeclTypeSig "moduleName" (TApp (TCon "Parser") (TCon "String")),DeclFunGroup "moduleName" [FunClause [] Nothing (Just (EApp (EApp (EApp (EApp (EApp (EVar "intercalate") (EString ".")) (EVar "<$>")) (EVar "sepBy1")) (EVar "identI")) (EVar "tokdot"))) Nothing],DeclTypeSig "tokdot" (TApp (TCon "Parser") (TCon "String")),DeclFunGroup "tokdot" [FunClause [] Nothing (Just (EApp (EApp (EApp (EApp (EVar "token") (EVarType "TokDot")) (EVar "*>")) (EVar "pure")) (EString "."))) Nothing],DeclTypeSig "operatorI" (TApp (TCon "Parser") (TCon "Name")),DeclFunGroup "operatorI" [FunClause [] Nothing (Just (EApp (EVar "satisfyToken") (EVar "isOp"))) (Just [DeclFunGroup "isOp" [FunClause [PApp (PApp (PConstr "TokOperator" []) [PVar "s"]) []] Nothing (Just (EApp (EVarType "Just") (EVar "s"))) Nothing,FunClause [PApp PWildcard []] Nothing (Just (EVarType "Nothing")) Nothing]])]],[TokNewline])

=== Running: src/Decl/DeclParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Decl.DeclParserCore where

import AST.Decl
import AST.Expr
-- import AST.Module (Name)
import AST.Pattern (Pattern (..))
import AST.Type (Constraint (Constraint), Type (..))
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.List (intercalate)
-- Åö Ç±Ç±Ç™ê≥ÇµÇ¢

-- (keyword) -- , whereClause)

import Decl.DeclParser.Data
import Decl.DeclParser.Fun
import Decl.DeclParser.Import
import Decl.DeclParser.Module
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprExtensions (expr, skipNewlines)
import Parser.Expr.PatternParser (pattern, patternParser)
import Parser.Type.TypeParser (constraintList, parseType, typeAtom, typeIdent, typeP)
import Utils.MyTrace

-- decls :: Parser [Decl]
-- decls = many decl
{-}
decl :: Parser Decl
decl = do
  skipNewlines
  myTrace "<< decl parser called"
  declBody
-}
isEOF :: Parser Bool
isEOF = Parser $ \ts ->
  case ts of
    [] -> Just (True, [])
    _ -> Just (False, ts)

decl :: Parser Decl
decl = do
  skipNewlines
  t <- lookAhead anyToken
  myTrace ("<< decl next token: " ++ show t)
  eof <- isEOF
  if eof
    then Parser $ \_ -> Nothing -- many decl Ç…ÅuÇ‡Ç§èIÇÌÇËÅvÇ∆ì`Ç¶ÇÈ
    else do
      myTrace "<< decl parser called"
      declBody

declBody :: Parser Decl
declBody = do
  d <- declDispatch
  myTrace ("<< declBody: return " ++ show d)
  return d

declDispatch :: Parser Decl
declDispatch = do
  t <- lookAhead anyToken
  myTrace ("<< decl dispatch: " ++ show t)
  case t of
    TokKeyword "data" -> dataDecl
    TokKeyword "newType" -> newtypeDecl
    TokKeyword "import" -> importDecl
    TokKeyword "instance" -> instanceDecl
    TokKeyword "module" -> moduleDecl
    TokKeyword "class" -> classDecl
    TokKeyword "type" -> typeAliasDecl
    -- _ -> try funDecl <|> valueDecl
    TokIdent _ -> try (funDecl) <|> try typeSigDecl <|> valueDecl
    -- TokSymbol "{" -> try (braces (funDecl decl)) <|> empty
    TokSymbol "(" -> try typeSigDecl <|> empty
    _ -> do
      myTrace ("<< unknown token in decl: " ++ show t)
      empty

-- Haskell ÉtÉ@ÉCÉãëSëÃ
program :: Parser [Decl]
program = many decl

typeSigDecl :: Parser Decl
typeSigDecl = do
  t <- lookAhead anyToken
  myTrace ("<< typeSigDecl: " ++ show t)
  name <- ident <|> operator -- name
  symbol "::"
  ty <- parseType
  myTrace ("<< parsed type signature: " ++ name ++ " :: " ++ show ty)
  let decl = DeclTypeSig name ty
  myTrace ("<< returning DeclTypeSig: " ++ show decl)
  return decl

-- ílêÈåæ
valueDecl :: Parser Decl
valueDecl = do
  t <- lookAhead anyToken
  myTrace ("<< valueDecl: " ++ show t)
  pat <- patternParser
  symbol "="
  body <- expr
  return (DeclValue pat body)

-- ÉRÉìÉXÉgÉâÉNÉ^
constr :: Parser Constraint
constr = do
  myTrace "<< constr parser called"
  cname <- typeIdent
  tys <- many parseType
  return (Constraint cname tys)

-- newtype êÈåæ
newtypeDecl :: Parser Decl
newtypeDecl = do
  myTrace "<< newtypeDecl parser called"
  keyword "newtype"
  name <- typeIdent
  vars <- many typeIdent
  symbol "="
  c <- constr
  return (DeclNewtype name vars c)

instanceDecl :: Parser Decl
instanceDecl = do
  myTrace "<< instanceDecl parser called"
  keyword "instance"
  ctx <- optional (try (constraintList <* keyword "=>"))
  className <- typeIdent
  args <- some typeAtom
  keyword "where"
  methods <- bracedBlock decl
  return (DeclInstance ctx className args methods)

classDecl :: Parser Decl
classDecl = do
  myTrace "<< classDecl parser called"
  keyword "class"
  className <- typeIdent
  vars <- some ident
  keyword "where"
  t <- lookAhead anyToken
  methods <- bracedBlock decl
  return $ DeclClass className vars methods

typeAliasDecl :: Parser Decl
typeAliasDecl = do
  myTrace "<< typeAliasDecl parser called"
  keyword "type"
  name <- typeIdent
  vars <- many ident
  symbol "="
  body <- parseType
  return $ DeclTypeAlias name vars body


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol ")",TokSymbol ",",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "intercalate",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Data",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Fun",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Import",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParser",TokDot,TokTypeIdent "Module",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "constraintList",TokSymbol ",",TokIdent "parseType",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "typeP",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "isEOF",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Bool",TokNewline,TokIdent "isEOF",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "decl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSymbol "<-",TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokIdent "eof",TokVLBrace,TokKeyword "then",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "declBody",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "d",TokSymbol "<-",TokIdent "declDispatch",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< declBody: return ",TokOperator "++",TokIdent "show",TokIdent "d",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "d",TokVRBrace,TokNewline,TokIdent "declDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "data",TokArrow,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "newType",TokArrow,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "import",TokArrow,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "instance",TokArrow,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "module",TokArrow,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "class",TokArrow,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "type",TokArrow,TokIdent "typeAliasDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokSymbol "_",TokArrow,TokIdent "try",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokOperator "<|>",TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "valueDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "(",TokArrow,TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< unknown token in decl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "program",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSymbol "=",TokIdent "many",TokIdent "decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokOperator "<|>",TokIdent "operator",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "decl",TokSymbol "=",TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "decl",TokVRBrace,TokNewline,TokIdent "valueDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSymbol "<-",TokIdent "many",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "newtypeDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "newtype",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "c",TokSymbol "<-",TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "instanceDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "instance",TokSymbol ";",TokIdent "ctx",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "classDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "class",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclClass",TokIdent "className",TokIdent "vars",TokIdent "methods",TokVRBrace,TokNewline,TokIdent "typeAliasDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "type",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclTypeAlias",TokIdent "name",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "Decl.DeclParserCore" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Data", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Fun", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Import", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParser.Module", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "isEOF"
<< decl parser called
<< decl dispatch: TokIdent "isEOF"
<< funDecl: next token=TokIdent "isEOF"
<< funClause: next token=TokIdent "isEOF"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "isEOF"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Bool")
<< parsed type signature: isEOF :: TApp (TCon "Parser") (TCon "Bool")
<< returning DeclTypeSig: DeclTypeSig "isEOF" (TApp (TCon "Parser") (TCon "Bool"))
<< declBody: return DeclTypeSig "isEOF" (TApp (TCon "Parser") (TCon "Bool"))
<< decl next token: TokIdent "isEOF"
<< decl parser called
<< decl dispatch: TokIdent "isEOF"
<< funDecl: next token=TokIdent "isEOF"
<< funClause: next token=TokIdent "isEOF"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Parser"
<< expr dispatch: TokTypeIdent "Parser"
<< exprCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokSymbol "\\"
<< pattern1: (pAs <|> makeCons)PApp (PVar "ts") []
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "\\"
<< funClauseWithName: next token=TokSymbol "\\"
<< declBody: return DeclFunGroup "isEOF" [FunClause [] Nothing (Just (EApp (EVarType "Parser") (EVar "$"))) Nothing]
<< decl next token: TokSymbol "\\"
<< decl parser called
<< decl dispatch: TokSymbol "\\"
<< unknown token in decl: TokSymbol "\\"
Just ([DeclModule "Decl.DeclParserCore" Nothing,DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeSome "Constraint" ["Constraint"],ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "intercalate"]},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Data", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Fun", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Import", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Decl.DeclParser.Module", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern",ImportVar "patternParser"]},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "constraintList",ImportVar "parseType",ImportVar "typeAtom",ImportVar "typeIdent",ImportVar "typeP"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "isEOF" (TApp (TCon "Parser") (TCon "Bool")),DeclFunGroup "isEOF" [FunClause [] Nothing (Just (EApp (EVarType "Parser") (EVar "$"))) Nothing]],[TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "True",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "False",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "decl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "decl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "eof",TokSymbol "<-",TokIdent "isEOF",TokSymbol ";",TokKeyword "if",TokIdent "eof",TokVLBrace,TokKeyword "then",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< decl parser called",TokSymbol ";",TokIdent "declBody",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "declBody",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declBody",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "d",TokSymbol "<-",TokIdent "declDispatch",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< declBody: return ",TokOperator "++",TokIdent "show",TokIdent "d",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "d",TokVRBrace,TokNewline,TokIdent "declDispatch",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "declDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< decl dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "data",TokArrow,TokIdent "dataDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "newType",TokArrow,TokIdent "newtypeDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "import",TokArrow,TokIdent "importDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "instance",TokArrow,TokIdent "instanceDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "module",TokArrow,TokIdent "moduleDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "class",TokArrow,TokIdent "classDecl",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "type",TokArrow,TokIdent "typeAliasDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokIdent",TokSymbol "_",TokArrow,TokIdent "try",TokSymbol "(",TokIdent "funDecl",TokSymbol ")",TokOperator "<|>",TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "valueDecl",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "(",TokArrow,TokIdent "try",TokIdent "typeSigDecl",TokOperator "<|>",TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokSymbol "(",TokString "<< unknown token in decl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "empty",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "program",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "program",TokSymbol "=",TokIdent "many",TokIdent "decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeSigDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< typeSigDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokOperator "<|>",TokIdent "operator",TokSymbol ";",TokIdent "symbol",TokString "::",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parsed type signature: ",TokOperator "++",TokIdent "name",TokOperator "++",TokString " :: ",TokOperator "++",TokIdent "show",TokIdent "ty",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "decl",TokSymbol "=",TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< returning DeclTypeSig: ",TokOperator "++",TokIdent "show",TokIdent "decl",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokIdent "decl",TokVRBrace,TokNewline,TokIdent "valueDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "valueDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueDecl: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "patternParser",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< constr parser called",TokSymbol ";",TokIdent "cname",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "tys",TokSymbol "<-",TokIdent "many",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cname",TokIdent "tys",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "newtypeDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "newtypeDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< newtypeDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "newtype",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "typeIdent",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "c",TokSymbol "<-",TokIdent "constr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclNewtype",TokIdent "name",TokIdent "vars",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "instanceDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "instanceDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< instanceDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "instance",TokSymbol ";",TokIdent "ctx",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "constraintList",TokOperator "<*",TokIdent "keyword",TokString "=>",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "DeclInstance",TokIdent "ctx",TokIdent "className",TokIdent "args",TokIdent "methods",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "classDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "classDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< classDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "class",TokSymbol ";",TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "keyword",TokString "where",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "methods",TokSymbol "<-",TokIdent "bracedBlock",TokIdent "decl",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclClass",TokIdent "className",TokIdent "vars",TokIdent "methods",TokVRBrace,TokNewline,TokIdent "typeAliasDecl",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Decl",TokNewline,TokIdent "typeAliasDecl",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "myTrace",TokString "<< typeAliasDecl parser called",TokSymbol ";",TokIdent "keyword",TokString "type",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "many",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseType",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "DeclTypeAlias",TokIdent "name",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline])

=== Running: src/Layout/LayoutTransform.hs ===
-- Raw Source --
module Layout.LayoutTransform (layoutTransform) where

import Lexer.Token

layoutTransform :: [Token] -> [Token]
layoutTransform toks = go toks

go :: [Token] -> [Token]
go [] = []
go (TokVNewline (x, y) : rest)
  | x == 0 && x == y = TokNewline : go rest
  | x == y = TokSymbol ";" : go rest
  -- \| x < y = TokSymbol "{" : go rest
  | x < y = TokVLBrace : go rest
  | x > y = closeBlocks (x, y) rest
go (t : rest) =
  t : go rest

closeBlocks :: (Int, Int) -> [Token] -> [Token]
closeBlocks (x, y) rest
  -- \| x > y = TokSymbol "}" : closeBlocks (x - 1, y) rest
  | x > y = TokVRBrace : closeBlocks (x - 1, y) rest
  | otherwise = TokNewline : go rest


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokSymbol "(",TokIdent "layoutTransform",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "layoutTransform",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutTransform",TokIdent "toks",TokSymbol "=",TokIdent "go",TokIdent "toks",TokNewline,TokIdent "go",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "x",TokSymbol "==",TokNumber 0,TokSymbol "&",TokSymbol "&",TokIdent "x",TokSymbol "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokSymbol "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ";",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "<",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVLBrace",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "closeBlocks",TokSymbol "::",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVLBrace,TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVRBrace",TokOperator ":",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "layoutTransform"
<< declBody: return DeclModule "Layout.LayoutTransform" (Just [ExportVar "layoutTransform"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "layoutTransform"
<< decl parser called
<< decl dispatch: TokIdent "layoutTransform"
<< funDecl: next token=TokIdent "layoutTransform"
<< funClause: next token=TokIdent "layoutTransform"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "layoutTransform"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: layoutTransform :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "layoutTransform"
<< decl parser called
<< decl dispatch: TokIdent "layoutTransform"
<< funDecl: next token=TokIdent "layoutTransform"
<< funClause: next token=TokIdent "layoutTransform"
<< patternParser: (pAs <|> makeCons)PApp (PVar "toks") []
<< funClause: args=[PApp (PVar "toks") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< declBody: return DeclFunGroup "layoutTransform" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EVar "go") (EVar "toks"))) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "go"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: go :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< patternParser: (pAs <|> makeCons)PApp (PList []) []
<< funClause: args=[PApp (PList []) []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])) []
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "go" [FunClause [PApp (PList []) []] Nothing (Just (EList [])) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])) []
<< funClause: args=[PApp (PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])) []] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "x"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "=="
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "go"
<< valueDecl: TokIdent "go"
<< pattern1: (pAs <|> makeCons)PApp (PVar "x") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "y") []
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PVar "go") [PCons (PApp (PConstr "TokVNewline" []) [PTuple [PApp (PVar "x") [],PApp (PVar "y") []]]) (PApp (PVar "rest") [])]
Just ([DeclModule "Layout.LayoutTransform" (Just [ExportVar "layoutTransform"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "layoutTransform" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "layoutTransform" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EVar "go") (EVar "toks"))) Nothing],DeclTypeSig "go" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "go" [FunClause [PApp (PList []) []] Nothing (Just (EList [])) Nothing]],[TokIdent "go",TokSymbol "(",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "x",TokSymbol "==",TokNumber 0,TokSymbol "&",TokSymbol "&",TokIdent "x",TokSymbol "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokSymbol "==",TokIdent "y",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ";",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator "<",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVLBrace",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "closeBlocks",TokSymbol "::",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokVLBrace,TokSymbol ";",TokSymbol "|",TokIdent "x",TokOperator ">",TokIdent "y",TokSymbol "=",TokTypeIdent "TokVRBrace",TokOperator ":",TokIdent "closeBlocks",TokSymbol "(",TokIdent "x",TokOperator "-",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/Lexer/LayoutLexer.hs ===
-- Raw Source --
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] 0 toks -- í«â¡: parenDepth = 0

go :: [Int] -> Int -> [Token] -> [Token]
go stack _ [] = []
-- ÉRÉÅÉìÉgçsÅiãÛîíÅ{ÉRÉÅÉìÉgÅ{â¸çsÅjÇãÛçsÇ∆Ç›Ç»Ç∑
go stack 0 (TokNewline : TokSpace n : TokNewline : rest)
  | n == head stack =
      TokVNewline (level, level) : TokVNewline (level, level) : go stack 0 rest
  where
    level = length stack - 1
-- ãÛçsÅiTokNewline ÇÃÇ†Ç∆Ç… TokNewline Ç‹ÇΩÇÕ EOFÅj
go stack 0 (TokNewline : TokNewline : rest) =
  go stack 0 (TokNewline : rest)
-- çsì™ÇÃÉXÉyÅ[ÉXÅiäáå äOÇÃÇ›èàóùÅj
go stack 0 (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack 0 rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' 0 rest
-- çsì™ÇÃâ¸çsÅiÉXÉyÅ[ÉXÇ»ÇµÅjÅ¶äáå äOÇÃÇ›èàóù
go stack 0 (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' 0 rest
-- äáå ì‡ÇÃ TokSpace Ç‚ TokNewline ÇÕÉXÉLÉbÉv
go stack depth (TokSpace _ : rest) =
  go stack depth rest
-- go stack depth (TokSpace _ : rest)
--  | depth > 0 = go stack depth rest
go stack depth (TokNewline : rest)
  | depth > 0 = go stack depth rest
-- äáå ÇÃÉlÉXÉgêßå‰
go stack depth (TokSymbol "(" : rest) =
  TokSymbol "(" : go stack (depth + 1) rest
go stack depth (TokSymbol ")" : rest) =
  TokSymbol ")" : go stack (max 0 (depth - 1)) rest
-- ÇªÇÃëºÇÃÉgÅ[ÉNÉì
go stack depth (t : rest) =
  t : go stack depth rest

{-}
module Lexer.LayoutLexer (layoutLexer) where

import Lexer.Token

layoutLexer :: [Token] -> [Token]
layoutLexer toks = go [0] toks

go :: [Int] -> [Token] -> [Token]
go stack [] = []
-- çsì™ÇÃÉXÉyÅ[ÉX
go stack (TokNewline : TokSpace n : rest)
  | n == head stack =
      let level = length stack - 1
       in TokVNewline (level, level) : go stack rest
  | n > head stack =
      let stack' = n : stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
  | n < head stack =
      let stack' = dropWhile (> n) stack
          prevLevel = length stack - 1
          newLevel = length stack' - 1
       in TokVNewline (prevLevel, newLevel) : go stack' rest
-- çsì™ÇÃâ¸çsÅiÉXÉyÅ[ÉXÇ»ÇµÅj
go stack (TokNewline : rest) =
  let stack' = [0]
      prevLevel = length stack - 1
   in TokVNewline (prevLevel, 0) : go stack' rest
-- çsì™à»äOÇÃÉXÉyÅ[ÉXÅiSimpleLexer Ç™èoÇ≥Ç»Ç¢Ç»ÇÁñ≥éãÇ≈OKÅj
go stack (TokSpace _ : rest) =
  go stack rest
-- ÇªÇÃëºÇÃÉgÅ[ÉNÉì
go stack (t : rest) =
  t : go stack rest
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokSymbol "(",TokIdent "layoutLexer",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "layoutLexer",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "layoutLexer",TokIdent "toks",TokSymbol "=",TokIdent "go",TokSymbol "[",TokNumber 0,TokSymbol "]",TokNumber 0,TokIdent "toks",TokNewline,TokIdent "go",TokSymbol "::",TokSymbol "[",TokTypeIdent "Int",TokSymbol "]",TokArrow,TokTypeIdent "Int",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "go",TokIdent "stack",TokSymbol "_",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokSymbol "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokSymbol "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVLBrace,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator ">",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "n",TokOperator ":",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator "<",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokSymbol "[",TokNumber 0,TokSymbol "]",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSpace",TokSymbol "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "depth",TokOperator ">",TokNumber 0,TokSymbol "=",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "layoutLexer"
<< declBody: return DeclModule "Lexer.LayoutLexer" (Just [ExportVar "layoutLexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "layoutLexer"
<< decl parser called
<< decl dispatch: TokIdent "layoutLexer"
<< funDecl: next token=TokIdent "layoutLexer"
<< funClause: next token=TokIdent "layoutLexer"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "layoutLexer"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parsed type signature: layoutLexer :: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< declBody: return DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< decl next token: TokIdent "layoutLexer"
<< decl parser called
<< decl dispatch: TokIdent "layoutLexer"
<< funDecl: next token=TokIdent "layoutLexer"
<< funClause: next token=TokIdent "layoutLexer"
<< patternParser: (pAs <|> makeCons)PApp (PVar "toks") []
<< funClause: args=[PApp (PVar "toks") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokSymbol "["
<< exprCore next token: TokNumber 0
<< atomBaseCore next token: TokNumber 0
<< atomBaseCore next token: TokSymbol "]"
<< atomBaseCore next token: TokNumber 0
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< declBody: return DeclFunGroup "layoutLexer" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EApp (EApp (EVar "go") (EList [EInt 0])) (EInt 0)) (EVar "toks"))) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "go"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TList (TCon "Token")) (TList (TCon "Token"))
<< parseTypeCore: TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))
<< parseTypeCore: TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))
<< parsed type signature: go :: TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))
<< returning DeclTypeSig: DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))))
<< declBody: return DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token")))))
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< patternParser: (pAs <|> makeCons)PApp (PVar "stack") [PWildcard,PList []]
<< funClause: args=[PApp (PVar "stack") [PWildcard,PList []]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereBlock: next tokenTokIdent "go"
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))
<< patternParser: (pAs <|> makeCons)PApp (PVar "stack") [PInt 0,PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))]
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "go" [FunClause [PApp (PVar "stack") [PWildcard,PList []]] Nothing (Just (EList [])) Nothing]
<< decl next token: TokIdent "go"
<< decl parser called
<< decl dispatch: TokIdent "go"
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))
<< patternParser: (pAs <|> makeCons)PApp (PVar "stack") [PInt 0,PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))]
<< funClause: args=[PApp (PVar "stack") [PInt 0,PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))]] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "n"
<< exprCore next token: TokIdent "n"
<< atomBaseCore next token: TokIdent "n"
<< atomBaseCore next token: TokSymbol "=="
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "go"
<< valueDecl: TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))
<< patternParser: (pAs <|> makeCons)PApp (PVar "go") [PVar "stack",PInt 0,PCons (PApp (PConstr "TokNewline" []) []) (PCons (PApp (PConstr "TokSpace" []) [PVar "n"]) (PCons (PApp (PConstr "TokNewline" []) []) (PApp (PVar "rest") [])))]
Just ([DeclModule "Lexer.LayoutLexer" (Just [ExportVar "layoutLexer"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "layoutLexer" (TFun (TList (TCon "Token")) (TList (TCon "Token"))),DeclFunGroup "layoutLexer" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EApp (EApp (EVar "go") (EList [EInt 0])) (EInt 0)) (EVar "toks"))) Nothing],DeclTypeSig "go" (TFun (TList (TCon "Int")) (TFun (TCon "Int") (TFun (TList (TCon "Token")) (TList (TCon "Token"))))),DeclFunGroup "go" [FunClause [PApp (PVar "stack") [PWildcard,PList []]] Nothing (Just (EList [])) Nothing]],[TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokSymbol "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokTypeIdent "TokSpace",TokIdent "n",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "n",TokSymbol "==",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "level",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVLBrace,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "level",TokSymbol ",",TokIdent "level",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator ">",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "n",TokOperator ":",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokSymbol "|",TokIdent "n",TokOperator "<",TokIdent "head",TokIdent "stack",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokOperator ">",TokIdent "n",TokSymbol ")",TokIdent "stack",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokSymbol ";",TokIdent "newLevel",TokSymbol "=",TokIdent "length",TokIdent "stack'",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokIdent "newLevel",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokNumber 0,TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "stack'",TokSymbol "=",TokSymbol "[",TokNumber 0,TokSymbol "]",TokVLBrace,TokIdent "prevLevel",TokSymbol "=",TokIdent "length",TokIdent "stack",TokOperator "-",TokNumber 1,TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "TokVNewline",TokSymbol "(",TokIdent "prevLevel",TokSymbol ",",TokNumber 0,TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "stack'",TokNumber 0,TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSpace",TokSymbol "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokNewline",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "depth",TokOperator ">",TokNumber 0,TokSymbol "=",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString "(",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "depth",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokString ")",TokOperator ":",TokIdent "go",TokIdent "stack",TokSymbol "(",TokIdent "max",TokNumber 0,TokSymbol "(",TokIdent "depth",TokOperator "-",TokNumber 1,TokSymbol ")",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "go",TokIdent "stack",TokIdent "depth",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "t",TokOperator ":",TokIdent "go",TokIdent "stack",TokIdent "depth",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/Lexer/Lexer.hs ===
-- Raw Source --
module Lexer.Lexer
  ( runLexer   -- Å© äOïîÇ…åˆäJÇ∑ÇÈä÷êî
  ) where

import Lexer.Token
import Lexer.SimpleLexer
import Lexer.LayoutLexer
import Layout.LayoutTransform

runLexer :: String -> [Token]
runLexer = layoutTransform . layoutLexer . slexer


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokVLBrace,TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokKeyword "where",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "LayoutLexer",TokNewline,TokKeyword "import",TokTypeIdent "Layout",TokDot,TokTypeIdent "LayoutTransform",TokNewline,TokIdent "runLexer",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "runLexer",TokSymbol "=",TokIdent "layoutTransform",TokDot,TokIdent "layoutLexer",TokDot,TokIdent "slexer",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "runLexer"
<< exportItem: next token=TokIdent "runLexer"
<< declBody: return DeclModule "Lexer.Lexer" (Just [ExportVar "runLexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.SimpleLexer", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.LayoutLexer", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Layout"
<< declBody: return DeclImport {importQualified = False, importModule = "Layout.LayoutTransform", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "runLexer"
<< decl parser called
<< decl dispatch: TokIdent "runLexer"
<< funDecl: next token=TokIdent "runLexer"
<< funClause: next token=TokIdent "runLexer"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "runLexer"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TCon "String") (TList (TCon "Token"))
<< parsed type signature: runLexer :: TFun (TCon "String") (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token")))
<< declBody: return DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token")))
<< decl next token: TokIdent "runLexer"
<< decl parser called
<< decl dispatch: TokIdent "runLexer"
<< funDecl: next token=TokIdent "runLexer"
<< funClause: next token=TokIdent "runLexer"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "layoutTransform"
<< expr dispatch: TokIdent "layoutTransform"
<< exprCore next token: TokIdent "layoutTransform"
<< atomBaseCore next token: TokIdent "layoutTransform"
<< atomBaseCore next token: TokDot
<< whereBlock: next tokenTokDot
<< funClauseWithName: next token=TokDot
<< declBody: return DeclFunGroup "runLexer" [FunClause [] Nothing (Just (EVar "layoutTransform")) Nothing]
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "Lexer.Lexer" (Just [ExportVar "runLexer"]),DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.SimpleLexer", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Lexer.LayoutLexer", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Layout.LayoutTransform", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "runLexer" (TFun (TCon "String") (TList (TCon "Token"))),DeclFunGroup "runLexer" [FunClause [] Nothing (Just (EVar "layoutTransform")) Nothing]],[TokDot,TokIdent "layoutLexer",TokDot,TokIdent "slexer",TokNewline])

=== Running: src/Lexer/SimpleLexer.hs ===
-- Raw Source --
module Lexer.SimpleLexer (slexer) where

import Data.Char
import Data.Char (isLetter)
import Lexer.Token

slexer :: String -> [Token]
slexer = go
  where
    go [] = []
    ------------------------------------------------------------
    -- â¸çs
    ------------------------------------------------------------
    go ('\n' : rest) =
      TokNewline : go rest
    ------------------------------------------------------------
    -- çsÉRÉÅÉìÉg "-- ..."
    ------------------------------------------------------------
    go ('-' : '-' : rest) =
      let rest' = dropWhile (/= '\n') rest
       in go rest'
    ------------------------------------------------------------
    -- ÉuÉçÉbÉNÉRÉÅÉìÉg "{- ... -}"
    ------------------------------------------------------------
    go ('{' : '-' : rest) =
      let rest' = skipBlockComment rest
       in go rest'
    ------------------------------------------------------------
    -- ãÛîíÅiÉXÉyÅ[ÉXÅj
    ------------------------------------------------------------
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    ------------------------------------------------------------
    -- ï∂éöÉäÉeÉâÉã
    ------------------------------------------------------------
    go ('\'' : rest) =
      case rest of
        ('\\' : c : '\'' : rest') ->
          TokChar (escapeChar c) : go rest'
        (c : '\'' : rest') ->
          TokChar c : go rest'
        _ ->
          TokUnknown '\'' : go rest
    ------------------------------------------------------------
    -- ï∂éöóÒÉäÉeÉâÉã
    ------------------------------------------------------------
    go ('"' : rest) =
      let (str, rest') = readString rest
       in TokString str : go rest'
    ------------------------------------------------------------
    -- êîéö
    ------------------------------------------------------------
    go ('-' : c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
    ------------------------------------------------------------
    -- éØï éq
    ------------------------------------------------------------
    go (c : rest)
      | isLetter c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
    ------------------------------------------------------------
    -- ï°êîï∂éöãLçÜ
    ------------------------------------------------------------
    go ('-' : '>' : rest) = TokArrow : go rest
    go ('=' : '>' : rest) = TokKeyword "=>" : go rest
    go ('+' : '+' : rest) = TokOperator "++" : go rest
    go (':' : ':' : rest) = TokSymbol "::" : go rest
    go (':' : rest) = TokOperator ":" : go rest
    go ('$' : rest) = TokOperator "$" : go rest
    go ('*' : '>' : rest) = TokOperator "*>" : go rest
    go ('<' : '*' : rest) = TokOperator "<*" : go rest
    go ('>' : '>' : rest) = TokOperator ">>" : go rest
    go ('<' : '|' : '>' : rest) = TokOperator "<|>" : go rest
    go ('<' : '$' : '>' : rest) = TokOperator "<$>" : go rest
    go ('>' : '>' : '=' : rest) = TokOperator ">>=" : go rest
    -- go ('+' : '+' : rest) = TokSymbol "++" : go rest
    go ('=' : '=' : rest) = TokSymbol "==" : go rest
    go ('(' : ')' : rest) = TokSymbol "()" : go rest
    -- go ('[' : ']' : rest) = TokSymbol "[]" : go rest
    go ('/' : '=' : rest) = TokSymbol "/=" : go rest
    go ('<' : '=' : rest) = TokSymbol "<=" : go rest
    go ('>' : '=' : rest) = TokSymbol ">=" : go rest
    go ('<' : '-' : rest) = TokSymbol "<-" : go rest
    go ('.' : '.' : '.' : rest) = TokEllipsis : go rest
    go ('.' : '.' : rest) = TokSymbol ".." : go rest
    go ('.' : rest) = TokDot : go rest
    go ('+' : rest) = TokOperator "+" : go rest
    go ('-' : rest) = TokOperator "-" : go rest
    go ('*' : rest) = TokOperator "*" : go rest
    go ('/' : rest) = TokOperator "/" : go rest
    -- go ('=' : rest) = TokOperator "=" : go rest
    go ('<' : rest) = TokOperator "<" : go rest
    go ('>' : rest) = TokOperator ">" : go rest
    ------------------------------------------------------------
    -- íPàÍãLçÜ
    ------------------------------------------------------------
    go (c : rest)
      | isSymbolChar c =
          TokSymbol [c] : go rest
    ------------------------------------------------------------
    -- ïsñæï∂éö
    ------------------------------------------------------------
    go (c : rest) =
      TokUnknown c : go rest

    ------------------------------------------------------------
    -- ï‚èïä÷êî
    ------------------------------------------------------------

    -- isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    isIdentChar c = isLetter c || isDigit c || c == '_' || c == '\'' || c == '`'

    -- isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&."
    isSymbolChar x = x `elem` "=(){}[]:;,\\'_|@&"

    classifyIdent "sql" = TokKeyword "sql"
    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "for" = TokKeyword "for"
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "import" = TokKeyword "import"
    classifyIdent "return" = TokKeyword "return"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "class" = TokKeyword "class"
    classifyIdent "type" = TokKeyword "type"
    classifyIdent "newtype" = TokKeyword "newtype"
    classifyIdent "instance" = TokKeyword "instance"
    classifyIdent "as" = TokKeyword "as"
    classifyIdent "qualified" = TokKeyword "qualified"
    classifyIdent "hiding" = TokKeyword "hiding"
    classifyIdent "deriving" = TokKeyword "deriving"
    classifyIdent "=>" = TokKeyword "=>"
    classifyIdent "->" = TokArrow
    -- classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name

    escapeChar 'n' = '\n'
    escapeChar 't' = '\t'
    escapeChar '\\' = '\\'
    escapeChar '\'' = '\''
    escapeChar c = c

    ------------------------------------------------------------
    -- ÉuÉçÉbÉNÉRÉÅÉìÉgÉXÉLÉbÉv
    ------------------------------------------------------------
    skipBlockComment :: String -> String
    skipBlockComment [] = []
    skipBlockComment ('-' : '}' : rest) = rest
    skipBlockComment (_ : rest) = skipBlockComment rest

    ------------------------------------------------------------
    -- ï∂éöóÒÉäÉeÉâÉãì«Ç›éÊÇË
    ------------------------------------------------------------
    readString :: String -> (String, String)
    readString [] = ("", [])
    readString ('"' : rest) = ("", rest)
    readString ('\\' : c : rest) =
      let (s, rest') = readString rest
       in (escapeChar c : s, rest')
    readString (c : rest) =
      let (s, rest') = readString rest
       in (c : s, rest')

{-}
module Lexer.SimpleLexer (runLexer) where

import Data.Char
import Lexer.Token (Token (..))

runLexer :: String -> [Token]
runLexer = go
  where
    go [] = []
    go ('\n' : rest) =
      TokNewline : go rest
    go (' ' : rest) =
      let (spaces, rest') = span (== ' ') rest
       in TokSpace (1 + length spaces) : go rest'
    go (c : rest)
      | isDigit c =
          let (digits, rest') = span isDigit rest
           in TokNumber (read (c : digits)) : go rest'
      | isAlpha c =
          let (letters, rest') = span isIdentChar rest
              name = c : letters
           in classifyIdent name : go rest'
      | isSymbolChar c =
          TokSymbol [c] : go rest
      | otherwise =
          TokUnknown c : go rest

    isIdentChar x = isAlphaNum x || x == '_' || x == '\''
    isSymbolChar x = x `elem` "=(){}[]:;,+-*/<>|&"

    classifyIdent "do" = TokKeyword "do"
    classifyIdent "let" = TokKeyword "let"
    classifyIdent "in" = TokKeyword "in"
    classifyIdent "case" = TokKeyword "case"
    classifyIdent "of" = TokKeyword "of"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "forall" = TokForall
    classifyIdent "if" = TokKeyword "if"
    classifyIdent "then" = TokKeyword "then"
    classifyIdent "else" = TokKeyword "else"
    classifyIdent "data" = TokKeyword "data"
    classifyIdent "where" = TokKeyword "where"
    classifyIdent "module" = TokKeyword "module"
    classifyIdent "->" = TokArrow
    classifyIdent "..." = TokEllipsis
    classifyIdent "." = TokDot
    classifyIdent "::" = TokSymbol "::"
    classifyIdent "<-" = TokSymbol "<-"
    classifyIdent "==" = TokOperator "=="
    classifyIdent "<=" = TokOperator "<="
    classifyIdent ">=" = TokOperator ">="
    classifyIdent "/=" = TokOperator "/="
    classifyIdent name
      | isUpper (head name) = TokTypeIdent name
      | otherwise = TokIdent name
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "SimpleLexer",TokSymbol "(",TokIdent "slexer",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isLetter",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokNewline,TokIdent "slexer",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "slexer",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\n',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokSymbol "/=",TokChar '\n',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '{',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ' ',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokSymbol "==",TokChar ' ',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokSpace",TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\'',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "(",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "TokUnknown",TokChar '\'',TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokString",TokIdent "str",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isLetter",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isIdentChar",TokIdent "rest",TokVLBrace,TokIdent "name",TokSymbol "=",TokIdent "c",TokOperator ":",TokIdent "letters",TokVRBrace,TokNewline,TokKeyword "in",TokIdent "classifyIdent",TokIdent "name",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokArrow",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "++",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ":",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '$',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "$",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '|',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<|>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '$',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<$>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "==",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '(',TokOperator ":",TokChar ')',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "()",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "/=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ">=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokEllipsis",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "..",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokDot",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "+",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isSymbolChar",TokIdent "c",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokSymbol "[",TokIdent "c",TokSymbol "]",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokUnknown",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "isIdentChar",TokIdent "c",TokSymbol "=",TokIdent "isLetter",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '_',TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '\'',TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '`',TokSymbol ";",TokSymbol ";",TokIdent "isSymbolChar",TokIdent "x",TokSymbol "=",TokIdent "x",TokUnknown '`',TokIdent "elem`",TokString "=(){}[]:;,\\'_|@&",TokSymbol ";",TokIdent "classifyIdent",TokString "sql",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokString "do",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokString "let",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokString "in",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokString "case",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokString "of",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokString "where",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokString "forall",TokSymbol "=",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokString "for",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokString "if",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokString "then",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokString "else",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokString "module",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokString "import",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokString "return",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokString "data",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokString "class",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokString "type",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokString "newtype",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokString "instance",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokString "as",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "as",TokSymbol ";",TokIdent "classifyIdent",TokString "qualified",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "qualified",TokSymbol ";",TokIdent "classifyIdent",TokString "hiding",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "hiding",TokSymbol ";",TokIdent "classifyIdent",TokString "deriving",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "deriving",TokSymbol ";",TokIdent "classifyIdent",TokString "=>",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokString "->",TokSymbol "=",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokString ".",TokSymbol "=",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokString "::",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokString "<-",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokString "==",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokString "<=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokString ">=",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokString "/=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokIdent "name",TokVLBrace,TokSymbol "|",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokTypeIdent",TokIdent "name",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokIdent",TokIdent "name",TokVRBrace,TokNewline,TokIdent "escapeChar",TokChar 'n',TokSymbol "=",TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokChar 't',TokSymbol "=",TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokChar '\\',TokSymbol "=",TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokChar '\'',TokSymbol "=",TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokIdent "c",TokSymbol "=",TokIdent "c",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '}',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokSymbol "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "readString",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "slexer"
<< declBody: return DeclModule "Lexer.SimpleLexer" (Just [ExportVar "slexer"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isLetter"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "slexer"
<< decl parser called
<< decl dispatch: TokIdent "slexer"
<< funDecl: next token=TokIdent "slexer"
<< funClause: next token=TokIdent "slexer"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "slexer"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TFun (TCon "String") (TList (TCon "Token"))
<< parsed type signature: slexer :: TFun (TCon "String") (TList (TCon "Token"))
<< returning DeclTypeSig: DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token")))
<< declBody: return DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token")))
<< decl next token: TokIdent "slexer"
<< decl parser called
<< decl dispatch: TokIdent "slexer"
<< funDecl: next token=TokIdent "slexer"
<< funClause: next token=TokIdent "slexer"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokKeyword "where"
<< whereBlock:2 next tokenTokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< patternParser: (pAs <|> makeCons)PApp (PList []) []
<< funClause: args=[PApp (PList []) []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokSymbol "["
<< expr dispatch: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< whereBlock: next tokenTokSymbol ";"
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\n') []) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\n') []) (PApp (PVar "rest") [])) []
<< expr dispatch: TokTypeIdent "TokNewline"
<< exprCore next token: TokTypeIdent "TokNewline"
<< atomBaseCore next token: TokTypeIdent "TokNewline"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '-') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '-') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))) []
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokIdent "rest'"
<< valueBinding next token: TokIdent "rest'"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< expr dispatch: TokIdent "dropWhile"
<< exprCore next token: TokIdent "dropWhile"
<< atomBaseCore next token: TokIdent "dropWhile"
<< exprCore next token: TokChar '\n'
<< atomBaseCore next token: TokChar '\n'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '{') []) (PCons (PApp (PChar '-') []) (PApp (PVar "rest") []))) []
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokIdent "rest'"
<< valueBinding next token: TokIdent "rest'"
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< expr dispatch: TokIdent "skipBlockComment"
<< exprCore next token: TokIdent "skipBlockComment"
<< atomBaseCore next token: TokIdent "skipBlockComment"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar ' ') []) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar ' ') []) (PApp (PVar "rest") [])) []
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "spaces") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest'") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "spaces") [],PApp (PVar "rest'") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar ' '
<< atomBaseCore next token: TokChar ' '
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokTypeIdent "TokSpace"
<< exprCore next token: TokTypeIdent "TokSpace"
<< atomBaseCore next token: TokTypeIdent "TokSpace"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< atomBaseCore next token: TokOperator "+"
<< atomBaseCore next token: TokIdent "length"
<< atomBaseCore next token: TokIdent "spaces"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokOperator ":"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "rest'"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])) []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "rest"
<< exprCore next token: TokIdent "rest"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])) []
<< funClause: args=[PApp (PCons (PApp (PChar '\'') []) (PApp (PVar "rest") [])) []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "rest"
<< exprCore next token: TokIdent "rest"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PChar '\\') []) (PCons (PApp (PVar "c") []) (PCons (PApp (PChar '\'') []) (PApp (PVar "rest'") [])))) []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "slexer" [FunClause [] Nothing (Just (EVar "go")) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Lexer.SimpleLexer" (Just [ExportVar "slexer"]),DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isLetter"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "slexer" (TFun (TCon "String") (TList (TCon "Token"))),DeclFunGroup "slexer" [FunClause [] Nothing (Just (EVar "go")) Nothing]],[TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\n',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokNewline",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "dropWhile",TokSymbol "(",TokSymbol "/=",TokChar '\n',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '{',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "rest'",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokVLBrace,TokKeyword "in",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ' ',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "spaces",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokSymbol "==",TokChar ' ',TokSymbol ")",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokSpace",TokSymbol "(",TokNumber 1,TokOperator "+",TokIdent "length",TokIdent "spaces",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '\'',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "(",TokIdent "c",TokOperator ":",TokChar '\'',TokOperator ":",TokIdent "rest'",TokSymbol ")",TokArrow,TokVLBrace,TokTypeIdent "TokChar",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "TokUnknown",TokChar '\'',TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "str",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokString",TokIdent "str",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "digits",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isDigit",TokIdent "rest",TokVLBrace,TokKeyword "in",TokTypeIdent "TokNumber",TokSymbol "(",TokIdent "read",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "digits",TokSymbol ")",TokSymbol ")",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isLetter",TokIdent "c",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "letters",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "span",TokIdent "isIdentChar",TokIdent "rest",TokVLBrace,TokIdent "name",TokSymbol "=",TokIdent "c",TokOperator ":",TokIdent "letters",TokVRBrace,TokNewline,TokKeyword "in",TokIdent "classifyIdent",TokIdent "name",TokOperator ":",TokIdent "go",TokIdent "rest'",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokArrow",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "++",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar ':',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ":",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '$',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "$",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '|',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<|>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '$',TokOperator ":",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<$>",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">>=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '=',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "==",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '(',TokOperator ":",TokChar ')',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "()",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "/=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokChar '=',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString ">=",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokEllipsis",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "..",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '.',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokDot",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '+',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "+",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '-',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "-",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '*',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "*",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '/',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '<',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokIdent "go",TokSymbol "(",TokChar '>',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">",TokOperator ":",TokIdent "go",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "isSymbolChar",TokIdent "c",TokSymbol "=",TokVLBrace,TokTypeIdent "TokSymbol",TokSymbol "[",TokIdent "c",TokSymbol "]",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "go",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TokUnknown",TokIdent "c",TokOperator ":",TokIdent "go",TokIdent "rest",TokVRBrace,TokNewline,TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "isIdentChar",TokIdent "c",TokSymbol "=",TokIdent "isLetter",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "isDigit",TokIdent "c",TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '_',TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '\'',TokSymbol "|",TokSymbol "|",TokIdent "c",TokSymbol "==",TokChar '`',TokSymbol ";",TokSymbol ";",TokIdent "isSymbolChar",TokIdent "x",TokSymbol "=",TokIdent "x",TokUnknown '`',TokIdent "elem`",TokString "=(){}[]:;,\\'_|@&",TokSymbol ";",TokIdent "classifyIdent",TokString "sql",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "sql",TokSymbol ";",TokIdent "classifyIdent",TokString "do",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "do",TokSymbol ";",TokIdent "classifyIdent",TokString "let",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "let",TokSymbol ";",TokIdent "classifyIdent",TokString "in",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "in",TokSymbol ";",TokIdent "classifyIdent",TokString "case",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "case",TokSymbol ";",TokIdent "classifyIdent",TokString "of",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "of",TokSymbol ";",TokIdent "classifyIdent",TokString "where",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "where",TokSymbol ";",TokIdent "classifyIdent",TokString "forall",TokSymbol "=",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "classifyIdent",TokString "for",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "for",TokSymbol ";",TokIdent "classifyIdent",TokString "if",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "if",TokSymbol ";",TokIdent "classifyIdent",TokString "then",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "then",TokSymbol ";",TokIdent "classifyIdent",TokString "else",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "else",TokSymbol ";",TokIdent "classifyIdent",TokString "module",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "module",TokSymbol ";",TokIdent "classifyIdent",TokString "import",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "import",TokSymbol ";",TokIdent "classifyIdent",TokString "return",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "return",TokSymbol ";",TokIdent "classifyIdent",TokString "data",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "data",TokSymbol ";",TokIdent "classifyIdent",TokString "class",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "class",TokSymbol ";",TokIdent "classifyIdent",TokString "type",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "type",TokSymbol ";",TokIdent "classifyIdent",TokString "newtype",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "newtype",TokSymbol ";",TokIdent "classifyIdent",TokString "instance",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "instance",TokSymbol ";",TokIdent "classifyIdent",TokString "as",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "as",TokSymbol ";",TokIdent "classifyIdent",TokString "qualified",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "qualified",TokSymbol ";",TokIdent "classifyIdent",TokString "hiding",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "hiding",TokSymbol ";",TokIdent "classifyIdent",TokString "deriving",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "deriving",TokSymbol ";",TokIdent "classifyIdent",TokString "=>",TokSymbol "=",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ";",TokIdent "classifyIdent",TokString "->",TokSymbol "=",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol ";",TokIdent "classifyIdent",TokString ".",TokSymbol "=",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "classifyIdent",TokString "::",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "::",TokSymbol ";",TokIdent "classifyIdent",TokString "<-",TokSymbol "=",TokTypeIdent "TokSymbol",TokString "<-",TokSymbol ";",TokIdent "classifyIdent",TokString "==",TokSymbol "=",TokTypeIdent "TokOperator",TokString "==",TokSymbol ";",TokIdent "classifyIdent",TokString "<=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "<=",TokSymbol ";",TokIdent "classifyIdent",TokString ">=",TokSymbol "=",TokTypeIdent "TokOperator",TokString ">=",TokSymbol ";",TokIdent "classifyIdent",TokString "/=",TokSymbol "=",TokTypeIdent "TokOperator",TokString "/=",TokSymbol ";",TokIdent "classifyIdent",TokIdent "name",TokVLBrace,TokSymbol "|",TokIdent "isUpper",TokSymbol "(",TokIdent "head",TokIdent "name",TokSymbol ")",TokSymbol "=",TokTypeIdent "TokTypeIdent",TokIdent "name",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "TokIdent",TokIdent "name",TokVRBrace,TokNewline,TokIdent "escapeChar",TokChar 'n',TokSymbol "=",TokChar '\n',TokSymbol ";",TokIdent "escapeChar",TokChar 't',TokSymbol "=",TokChar '\t',TokSymbol ";",TokIdent "escapeChar",TokChar '\\',TokSymbol "=",TokChar '\\',TokSymbol ";",TokIdent "escapeChar",TokChar '\'',TokSymbol "=",TokChar '\'',TokSymbol ";",TokIdent "escapeChar",TokIdent "c",TokSymbol "=",TokIdent "c",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "String",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokChar '-',TokOperator ":",TokChar '}',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "rest",TokSymbol ";",TokIdent "skipBlockComment",TokSymbol "(",TokSymbol "_",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "skipBlockComment",TokIdent "rest",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "readString",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "String",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '"',TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokString "",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokIdent "readString",TokSymbol "(",TokChar '\\',TokOperator ":",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "escapeChar",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "readString",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokSymbol "=",TokIdent "readString",TokIdent "rest",TokVLBrace,TokKeyword "in",TokSymbol "(",TokIdent "c",TokOperator ":",TokIdent "s",TokSymbol ",",TokIdent "rest'",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Lexer/Token.hs ===
-- Raw Source --
{-# LANGUAGE OverloadedStrings #-}

module Lexer.Token
  ( Token (..),
  )
where

{-}
import Control.Applicative
import Data.Char (isUpper)
import Data.Void
-- import Text.Megaparsec.Char (oneOf)
import Text.Megaparsec (ParseErrorBundle, Parsec, choice, eof, manyTill, oneOf, parse, satisfy, try, (<|>))
import Text.Megaparsec.Char (alphaNumChar, char, letterChar, space1, string)
import qualified Text.Megaparsec.Char.Lexer as L
-}

-- Parser type
-- type Parser = Parsec Void String

-- Token definition
data Token
  = TokKeyword String
  | TokIdent String
  | TokTypeIdent String
  | TokNumber Int
  | TokFloat Double
  | TokString String
  | TokSymbol String
  | TokOperator String
  | TokChar Char
  | TokForall
  | TokDot
  | TokEllipsis
  | TokArrow
  | TokLParen
  | TokRParen
  | TokNewline
  | TokInt Int
  | TokSpace Int
  | TokIndent
  | TokVLBrace
  | TokVRBrace
  | TokVSemicolon
  | TokVNewline (Int, Int)
  | TokUnknown Char
  deriving (Show, Eq, Ord)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokVLBrace,TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Token",TokVLBrace,TokSymbol "=",TokTypeIdent "TokKeyword",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokIdent",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokTypeIdent",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokNumber",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokFloat",TokTypeIdent "Double",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokString",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokSymbol",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokOperator",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokChar",TokTypeIdent "Char",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokForall",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokDot",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokEllipsis",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokArrow",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokLParen",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokRParen",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokNewline",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokInt",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokSpace",TokTypeIdent "Int",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokIndent",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVLBrace",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVRBrace",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVSemicolon",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokVNewline",TokSymbol "(",TokTypeIdent "Int",TokSymbol ",",TokTypeIdent "Int",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokTypeIdent "TokUnknown",TokTypeIdent "Char",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Ord",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Token"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Lexer.Token" (Just [ExportType "Token" True])
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "TokKeyword"
<< constrS: next token TokTypeIdent "TokKeyword"
<< dataConstr: next token TokTypeIdent "TokKeyword"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "TokKeyword" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Int"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Double"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Char"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Int"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Int"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "("
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Int"
<< parseTypeCore: TCon "Int"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Char"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "TokKeyword" [TCon "String"],Constraint "TokIdent" [TCon "String"],Constraint "TokTypeIdent" [TCon "String"],Constraint "TokNumber" [TCon "Int"],Constraint "TokFloat" [TCon "Double"],Constraint "TokString" [TCon "String"],Constraint "TokSymbol" [TCon "String"],Constraint "TokOperator" [TCon "String"],Constraint "TokChar" [TCon "Char"],Constraint "TokForall" [],Constraint "TokDot" [],Constraint "TokEllipsis" [],Constraint "TokArrow" [],Constraint "TokLParen" [],Constraint "TokRParen" [],Constraint "TokNewline" [],Constraint "TokInt" [TCon "Int"],Constraint "TokSpace" [TCon "Int"],Constraint "TokIndent" [],Constraint "TokVLBrace" [],Constraint "TokVRBrace" [],Constraint "TokVSemicolon" [],Constraint "TokVNewline" [TTuple [TCon "Int",TCon "Int"]],Constraint "TokUnknown" [TCon "Char"]]
<< dataDecl:4 next token ["Show","Eq","Ord"]
<< declBody: return DeclData "Token" [] [Constraint "TokKeyword" [TCon "String"],Constraint "TokIdent" [TCon "String"],Constraint "TokTypeIdent" [TCon "String"],Constraint "TokNumber" [TCon "Int"],Constraint "TokFloat" [TCon "Double"],Constraint "TokString" [TCon "String"],Constraint "TokSymbol" [TCon "String"],Constraint "TokOperator" [TCon "String"],Constraint "TokChar" [TCon "Char"],Constraint "TokForall" [],Constraint "TokDot" [],Constraint "TokEllipsis" [],Constraint "TokArrow" [],Constraint "TokLParen" [],Constraint "TokRParen" [],Constraint "TokNewline" [],Constraint "TokInt" [TCon "Int"],Constraint "TokSpace" [TCon "Int"],Constraint "TokIndent" [],Constraint "TokVLBrace" [],Constraint "TokVRBrace" [],Constraint "TokVSemicolon" [],Constraint "TokVNewline" [TTuple [TCon "Int",TCon "Int"]],Constraint "TokUnknown" [TCon "Char"]] ["Show","Eq","Ord"]
Just ([DeclModule "Lexer.Token" (Just [ExportType "Token" True]),DeclData "Token" [] [Constraint "TokKeyword" [TCon "String"],Constraint "TokIdent" [TCon "String"],Constraint "TokTypeIdent" [TCon "String"],Constraint "TokNumber" [TCon "Int"],Constraint "TokFloat" [TCon "Double"],Constraint "TokString" [TCon "String"],Constraint "TokSymbol" [TCon "String"],Constraint "TokOperator" [TCon "String"],Constraint "TokChar" [TCon "Char"],Constraint "TokForall" [],Constraint "TokDot" [],Constraint "TokEllipsis" [],Constraint "TokArrow" [],Constraint "TokLParen" [],Constraint "TokRParen" [],Constraint "TokNewline" [],Constraint "TokInt" [TCon "Int"],Constraint "TokSpace" [TCon "Int"],Constraint "TokIndent" [],Constraint "TokVLBrace" [],Constraint "TokVRBrace" [],Constraint "TokVSemicolon" [],Constraint "TokVNewline" [TTuple [TCon "Int",TCon "Int"]],Constraint "TokUnknown" [TCon "Char"]] ["Show","Eq","Ord"]],[TokNewline])

=== Running: src/main.hs ===
-- Raw Source --
module Main where

-- import Parser.Core.Parser (runParser)

-- (runLexer)
-- import Layout.LayoutTransform --
-- import Lexer.LayoutLexer

import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified Data.Text.IO as TIO
import Decl.DeclParserCore (program)
import Lexer.Lexer (runLexer)
import Lexer.Token (Token)
import Parser.Core.Combinator (Parser (..), runParser, try)
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO
import System.IO (readFile)
import Utils.MyTrace (setTrace)

main :: IO ()
main = do
  args <- getArgs
  case args of
    [file] -> processFile file
    _ -> putStrLn "Usage: myparser <filename>"

processFile :: FilePath -> IO ()
processFile file = do
  handle <- openFile file ReadMode
  hSetEncoding handle utf8 -- Åö Ç±Ç±Ç≈ÉGÉìÉRÅ[ÉfÉBÉìÉOÇñæé¶ÅI
  src <- TIO.hGetContents handle
  -- src <- T.readFile file

  putStrLn "-- Raw Source --"
  putStrLn (T.unpack src)

  let toks3 = runLexer (T.unpack src)
  putStrLn "\n-- Tokens from Lexer --"
  print toks3
  {-}
    let toks2 = layoutLexer toks1
    putStrLn "\n-- Tokens from LayoutLexer --"
    print toks2

    let toks3 = layoutTransform toks2
    putStrLn "\n-- Tokens after LayoutTransform --"
    print toks3
  -}
  putStrLn "\n-- Parsing --"
  let ast = runParser program toks3
  putStrLn "\n-- Parsed AST --"
  print ast


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Main",TokKeyword "where",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokKeyword "as",TokTypeIdent "T",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokKeyword "as",TokTypeIdent "T",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Text",TokDot,TokTypeIdent "IO",TokKeyword "as",TokTypeIdent "TIO",TokNewline,TokKeyword "import",TokTypeIdent "Decl",TokDot,TokTypeIdent "DeclParserCore",TokSymbol "(",TokIdent "program",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "try",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "Environment",TokSymbol "(",TokIdent "getArgs",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "Exit",TokSymbol "(",TokIdent "exitFailure",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokSymbol "(",TokIdent "readFile",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "setTrace",TokSymbol ")",TokNewline,TokIdent "main",TokSymbol "::",TokTypeIdent "IO",TokSymbol "()",TokNewline,TokIdent "main",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "args",TokSymbol "<-",TokIdent "getArgs",TokSymbol ";",TokKeyword "case",TokIdent "args",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "file",TokSymbol "]",TokArrow,TokIdent "processFile",TokIdent "file",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "putStrLn",TokString "Usage: myparser <filename>",TokVRBrace,TokVRBrace,TokNewline,TokIdent "processFile",TokSymbol "::",TokTypeIdent "FilePath",TokArrow,TokTypeIdent "IO",TokSymbol "()",TokNewline,TokIdent "processFile",TokIdent "file",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "handle",TokSymbol "<-",TokIdent "openFile",TokIdent "file",TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokIdent "handle",TokIdent "utf8",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokIdent "handle",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "toks3",TokSymbol "=",TokIdent "runLexer",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokIdent "ast",TokSymbol "=",TokIdent "runParser",TokIdent "program",TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokIdent "ast",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "Main" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text", importAlias = Just "T", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "T", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "TIO", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Decl"
<< declBody: return DeclImport {importQualified = False, importModule = "Decl.DeclParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "program"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser",ImportVar "runParser",ImportVar "try"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.Environment", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "getArgs"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.Exit", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exitFailure"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "readFile"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "setTrace"]}
<< decl next token: TokIdent "main"
<< decl parser called
<< decl dispatch: TokIdent "main"
<< funDecl: next token=TokIdent "main"
<< funClause: next token=TokIdent "main"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "main"
<< parseType dispatch: TokTypeIdent "IO"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parsed type signature: main :: TApp (TCon "IO") TUnit
<< returning DeclTypeSig: DeclTypeSig "main" (TApp (TCon "IO") TUnit)
<< declBody: return DeclTypeSig "main" (TApp (TCon "IO") TUnit)
<< decl next token: TokIdent "main"
<< decl parser called
<< decl dispatch: TokIdent "main"
<< funDecl: next token=TokIdent "main"
<< funClause: next token=TokIdent "main"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "args"
<< pattern1: (pAs <|> makeCons)PApp (PVar "args") []
<< expr dispatch: TokIdent "getArgs"
<< exprCore next token: TokIdent "getArgs"
<< atomBaseCore next token: TokIdent "getArgs"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "args"
<< exprCore next token: TokIdent "args"
<< atomBaseCore next token: TokIdent "args"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PVar "file") []
<< pattern1: (pAs <|> makeCons)PApp (PList [PApp (PVar "file") []]) []
<< expr dispatch: TokIdent "processFile"
<< exprCore next token: TokIdent "processFile"
<< atomBaseCore next token: TokIdent "processFile"
<< atomBaseCore next token: TokIdent "file"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokIdent "putStrLn"
<< exprCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokIdent "putStrLn"
<< atomBaseCore next token: TokString "Usage: myparser <filename>"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "processFile"
<< funClauseWithName: next token=TokIdent "processFile"
<< declBody: return DeclFunGroup "main" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "args") []) (EVar "getArgs"),ExprStmt (ECase (EVar "args") [CaseAlt (PApp (PList [PApp (PVar "file") []]) []) (EApp (EVar "processFile") (EVar "file")),CaseAlt (PApp PWildcard []) (EApp (EVar "putStrLn") (EString "Usage: myparser <filename>"))])])) Nothing]
<< decl next token: TokIdent "processFile"
<< decl parser called
<< decl dispatch: TokIdent "processFile"
<< funDecl: next token=TokIdent "processFile"
<< funClause: next token=TokIdent "processFile"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "processFile"
<< parseType dispatch: TokTypeIdent "FilePath"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parseTypeCore: TFun (TCon "FilePath") (TApp (TCon "IO") TUnit)
<< parsed type signature: processFile :: TFun (TCon "FilePath") (TApp (TCon "IO") TUnit)
<< returning DeclTypeSig: DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit))
<< declBody: return DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit))
<< decl next token: TokIdent "processFile"
<< decl parser called
<< decl dispatch: TokIdent "processFile"
<< funDecl: next token=TokIdent "processFile"
<< funClause: next token=TokIdent "processFile"
<< patternParser: (pAs <|> makeCons)PApp (PVar "file") []
<< funClause: args=[PApp (PVar "file") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "handle"
<< pattern1: (pAs <|> makeCons)PApp (PVar "handle") []
<< expr dispatch: TokIdent "openFile"
<< exprCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "openFile"
<< atomBaseCore next token: TokIdent "file"
<< atomBaseCore next token: TokTypeIdent "ReadMode"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "hSetEncoding"
<< pattern1: (pAs <|> makeCons)PApp (PVar "hSetEncoding") [PVar "handle",PVar "utf8"]
<< expr dispatch: TokIdent "hSetEncoding"
<< exprCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "hSetEncoding"
<< atomBaseCore next token: TokIdent "handle"
<< atomBaseCore next token: TokIdent "utf8"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "src"
<< pattern1: (pAs <|> makeCons)PApp (PVar "src") []
<< expr dispatch: TokTypeIdent "TIO"
<< exprCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokTypeIdent "TIO"
<< atomBaseCore next token: TokDot
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "handle"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "processFile" [FunClause [PApp (PVar "file") []] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Main" Nothing,DeclImport {importQualified = True, importModule = "Data.Text", importAlias = Just "T", importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "T", importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Text.IO", importAlias = Just "TIO", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Decl.DeclParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "program"]},DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser",ImportVar "runParser",ImportVar "try"]},DeclImport {importQualified = False, importModule = "System.Environment", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "getArgs"]},DeclImport {importQualified = False, importModule = "System.Exit", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exitFailure"]},DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "System.IO", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "readFile"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "setTrace"]},DeclTypeSig "main" (TApp (TCon "IO") TUnit),DeclFunGroup "main" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "args") []) (EVar "getArgs"),ExprStmt (ECase (EVar "args") [CaseAlt (PApp (PList [PApp (PVar "file") []]) []) (EApp (EVar "processFile") (EVar "file")),CaseAlt (PApp PWildcard []) (EApp (EVar "putStrLn") (EString "Usage: myparser <filename>"))])])) Nothing],DeclTypeSig "processFile" (TFun (TCon "FilePath") (TApp (TCon "IO") TUnit)),DeclFunGroup "processFile" [FunClause [PApp (PVar "file") []] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "handle",TokSymbol "<-",TokIdent "openFile",TokIdent "file",TokTypeIdent "ReadMode",TokSymbol ";",TokIdent "hSetEncoding",TokIdent "handle",TokIdent "utf8",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokTypeIdent "TIO",TokDot,TokIdent "hGetContents",TokIdent "handle",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "-- Raw Source --",TokSymbol ";",TokIdent "putStrLn",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "toks3",TokSymbol "=",TokIdent "runLexer",TokSymbol "(",TokTypeIdent "T",TokDot,TokIdent "unpack",TokIdent "src",TokSymbol ")",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Tokens from Lexer --",TokSymbol ";",TokIdent "print",TokIdent "toks3",TokSymbol ";",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsing --",TokSymbol ";",TokKeyword "let",TokIdent "ast",TokSymbol "=",TokIdent "runParser",TokIdent "program",TokIdent "toks3",TokSymbol ";",TokIdent "putStrLn",TokString "\n-- Parsed AST --",TokSymbol ";",TokIdent "print",TokIdent "ast",TokVRBrace,TokNewline])

=== Running: src/Parser/Core/Combinator.hs ===
-- Raw Source --
{-# LANGUAGE InstanceSigs #-}

module Parser.Core.Combinator
  ( Parser (..),
    runParser,
    satisfy,
    satisfyMap,
    token,
    tokens,
    between,
    sepBy,
    sepBy1,
    sepEndBy,
    sepEndBy1,
    try,
    chainl1,
    many1,
    manyTill,
    choice,
    choice1,
    lookAhead,
    option,
    skipMany,
    skipMany1
  )
where

import Control.Applicative (Alternative (..), many)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))

-- import app.MyTrace (myTrace)

-- ç∑ï™ÉäÉXÉgïóÉpÅ[ÉTÅ[
newtype Parser a = Parser {runParser :: [Token] -> Maybe (a, [Token])}

instance Functor Parser where
  fmap :: (a -> b) -> Parser a -> Parser b
  fmap f p = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> Just (f a, rest)
      Nothing -> Nothing

instance Applicative Parser where
  pure :: a -> Parser a
  pure a = Parser $ \input -> Just (a, input)
  (<*>) :: Parser (a -> b) -> Parser a -> Parser b
  pf <*> pa = Parser $ \input ->
    case runParser pf input of
      Just (f, rest1) ->
        case runParser pa rest1 of
          Just (a, rest2) -> Just (f a, rest2)
          Nothing -> Nothing
      Nothing -> Nothing

instance Monad Parser where
  (>>=) :: Parser a -> (a -> Parser b) -> Parser b
  p >>= f = Parser $ \input ->
    case runParser p input of
      Just (a, rest) -> runParser (f a) rest
      Nothing -> Nothing

instance Alternative Parser where
  empty :: Parser a
  empty = Parser $ const Nothing
  (<|>) :: Parser a -> Parser a -> Parser a
  p1 <|> p2 = Parser $ \input ->
    runParser p1 input <|> runParser p2 input

-- ï‚èïä÷êî
satisfy :: (Token -> Bool) -> Parser Token
satisfy f = Parser $ \tokens -> case tokens of
  (t : ts) | f t -> Just (t, ts)
  _ -> Nothing

satisfyMap :: (Token -> Maybe a) -> Parser a
satisfyMap f = Parser $ \tokens -> case tokens of
  (t : ts) -> case f t of
    Just x -> Just (x, ts)
    Nothing -> Nothing
  [] -> Nothing

token :: Token -> Parser Token
token t = satisfy (== t)

tokens :: [Token] -> Parser [Token]
tokens expected = Parser $ \input ->
  if expected `isPrefixOf` input
    then Just (expected, drop (length expected) input)
    else Nothing

between :: Parser open -> Parser close -> Parser a -> Parser a
between open close p = do
  _ <- open
  x <- p
  _ <- close
  return x

sepBy :: Parser a -> Parser sep -> Parser [a]
sepBy p sep =
  ( do
      x <- p
      xs <- many (sep *> p)
      return (x : xs)
  )
    <|> pure []

sepBy1 :: Parser a -> Parser sep -> Parser [a]
sepBy1 p sep = do
  first <- p
  rest <- (sep *> sepBy1 p sep) <|> pure []
  return (first : rest)

sepEndBy1 :: Parser a -> Parser sep -> Parser [a]
sepEndBy1 p sep = do
  x <- p
  ( do
      _ <- sep
      xs <- sepEndBy p sep
      return (x : xs)
    )
    <|> pure [x]

sepEndBy :: Parser a -> Parser sep -> Parser [a]
sepEndBy p sep = sepEndBy1 p sep <|> pure []

try :: Parser a -> Parser a
try p = Parser $ \tokens -> runParser p tokens

chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
chainl1 p op = do
  x <- p
  rest x
  where
    rest x =
      ( do
          f <- op
          y <- p
          rest (f x y)
      )
        <|> return x

many1 :: Parser a -> Parser [a]
many1 p = (:) <$> p <*> many p

manyTill :: Parser a -> Parser end -> Parser [a]
manyTill p end = go
  where
    go =
      end
        *> pure []
          <|> (:)
        <$> p
        <*> go

choice1 :: Parser a -> Parser a -> Parser a
choice1 p q = Parser $ \input ->
  case runParser p input of
    Just r -> Just r
    Nothing -> runParser q input

choice :: [Parser a] -> Parser a
choice [] = Parser $ \_ -> Nothing
choice (p : ps) = choice1 p (choice ps)

option :: a -> Parser a -> Parser a
option x p = p <|> pure x

{-}
lookAhead :: Parser a -> Parser a
lookAhead p = Parser $ \input ->
  case runParser p input of
    Just (a, _) -> Just (a, input) -- ê¨å˜ÇµÇƒÇ‡ input Çè¡îÔÇµÇ»Ç¢
    Nothing -> Nothing
-}

lookAhead :: Parser a -> Parser a
lookAhead (Parser p) = Parser $ \input ->
  case p input of
    Just (a, _) -> Just (a, input) -- åãâ ÇÕÇªÇÃÇ‹Ç‹ÅAì¸óÕÇÕè¡îÔÇµÇ»Ç¢
    Nothing -> Nothing


skipMany1 :: Parser a -> Parser ()
skipMany1 p = p *> skipMany p

skipMany :: Parser a -> Parser ()
skipMany p = Parser $ \ts ->
  case runParser p ts of
    Just (_, ts') -> runParser (skipMany p) ts'
    Nothing -> Just ((), ts)

-- àÀë∂ÅFsymbol ÇÕ TokenParser ë§Ç≈íËã`Ç≥ÇÍÇÈÇΩÇﬂÅAÇ±Ç±Ç≈ÇÕíËã`ÇµÇ»Ç¢


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokVLBrace,TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "runParser",TokSymbol ",",TokIdent "satisfy",TokSymbol ",",TokIdent "satisfyMap",TokSymbol ",",TokIdent "token",TokSymbol ",",TokIdent "tokens",TokSymbol ",",TokIdent "between",TokSymbol ",",TokIdent "sepBy",TokSymbol ",",TokIdent "sepBy1",TokSymbol ",",TokIdent "sepEndBy",TokSymbol ",",TokIdent "sepEndBy1",TokSymbol ",",TokIdent "try",TokSymbol ",",TokIdent "chainl1",TokSymbol ",",TokIdent "many1",TokSymbol ",",TokIdent "manyTill",TokSymbol ",",TokIdent "choice",TokSymbol ",",TokIdent "choice1",TokSymbol ",",TokIdent "lookAhead",TokSymbol ",",TokIdent "option",TokSymbol ",",TokIdent "skipMany",TokSymbol ",",TokIdent "skipMany1",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokTypeIdent "Alternative",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "many",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "newtype",TokTypeIdent "Parser",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokSymbol "{",TokIdent "runParser",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "instance",TokTypeIdent "Functor",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "fmap",TokSymbol "::",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "fmap",TokIdent "f",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Applicative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "pure",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "pure",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<*",TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "pf",TokOperator "<*",TokOperator ">",TokIdent "pa",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pf",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pa",TokIdent "rest1",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Monad",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokSymbol "(",TokOperator ">>",TokSymbol "=",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "p",TokOperator ">>",TokSymbol "=",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Alternative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "empty",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "empty",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokIdent "const",TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "p1",TokOperator "<|>",TokIdent "p2",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokIdent "runParser",TokIdent "p1",TokIdent "input",TokOperator "<|>",TokIdent "runParser",TokIdent "p2",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfy",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "|",TokIdent "f",TokIdent "t",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "satisfyMap",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyMap",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "token",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "token",TokIdent "t",TokSymbol "=",TokIdent "satisfy",TokSymbol "(",TokSymbol "==",TokIdent "t",TokSymbol ")",TokNewline,TokIdent "tokens",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokIdent "expected",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "expected",TokUnknown '`',TokIdent "isPrefixOf`",TokIdent "input",TokVLBrace,TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "between",TokSymbol "::",TokTypeIdent "Parser",TokIdent "open",TokArrow,TokTypeIdent "Parser",TokIdent "close",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "between",TokIdent "open",TokIdent "close",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "open",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "_",TokSymbol "<-",TokIdent "close",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "sepBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "first",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "first",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "sepEndBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokSymbol "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokIdent "x",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepEndBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "try",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "try",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokIdent "runParser",TokIdent "p",TokIdent "tokens",TokNewline,TokIdent "chainl1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "chainl1",TokIdent "p",TokIdent "op",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokIdent "x",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "x",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "x",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "many1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokIdent "p",TokSymbol "=",TokSymbol "(",TokOperator ":",TokSymbol ")",TokOperator "<$>",TokIdent "p",TokOperator "<*",TokOperator ">",TokIdent "many",TokIdent "p",TokNewline,TokIdent "manyTill",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "end",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokIdent "p",TokIdent "end",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "=",TokVLBrace,TokIdent "end",TokVLBrace,TokOperator "*>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokOperator ":",TokSymbol ")",TokVRBrace,TokNewline,TokOperator "<$>",TokIdent "p",TokSymbol ";",TokOperator "<*",TokOperator ">",TokIdent "go",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice1",TokIdent "p",TokIdent "q",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "r",TokArrow,TokTypeIdent "Just",TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokIdent "runParser",TokIdent "q",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice",TokSymbol "::",TokSymbol "[",TokTypeIdent "Parser",TokIdent "a",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokIdent "choice1",TokIdent "p",TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokIdent "option",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "option",TokIdent "x",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "<|>",TokIdent "pure",TokIdent "x",TokNewline,TokIdent "lookAhead",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "lookAhead",TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipMany1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipMany1",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "*>",TokIdent "skipMany",TokIdent "p",TokNewline,TokIdent "skipMany",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipMany",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "ts",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Parser"
<< exportItem: next token=TokIdent "runParser"
<< exportItem: next token=TokIdent "satisfy"
<< exportItem: next token=TokIdent "satisfyMap"
<< exportItem: next token=TokIdent "token"
<< exportItem: next token=TokIdent "tokens"
<< exportItem: next token=TokIdent "between"
<< exportItem: next token=TokIdent "sepBy"
<< exportItem: next token=TokIdent "sepBy1"
<< exportItem: next token=TokIdent "sepEndBy"
<< exportItem: next token=TokIdent "sepEndBy1"
<< exportItem: next token=TokIdent "try"
<< exportItem: next token=TokIdent "chainl1"
<< exportItem: next token=TokIdent "many1"
<< exportItem: next token=TokIdent "manyTill"
<< exportItem: next token=TokIdent "choice"
<< exportItem: next token=TokIdent "choice1"
<< exportItem: next token=TokIdent "lookAhead"
<< exportItem: next token=TokIdent "option"
<< exportItem: next token=TokIdent "skipMany"
<< exportItem: next token=TokIdent "skipMany1"
<< declBody: return DeclModule "Parser.Core.Combinator" (Just [ExportType "Parser" True,ExportVar "runParser",ExportVar "satisfy",ExportVar "satisfyMap",ExportVar "token",ExportVar "tokens",ExportVar "between",ExportVar "sepBy",ExportVar "sepBy1",ExportVar "sepEndBy",ExportVar "sepEndBy1",ExportVar "try",ExportVar "chainl1",ExportVar "many1",ExportVar "manyTill",ExportVar "choice",ExportVar "choice1",ExportVar "lookAhead",ExportVar "option",ExportVar "skipMany",ExportVar "skipMany1"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Alternative",ImportVar "many"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "newtype"
<< decl parser called
<< decl dispatch: TokKeyword "newtype"
<< unknown token in decl: TokKeyword "newtype"
Just ([DeclModule "Parser.Core.Combinator" (Just [ExportType "Parser" True,ExportVar "runParser",ExportVar "satisfy",ExportVar "satisfyMap",ExportVar "token",ExportVar "tokens",ExportVar "between",ExportVar "sepBy",ExportVar "sepBy1",ExportVar "sepEndBy",ExportVar "sepEndBy1",ExportVar "try",ExportVar "chainl1",ExportVar "many1",ExportVar "manyTill",ExportVar "choice",ExportVar "choice1",ExportVar "lookAhead",ExportVar "option",ExportVar "skipMany",ExportVar "skipMany1"]),DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Alternative",ImportVar "many"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}],[TokNewline,TokKeyword "newtype",TokTypeIdent "Parser",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokSymbol "{",TokIdent "runParser",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokSymbol "}",TokNewline,TokKeyword "instance",TokTypeIdent "Functor",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "fmap",TokSymbol "::",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "fmap",TokIdent "f",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Applicative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "pure",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "pure",TokIdent "a",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokOperator "<*",TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "pf",TokOperator "<*",TokOperator ">",TokIdent "pa",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pf",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokSymbol ",",TokIdent "rest1",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "pa",TokIdent "rest1",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ",",TokIdent "rest2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Monad",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokSymbol "(",TokOperator ">>",TokSymbol "=",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokSymbol "(",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "b",TokSymbol ";",TokIdent "p",TokOperator ">>",TokSymbol "=",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "f",TokIdent "a",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokKeyword "instance",TokTypeIdent "Alternative",TokTypeIdent "Parser",TokKeyword "where",TokVLBrace,TokIdent "empty",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "empty",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokIdent "const",TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokSymbol ";",TokIdent "p1",TokOperator "<|>",TokIdent "p2",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokIdent "runParser",TokIdent "p1",TokIdent "input",TokOperator "<|>",TokIdent "runParser",TokIdent "p2",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfy",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "satisfy",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "|",TokIdent "f",TokIdent "t",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "satisfyMap",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyMap",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "token",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "token",TokIdent "t",TokSymbol "=",TokIdent "satisfy",TokSymbol "(",TokSymbol "==",TokIdent "t",TokSymbol ")",TokNewline,TokIdent "tokens",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokNewline,TokIdent "tokens",TokIdent "expected",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "expected",TokUnknown '`',TokIdent "isPrefixOf`",TokIdent "input",TokVLBrace,TokKeyword "then",TokTypeIdent "Just",TokSymbol "(",TokIdent "expected",TokSymbol ",",TokIdent "drop",TokSymbol "(",TokIdent "length",TokIdent "expected",TokSymbol ")",TokIdent "input",TokSymbol ")",TokSymbol ";",TokKeyword "else",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "between",TokSymbol "::",TokTypeIdent "Parser",TokIdent "open",TokArrow,TokTypeIdent "Parser",TokIdent "close",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "between",TokIdent "open",TokIdent "close",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "open",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "_",TokSymbol "<-",TokIdent "close",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "sepBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "x",TokSymbol "<-",TokIdent "p",TokIdent "xs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "p",TokSymbol ")",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "first",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokSymbol "(",TokIdent "sep",TokOperator "*>",TokIdent "sepBy1",TokIdent "p",TokIdent "sep",TokSymbol ")",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "first",TokOperator ":",TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "sepEndBy1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokSymbol "(",TokKeyword "do",TokSymbol "_",TokSymbol "<-",TokIdent "sep",TokIdent "xs",TokSymbol "<-",TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokIdent "x",TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "sepEndBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "sep",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "sepEndBy",TokIdent "p",TokIdent "sep",TokSymbol "=",TokIdent "sepEndBy1",TokIdent "p",TokIdent "sep",TokOperator "<|>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokNewline,TokIdent "try",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "try",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokIdent "runParser",TokIdent "p",TokIdent "tokens",TokNewline,TokIdent "chainl1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokIdent "a",TokArrow,TokIdent "a",TokArrow,TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "chainl1",TokIdent "p",TokIdent "op",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "rest",TokIdent "x",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "x",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "f",TokSymbol "<-",TokIdent "op",TokIdent "y",TokSymbol "<-",TokIdent "p",TokIdent "rest",TokSymbol "(",TokIdent "f",TokIdent "x",TokIdent "y",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "x",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "many1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "many1",TokIdent "p",TokSymbol "=",TokSymbol "(",TokOperator ":",TokSymbol ")",TokOperator "<$>",TokIdent "p",TokOperator "<*",TokOperator ">",TokIdent "many",TokIdent "p",TokNewline,TokIdent "manyTill",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "end",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "manyTill",TokIdent "p",TokIdent "end",TokSymbol "=",TokIdent "go",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokSymbol "=",TokVLBrace,TokIdent "end",TokVLBrace,TokOperator "*>",TokIdent "pure",TokSymbol "[",TokSymbol "]",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokOperator ":",TokSymbol ")",TokVRBrace,TokNewline,TokOperator "<$>",TokIdent "p",TokSymbol ";",TokOperator "<*",TokOperator ">",TokIdent "go",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice1",TokIdent "p",TokIdent "q",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "r",TokArrow,TokTypeIdent "Just",TokIdent "r",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokIdent "runParser",TokIdent "q",TokIdent "input",TokVRBrace,TokVRBrace,TokNewline,TokIdent "choice",TokSymbol "::",TokSymbol "[",TokTypeIdent "Parser",TokIdent "a",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "choice",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokNewline,TokIdent "choice",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokIdent "choice1",TokIdent "p",TokSymbol "(",TokIdent "choice",TokIdent "ps",TokSymbol ")",TokNewline,TokIdent "option",TokSymbol "::",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "option",TokIdent "x",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "<|>",TokIdent "pure",TokIdent "x",TokNewline,TokIdent "lookAhead",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "lookAhead",TokSymbol "(",TokTypeIdent "Parser",TokIdent "p",TokSymbol ")",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipMany1",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipMany1",TokIdent "p",TokSymbol "=",TokIdent "p",TokOperator "*>",TokIdent "skipMany",TokIdent "p",TokNewline,TokIdent "skipMany",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipMany",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "ts",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "_",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokArrow,TokIdent "runParser",TokSymbol "(",TokIdent "skipMany",TokIdent "p",TokSymbol ")",TokIdent "ts'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Core/Parser.hs ===
-- Raw Source --
-- module Parser.Core.Parser (parseExpr, runToplevelTest, runExprTest, toplevel) where
module Parser.Core.Parser (parseExpr, toplevel) where

import AST.Expr
import Control.Applicative (many, (<|>))
import Lexer.Token (Token (..))
import Lexer.Lexer (runLexer)
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (expr, letExpr)
import Parser.Expr.PatternParser
-- import Parser.Type.TypeParser

-- === é¿çsä÷êî ===

toplevel :: Parser (String, Expr)
toplevel = do
  name <- ident
  symbol "="
  body <- exprCore
  return (name, body)
{-}
parseExpr :: [Token] -> IO (Maybe Expr)
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing
-}
parseExpr :: [Token] -> Maybe (Expr, [Token])
parseExpr toks = runParser expr toks

{-}
parseExpr :: [Token] -> Maybe Expr
parseExpr toks = case runParser expr toks of
  Just (result, rest) | null rest -> Just result
  _ -> Nothing
-}

parseToplevel :: [Token] -> IO (Maybe (String, Expr))
parseToplevel toks = case runParser toplevel toks of
  Just (result, rest) | null rest -> return (Just result)
  _ -> return Nothing

{-}
-- éÆÇÃÉeÉXÉg
runExprTest :: ([Char], [Char]) -> IO ()
runExprTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseExpr tokens
      case result of
        Nothing -> putStrLn "  Parser error!"
        Just ast ->
          compareAST (show ast) expected

-- ÉgÉbÉvÉåÉxÉãíËã`ÇÃÉeÉXÉg
runToplevelTest :: ([Char], [Char]) -> IO ()
runToplevelTest (input, expected) = do
  putStrLn $ "Input: " ++ input
  case runLexer input of
    Left err -> putStrLn $ "  Lexer error: " ++ show err
    Right tokens -> do
      putStrLn $ " Tokens: " ++ show tokens
      result <- parseToplevel tokens
      case result of
        Nothing -> putStrLn "  Parser error!\n"
        Just (_, ast) ->
          compareAST (show ast) expected
-}

-- ã§í ÇÃî‰ärèàóù
compareAST actualRaw expectedRaw = do
  let normalize = filter (not . (`elem` [' ', '\n', '\t']))
      actual = normalize actualRaw
      expected = normalize expectedRaw
  if actual == expected
    then putStrLn "  O Passed\n"
    else do
      putStrLn "  X Failed!"
      putStrLn $ "     Expected: " ++ expectedRaw
      putStrLn $ "     Got:      " ++ actualRaw ++ "\n"


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Parser",TokSymbol "(",TokIdent "parseExpr",TokSymbol ",",TokIdent "toplevel",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Lexer",TokSymbol "(",TokIdent "runLexer",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "letExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokIdent "toplevel",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "toplevel",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseExpr",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "parseExpr",TokIdent "toks",TokSymbol "=",TokIdent "runParser",TokIdent "expr",TokIdent "toks",TokNewline,TokIdent "parseToplevel",TokSymbol "::",TokSymbol "[",TokTypeIdent "Token",TokSymbol "]",TokArrow,TokTypeIdent "IO",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol ")",TokNewline,TokIdent "parseToplevel",TokIdent "toks",TokSymbol "=",TokKeyword "case",TokIdent "runParser",TokIdent "toplevel",TokIdent "toks",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokIdent "result",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "|",TokIdent "null",TokIdent "rest",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "result",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "compareAST",TokIdent "actualRaw",TokIdent "expectedRaw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "normalize",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokUnknown '`',TokIdent "elem`",TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokVLBrace,TokIdent "actual",TokSymbol "=",TokIdent "normalize",TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSymbol "=",TokIdent "normalize",TokIdent "expectedRaw",TokVRBrace,TokNewline,TokKeyword "if",TokIdent "actual",TokSymbol "==",TokIdent "expected",TokVLBrace,TokKeyword "then",TokIdent "putStrLn",TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "putStrLn",TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Expected: ",TokOperator "++",TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Got:      ",TokOperator "++",TokIdent "actualRaw",TokOperator "++",TokString "\n",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseExpr"
<< exportItem: next token=TokIdent "toplevel"
<< declBody: return DeclModule "Parser.Core.Parser" (Just [ExportVar "parseExpr",ExportVar "toplevel"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "many",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "letExpr"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "toplevel"
<< decl parser called
<< decl dispatch: TokIdent "toplevel"
<< funDecl: next token=TokIdent "toplevel"
<< funClause: next token=TokIdent "toplevel"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "toplevel"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])
<< parsed type signature: toplevel :: TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])
<< returning DeclTypeSig: DeclTypeSig "toplevel" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"]))
<< declBody: return DeclTypeSig "toplevel" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"]))
<< decl next token: TokIdent "toplevel"
<< decl parser called
<< decl dispatch: TokIdent "toplevel"
<< funDecl: next token=TokIdent "toplevel"
<< funClause: next token=TokIdent "toplevel"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "name"
<< pattern1: (pAs <|> makeCons)PApp (PVar "name") []
<< expr dispatch: TokIdent "ident"
<< exprCore next token: TokIdent "ident"
<< atomBaseCore next token: TokIdent "ident"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "="]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "="
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "body"
<< pattern1: (pAs <|> makeCons)PApp (PVar "body") []
<< expr dispatch: TokIdent "exprCore"
<< exprCore next token: TokIdent "exprCore"
<< atomBaseCore next token: TokIdent "exprCore"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "body"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "parseExpr"
<< funClauseWithName: next token=TokIdent "parseExpr"
<< declBody: return DeclFunGroup "toplevel" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "name") []) (EVar "ident"),ExprStmt (EApp (EVar "symbol") (EString "=")),Bind (PApp (PVar "body") []) (EVar "exprCore"),ExprStmt (EReturn (ETuple [EVar "name",EVar "body"]))])) Nothing]
<< decl next token: TokIdent "parseExpr"
<< decl parser called
<< decl dispatch: TokIdent "parseExpr"
<< funDecl: next token=TokIdent "parseExpr"
<< funClause: next token=TokIdent "parseExpr"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseExpr"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TList (TCon "Token")
<< parseTypeCore: TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")])
<< parseTypeCore: TFun (TList (TCon "Token")) (TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")]))
<< parsed type signature: parseExpr :: TFun (TList (TCon "Token")) (TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")]))
<< returning DeclTypeSig: DeclTypeSig "parseExpr" (TFun (TList (TCon "Token")) (TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")])))
<< declBody: return DeclTypeSig "parseExpr" (TFun (TList (TCon "Token")) (TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")])))
<< decl next token: TokIdent "parseExpr"
<< decl parser called
<< decl dispatch: TokIdent "parseExpr"
<< funDecl: next token=TokIdent "parseExpr"
<< funClause: next token=TokIdent "parseExpr"
<< patternParser: (pAs <|> makeCons)PApp (PVar "toks") []
<< funClause: args=[PApp (PVar "toks") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "runParser"
<< expr dispatch: TokIdent "runParser"
<< exprCore next token: TokIdent "runParser"
<< atomBaseCore next token: TokIdent "runParser"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "parseToplevel"
<< funClauseWithName: next token=TokIdent "parseToplevel"
<< declBody: return DeclFunGroup "parseExpr" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EApp (EVar "runParser") (EVar "expr")) (EVar "toks"))) Nothing]
<< decl next token: TokIdent "parseToplevel"
<< decl parser called
<< decl dispatch: TokIdent "parseToplevel"
<< funDecl: next token=TokIdent "parseToplevel"
<< funClause: next token=TokIdent "parseToplevel"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseToplevel"
<< parseType dispatch: TokSymbol "["
<< parseTypeCore: TCon "Token"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"])
<< parseTypeCore: TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"]))
<< parseTypeCore: TFun (TList (TCon "Token")) (TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"])))
<< parsed type signature: parseToplevel :: TFun (TList (TCon "Token")) (TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"])))
<< returning DeclTypeSig: DeclTypeSig "parseToplevel" (TFun (TList (TCon "Token")) (TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"]))))
<< declBody: return DeclTypeSig "parseToplevel" (TFun (TList (TCon "Token")) (TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"]))))
<< decl next token: TokIdent "parseToplevel"
<< decl parser called
<< decl dispatch: TokIdent "parseToplevel"
<< funDecl: next token=TokIdent "parseToplevel"
<< funClause: next token=TokIdent "parseToplevel"
<< patternParser: (pAs <|> makeCons)PApp (PVar "toks") []
<< funClause: args=[PApp (PVar "toks") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "runParser"
<< exprCore next token: TokIdent "runParser"
<< atomBaseCore next token: TokIdent "runParser"
<< atomBaseCore next token: TokIdent "toplevel"
<< atomBaseCore next token: TokIdent "toks"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PVar "result") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Just" []) [PTuple [PApp (PVar "result") [],PApp (PVar "rest") []]]
<< expr dispatch: TokIdent "null"
<< exprCore next token: TokIdent "null"
<< atomBaseCore next token: TokIdent "null"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokArrow
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "result"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "result"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokTypeIdent "Just"
<< atomBaseCore next token: TokIdent "result"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokTypeIdent "Nothing"
<< exprCore next token: TokTypeIdent "Nothing"
<< atomBaseCore next token: TokTypeIdent "Nothing"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "compareAST"
<< funClauseWithName: next token=TokIdent "compareAST"
<< declBody: return DeclFunGroup "parseToplevel" [FunClause [PApp (PVar "toks") []] Nothing (Just (ECase (EApp (EApp (EVar "runParser") (EVar "toplevel")) (EVar "toks")) [CaseAltGuard (PApp (PConstr "Just" []) [PTuple [PApp (PVar "result") [],PApp (PVar "rest") []]]) [(EApp (EVar "null") (EVar "rest"),EReturn (EApp (EVarType "Just") (EVar "result")))],CaseAlt (PApp PWildcard []) (EReturn (EVarType "Nothing"))])) Nothing]
<< decl next token: TokIdent "compareAST"
<< decl parser called
<< decl dispatch: TokIdent "compareAST"
<< funDecl: next token=TokIdent "compareAST"
<< funClause: next token=TokIdent "compareAST"
<< patternParser: (pAs <|> makeCons)PApp (PVar "actualRaw") [PVar "expectedRaw"]
<< funClause: args=[PApp (PVar "actualRaw") [PVar "expectedRaw"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "normalize") []
<< expr dispatch: TokIdent "filter"
<< exprCore next token: TokIdent "filter"
<< atomBaseCore next token: TokIdent "filter"
<< exprCore next token: TokIdent "not"
<< atomBaseCore next token: TokIdent "not"
<< atomBaseCore next token: TokDot
<< exprCore next token: TokIdent "not"
<< atomBaseCore next token: TokIdent "not"
<< atomBaseCore next token: TokDot
<< exprCore next token: TokIdent "not"
<< atomBaseCore next token: TokIdent "not"
<< atomBaseCore next token: TokDot
<< atomBaseCore next token: TokSymbol "("
<< letStmt:binding next token: TokSymbol "("
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokKeyword "let"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "compareAST" [FunClause [PApp (PVar "actualRaw") [PVar "expectedRaw"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Core.Parser" (Just [ExportVar "parseExpr",ExportVar "toplevel"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "many",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Lexer.Lexer", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "runLexer"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "expr",ImportVar "letExpr"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "toplevel" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])),DeclFunGroup "toplevel" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "name") []) (EVar "ident"),ExprStmt (EApp (EVar "symbol") (EString "=")),Bind (PApp (PVar "body") []) (EVar "exprCore"),ExprStmt (EReturn (ETuple [EVar "name",EVar "body"]))])) Nothing],DeclTypeSig "parseExpr" (TFun (TList (TCon "Token")) (TApp (TCon "Maybe") (TTuple [TCon "Expr",TList (TCon "Token")]))),DeclFunGroup "parseExpr" [FunClause [PApp (PVar "toks") []] Nothing (Just (EApp (EApp (EVar "runParser") (EVar "expr")) (EVar "toks"))) Nothing],DeclTypeSig "parseToplevel" (TFun (TList (TCon "Token")) (TApp (TCon "IO") (TApp (TCon "Maybe") (TTuple [TCon "String",TCon "Expr"])))),DeclFunGroup "parseToplevel" [FunClause [PApp (PVar "toks") []] Nothing (Just (ECase (EApp (EApp (EVar "runParser") (EVar "toplevel")) (EVar "toks")) [CaseAltGuard (PApp (PConstr "Just" []) [PTuple [PApp (PVar "result") [],PApp (PVar "rest") []]]) [(EApp (EVar "null") (EVar "rest"),EReturn (EApp (EVarType "Just") (EVar "result")))],CaseAlt (PApp PWildcard []) (EReturn (EVarType "Nothing"))])) Nothing],DeclFunGroup "compareAST" [FunClause [PApp (PVar "actualRaw") [PVar "expectedRaw"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokKeyword "let",TokIdent "normalize",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokIdent "not",TokDot,TokSymbol "(",TokUnknown '`',TokIdent "elem`",TokSymbol "[",TokChar ' ',TokSymbol ",",TokChar '\n',TokSymbol ",",TokChar '\t',TokSymbol "]",TokSymbol ")",TokSymbol ")",TokVLBrace,TokIdent "actual",TokSymbol "=",TokIdent "normalize",TokIdent "actualRaw",TokSymbol ";",TokIdent "expected",TokSymbol "=",TokIdent "normalize",TokIdent "expectedRaw",TokVRBrace,TokNewline,TokKeyword "if",TokIdent "actual",TokSymbol "==",TokIdent "expected",TokVLBrace,TokKeyword "then",TokIdent "putStrLn",TokString "  O Passed\n",TokSymbol ";",TokKeyword "else",TokKeyword "do",TokVLBrace,TokIdent "putStrLn",TokString "  X Failed!",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Expected: ",TokOperator "++",TokIdent "expectedRaw",TokSymbol ";",TokIdent "putStrLn",TokOperator "$",TokString "     Got:      ",TokOperator "++",TokIdent "actualRaw",TokOperator "++",TokString "\n",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Core/TokenParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Core.TokenParser
  ( ident,
    int,
    keyword,
    symbol,
    tokenIs,
    parens,
    brackets,
    braces,
    bracesv,
    bracesV,
    bracesV3,
    notFollowedBy,
    (<?>),
    anyToken,
    stringLiteralExpr,
    charLiteralExpr,
    skipNewlines,
    newline,
    skipSeparators,
    name,
    operator,
    bracedBlock,
    anyToken,
    binOp,
    operatorVar,
    satisfyToken,
    symbolToken,
  )
where

import AST.Expr
import Control.Applicative (empty, many, (<|>))
import Data.Functor (void)
import qualified Data.Set as Set
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Utils.MyTrace (myTrace)

-- import Text.Megaparsec (token, (<?>))

(<?>) :: Parser a -> String -> Parser a
p <?> _ = p

braces :: Parser a -> Parser a
braces p = between (symbol "{") (symbol "}") p

bracesv :: Parser a -> Parser a
bracesv p = between (token TokVLBrace) (token TokVRBrace) p

-- bracesV :: Parser a -> Parser a
-- bracesV p = between (token TokVLBrace) (token TokVRBrace) p

-- âºëzäáå 
bracesV :: Parser a -> Parser a
bracesV p = try (bracesv p) <|> (braces p)

-- äáå ñ≥ÇµÇ≈Ç‡àµÇ§
bracesV3 :: Parser a -> Parser a
bracesV3 p = do try (bracesv p) <|> (braces p) <|> p

-- parens :: Parser a -> Parser a
-- parens p = between (symbol "(") (symbol ")") p
parens :: Parser a -> Parser a
parens p = do
  symbol "("
  x <- p
  symbol ")"
  return x

brackets :: Parser a -> Parser a
brackets p = between (symbol "[") (symbol "]") p

ident :: Parser String
ident = tokenIs $ \case
  TokIdent s -> Just s
  _ -> Nothing

int :: Parser Int
int = do
  t <- satisfy isNumber
  case t of
    -- TokNumber n -> myTrace ("<< int: " ++ show n) >> pure n
    TokNumber n -> pure n
    -- TokNumber n -> pure n
    _ -> empty
  where
    isNumber (TokNumber _) = True
    isNumber _ = False

keyword :: String -> Parser ()
keyword kw = do
  t <- satisfy isKeyword
  case t of
    -- TokKeyword s | s == kw -> myTrace ("<< keyword: " ++ s) >> pure ()
    TokKeyword s | s == kw -> pure ()
    _ -> empty
  where
    isKeyword (TokKeyword _) = True
    isKeyword _ = False

symbol :: String -> Parser ()
symbol s = tokenIs $ \case
  TokSymbol s' | s' == s -> Just ()
  TokOperator s' | s' == s -> Just ()
  _ -> Nothing

tokenIs :: (Token -> Maybe a) -> Parser a
tokenIs f = Parser $ \case
  (t : ts) -> case f t of
    Just a -> Just (a, ts)
    Nothing -> Nothing
  [] -> Nothing

notFollowedBy :: Parser a -> Parser ()
notFollowedBy p = Parser $ \input ->
  case runParser p input of
    Nothing -> Just ((), input) -- p Ç™é∏îs Å® ê¨å˜
    Just _ -> Nothing -- p Ç™ê¨å˜ Å® é∏îs

anyToken :: Parser Token
anyToken = Parser $ \input ->
  case input of
    (t : ts) -> Just (t, ts)
    [] -> Nothing

debugPeek :: Parser ()
debugPeek = do
  t <- peekToken
  Parser $ \tokens ->
    Just ((), tokens)

peekToken :: Parser Token
peekToken = Parser $ \tokens -> case tokens of
  [] -> Nothing
  (t : _) -> Just (t, tokens)

stringLiteralExpr :: Parser String
stringLiteralExpr =
  satisfyToken f
  where
    f (TokString s) = Just s
    f _ = Nothing

charLiteralExpr :: Parser Char
charLiteralExpr =
  satisfyToken f
  where
    f (TokChar s) = Just s
    f _ = Nothing

satisfyToken :: (Token -> Maybe a) -> Parser a
satisfyToken f = Parser $ \ts -> case ts of
  [] -> Nothing
  (t : ts') -> case f t of
    Just x -> Just (x, ts')
    Nothing -> Nothing

skipSeparators :: Parser ()
skipSeparators = do
  _ <- many (tokenIs isSep)
  return ()
  where
    isSep TokNewline = Just ()
    isSep (TokSymbol ";") = Just ()
    isSep _ = Nothing

newline :: Parser ()
newline = void (token TokNewline)

skipNewlines :: Parser ()
skipNewlines = do
  _ <- many (tokenIs (\t -> if t == TokNewline then Just () else Nothing))
  return ()

binOp :: [String] -> Parser (Expr -> Expr -> Expr)
binOp ops = tokenIs $ \case
  TokOperator op | op `elem` ops ->
    case parseBinOp op of
      Just bop -> Just (EBinOp bop)
      Nothing -> Nothing
  _ -> Nothing

parseBinOp :: String -> Maybe BinOp
parseBinOp s = case s of
  "+" -> Just Add
  "-" -> Just Sub
  "*" -> Just Mul
  "/" -> Just Div
  "==" -> Just Eq
  "!=" -> Just Neq
  "<" -> Just Lt
  ">" -> Just Gt
  "<=" -> Just Le
  ">=" -> Just Ge
  "&&" -> Just And
  "||" -> Just Or
  "++" -> Just Concat
  ":" -> Just Cons
  _ -> Nothing

operator :: Parser String
operator = choice (map (\s -> symbol s >> return s) allOps)
  where
    allOps =
      [ "==",
        "/=",
        ">=",
        "<=",
        "+",
        "-",
        "*",
        "/",
        ">",
        "<",
        ":"
      ]

operatorVar :: Parser Expr
operatorVar = do
  op <- satisfyToken isOp
  return (EVar op)
  where
    isOp (TokOperator s) = Just s
    isOp _ = Nothing

{-}
operator :: Parser String
operator = do
  symbol "("
  op <- operatorTok
  symbol ")"
  return (op)
-}

-- ä÷êîñºÇ‚ââéZéqñºÇÉpÅ[ÉXÇ∑ÇÈã§í ÉpÅ[ÉTÅ[
-- ó·: "f" Ç‚ "==" Ç‚ "(==)"
name :: Parser String
name = try parenOp <|> ident <|> symbolOp

-- äáå ïtÇ´ÉIÉyÉåÅ[É^: (==)
parenOp :: Parser String
parenOp = do
  symbol "("
  op <- symbolOp
  symbol ")"
  return op

-- äáå Ç»ÇµÇÃÉIÉyÉåÅ[É^: ==
symbolOp :: Parser String
symbolOp = do
  tok <- satisfy isSymbol
  case tok of
    TokSymbol s -> return s
    _ -> empty -- Ç±Ç±Ç…ÇÕóàÇ»Ç¢ÇÕÇ∏ÇæÇØÇ«ÅAà¿ëSÇÃÇΩÇﬂ

-- ï∂éöóÒÇ™ÉIÉyÉåÅ[É^Ç©Ç«Ç§Ç©
isSymbol :: Token -> Bool
isSymbol (TokSymbol _) = True
isSymbol _ = False

bracedBlock :: Parser a -> Parser [a]
bracedBlock p = do
  symbol "{"
  go 1 []
  where
    go 0 acc = return (reverse acc)
    go n acc = do
      t <- lookAhead anyToken
      case t of
        TokSymbol "{" -> symbol "{" >> go (n + 1) acc
        TokSymbol "}" -> symbol "}" >> go (n - 1) acc
        _ -> do
          x <- p
          go n (x : acc)

symbolToken :: Token -> Parser Token
symbolToken tok = satisfyToken match
  where
    match t
      | t == tok = Just t
      | otherwise = Nothing


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokVLBrace,TokSymbol "(",TokIdent "ident",TokSymbol ",",TokIdent "int",TokSymbol ",",TokIdent "keyword",TokSymbol ",",TokIdent "symbol",TokSymbol ",",TokIdent "tokenIs",TokSymbol ",",TokIdent "parens",TokSymbol ",",TokIdent "brackets",TokSymbol ",",TokIdent "braces",TokSymbol ",",TokIdent "bracesv",TokSymbol ",",TokIdent "bracesV",TokSymbol ",",TokIdent "bracesV3",TokSymbol ",",TokIdent "notFollowedBy",TokSymbol ",",TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "stringLiteralExpr",TokSymbol ",",TokIdent "charLiteralExpr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokIdent "newline",TokSymbol ",",TokIdent "skipSeparators",TokSymbol ",",TokIdent "name",TokSymbol ",",TokIdent "operator",TokSymbol ",",TokIdent "bracedBlock",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "binOp",TokSymbol ",",TokIdent "operatorVar",TokSymbol ",",TokIdent "satisfyToken",TokSymbol ",",TokIdent "symbolToken",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokKeyword "as",TokTypeIdent "Set",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "p",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol "_",TokSymbol "=",TokIdent "p",TokNewline,TokIdent "braces",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "braces",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesv",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesv",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesV",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV",TokIdent "p",TokSymbol "=",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokNewline,TokIdent "bracesV3",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV3",TokIdent "p",TokSymbol "=",TokKeyword "do",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokIdent "p",TokNewline,TokIdent "parens",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parens",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "brackets",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "brackets",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "ident",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "ident",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "int",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Int",TokNewline,TokIdent "int",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokNumber",TokIdent "n",TokArrow,TokIdent "pure",TokIdent "n",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isNumber",TokSymbol "(",TokTypeIdent "TokNumber",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "keyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "keyword",TokIdent "kw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokKeyword",TokIdent "s",TokSymbol "|",TokIdent "s",TokSymbol "==",TokIdent "kw",TokArrow,TokIdent "pure",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isKeyword",TokSymbol "(",TokTypeIdent "TokKeyword",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbol",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "symbol",TokIdent "s",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokSymbol "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokTypeIdent "TokOperator",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokSymbol "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "tokenIs",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "tokenIs",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "a",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "notFollowedBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "notFollowedBy",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "anyToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "input",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "debugPeek",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "debugPeek",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "peekToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "stringLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "charLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Char",TokNewline,TokIdent "charLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokChar",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfyToken",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyToken",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts'",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipSeparators",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipSeparators",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "()",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isSep",TokTypeIdent "TokNewline",TokSymbol "=",TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokIdent "isSep",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokIdent "isSep",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipNewlines",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "()",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "binOp",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokIdent "ops",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokOperator",TokIdent "op",TokSymbol "|",TokIdent "op",TokUnknown '`',TokIdent "elem`",TokIdent "ops",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "parseBinOp",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "bop",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "parseBinOp",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokIdent "s",TokSymbol "=",TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokString "+",TokArrow,TokTypeIdent "Just",TokTypeIdent "Add",TokSymbol ";",TokString "-",TokArrow,TokTypeIdent "Just",TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokArrow,TokTypeIdent "Just",TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokArrow,TokTypeIdent "Just",TokTypeIdent "Div",TokSymbol ";",TokString "==",TokArrow,TokTypeIdent "Just",TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokArrow,TokTypeIdent "Just",TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokArrow,TokTypeIdent "Just",TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokArrow,TokTypeIdent "Just",TokTypeIdent "And",TokSymbol ";",TokString "||",TokArrow,TokTypeIdent "Just",TokTypeIdent "Or",TokSymbol ";",TokString "++",TokArrow,TokTypeIdent "Just",TokTypeIdent "Concat",TokSymbol ";",TokString ":",TokArrow,TokTypeIdent "Just",TokTypeIdent "Cons",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "operator",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "operator",TokSymbol "=",TokIdent "choice",TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">>",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "allOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokString "==",TokSymbol ",",TokVLBrace,TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol ",",TokSymbol ";",TokString ":",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "operatorVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "satisfyToken",TokIdent "isOp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "isOp",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "name",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "name",TokSymbol "=",TokIdent "try",TokIdent "parenOp",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "symbolOp",TokNewline,TokIdent "parenOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "op",TokVRBrace,TokNewline,TokIdent "symbolOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tok",TokSymbol "<-",TokIdent "satisfy",TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokIdent "tok",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s",TokArrow,TokKeyword "return",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbol",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSymbol "(",TokTypeIdent "TokSymbol",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "bracedBlock",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "go",TokNumber 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "go",TokNumber 0,TokIdent "acc",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokIdent "n",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokIdent "symbol",TokString "{",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokIdent "symbol",TokString "}",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "go",TokIdent "n",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbolToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "symbolToken",TokIdent "tok",TokSymbol "=",TokIdent "satisfyToken",TokIdent "match",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "match",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokIdent "tok",TokSymbol "=",TokTypeIdent "Just",TokIdent "t",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "ident"
<< exportItem: next token=TokIdent "int"
<< exportItem: next token=TokIdent "keyword"
<< exportItem: next token=TokIdent "symbol"
<< exportItem: next token=TokIdent "tokenIs"
<< exportItem: next token=TokIdent "parens"
<< exportItem: next token=TokIdent "brackets"
<< exportItem: next token=TokIdent "braces"
<< exportItem: next token=TokIdent "bracesv"
<< exportItem: next token=TokIdent "bracesV"
<< exportItem: next token=TokIdent "bracesV3"
<< exportItem: next token=TokIdent "notFollowedBy"
<< exportItem: next token=TokSymbol "("
<< exportItem: next token=TokIdent "ident"
<< exportItem: next token=TokIdent "int"
<< exportItem: next token=TokIdent "keyword"
<< exportItem: next token=TokIdent "symbol"
<< exportItem: next token=TokIdent "tokenIs"
<< exportItem: next token=TokIdent "parens"
<< exportItem: next token=TokIdent "brackets"
<< exportItem: next token=TokIdent "braces"
<< exportItem: next token=TokIdent "bracesv"
<< exportItem: next token=TokIdent "bracesV"
<< exportItem: next token=TokIdent "bracesV3"
<< exportItem: next token=TokIdent "notFollowedBy"
<< exportItem: next token=TokSymbol "("
Just ([],[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokVLBrace,TokSymbol "(",TokIdent "ident",TokSymbol ",",TokIdent "int",TokSymbol ",",TokIdent "keyword",TokSymbol ",",TokIdent "symbol",TokSymbol ",",TokIdent "tokenIs",TokSymbol ",",TokIdent "parens",TokSymbol ",",TokIdent "brackets",TokSymbol ",",TokIdent "braces",TokSymbol ",",TokIdent "bracesv",TokSymbol ",",TokIdent "bracesV",TokSymbol ",",TokIdent "bracesV3",TokSymbol ",",TokIdent "notFollowedBy",TokSymbol ",",TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "stringLiteralExpr",TokSymbol ",",TokIdent "charLiteralExpr",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokIdent "newline",TokSymbol ",",TokIdent "skipSeparators",TokSymbol ",",TokIdent "name",TokSymbol ",",TokIdent "operator",TokSymbol ",",TokIdent "bracedBlock",TokSymbol ",",TokIdent "anyToken",TokSymbol ",",TokIdent "binOp",TokSymbol ",",TokIdent "operatorVar",TokSymbol ",",TokIdent "satisfyToken",TokSymbol ",",TokIdent "symbolToken",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Set",TokKeyword "as",TokTypeIdent "Set",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokSymbol "(",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol ")",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "p",TokOperator "<",TokUnknown '?',TokOperator ">",TokSymbol "_",TokSymbol "=",TokIdent "p",TokNewline,TokIdent "braces",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "braces",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "{",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "}",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesv",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesv",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVLBrace",TokSymbol ")",TokSymbol "(",TokIdent "token",TokTypeIdent "TokVRBrace",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "bracesV",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV",TokIdent "p",TokSymbol "=",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokNewline,TokIdent "bracesV3",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "bracesV3",TokIdent "p",TokSymbol "=",TokKeyword "do",TokIdent "try",TokSymbol "(",TokIdent "bracesv",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokSymbol "(",TokIdent "braces",TokIdent "p",TokSymbol ")",TokOperator "<|>",TokIdent "p",TokNewline,TokIdent "parens",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "parens",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "x",TokVRBrace,TokNewline,TokIdent "brackets",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "brackets",TokIdent "p",TokSymbol "=",TokIdent "between",TokSymbol "(",TokIdent "symbol",TokString "[",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString "]",TokSymbol ")",TokIdent "p",TokNewline,TokIdent "ident",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "ident",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "int",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Int",TokNewline,TokIdent "int",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isNumber",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokNumber",TokIdent "n",TokArrow,TokIdent "pure",TokIdent "n",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isNumber",TokSymbol "(",TokTypeIdent "TokNumber",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isNumber",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "keyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "keyword",TokIdent "kw",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "satisfy",TokIdent "isKeyword",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "TokKeyword",TokIdent "s",TokSymbol "|",TokIdent "s",TokSymbol "==",TokIdent "kw",TokArrow,TokIdent "pure",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "isKeyword",TokSymbol "(",TokTypeIdent "TokKeyword",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokSymbol ";",TokIdent "isKeyword",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbol",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "symbol",TokIdent "s",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokSymbol "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokTypeIdent "TokOperator",TokIdent "s'",TokSymbol "|",TokIdent "s'",TokSymbol "==",TokIdent "s",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "tokenIs",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "tokenIs",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "a",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "a",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "notFollowedBy",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "notFollowedBy",TokIdent "p",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "runParser",TokIdent "p",TokIdent "input",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "anyToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "anyToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "input",TokKeyword "of",TokVLBrace,TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol ";",TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "debugPeek",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "debugPeek",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "peekToken",TokSymbol ";",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "peekToken",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "peekToken",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "tokens",TokArrow,TokKeyword "case",TokIdent "tokens",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "t",TokSymbol ",",TokIdent "tokens",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "stringLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "stringLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokString",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "charLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Char",TokNewline,TokIdent "charLiteralExpr",TokSymbol "=",TokVLBrace,TokIdent "satisfyToken",TokIdent "f",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "f",TokSymbol "(",TokTypeIdent "TokChar",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "f",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "satisfyToken",TokSymbol "::",TokSymbol "(",TokTypeIdent "Token",TokArrow,TokTypeIdent "Maybe",TokIdent "a",TokSymbol ")",TokArrow,TokTypeIdent "Parser",TokIdent "a",TokNewline,TokIdent "satisfyToken",TokIdent "f",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Nothing",TokSymbol ";",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts'",TokSymbol ")",TokArrow,TokKeyword "case",TokIdent "f",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "x",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "ts'",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "skipSeparators",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipSeparators",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokIdent "isSep",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "()",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isSep",TokTypeIdent "TokNewline",TokSymbol "=",TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokIdent "isSep",TokSymbol "(",TokTypeIdent "TokSymbol",TokString ";",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokIdent "isSep",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "skipNewlines",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "skipNewlines",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokNewline",TokKeyword "then",TokTypeIdent "Just",TokSymbol "()",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "binOp",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "binOp",TokIdent "ops",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokOperator",TokIdent "op",TokSymbol "|",TokIdent "op",TokUnknown '`',TokIdent "elem`",TokIdent "ops",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "parseBinOp",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "bop",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "bop",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "parseBinOp",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "BinOp",TokNewline,TokIdent "parseBinOp",TokIdent "s",TokSymbol "=",TokKeyword "case",TokIdent "s",TokKeyword "of",TokVLBrace,TokString "+",TokArrow,TokTypeIdent "Just",TokTypeIdent "Add",TokSymbol ";",TokString "-",TokArrow,TokTypeIdent "Just",TokTypeIdent "Sub",TokSymbol ";",TokString "*",TokArrow,TokTypeIdent "Just",TokTypeIdent "Mul",TokSymbol ";",TokString "/",TokArrow,TokTypeIdent "Just",TokTypeIdent "Div",TokSymbol ";",TokString "==",TokArrow,TokTypeIdent "Just",TokTypeIdent "Eq",TokSymbol ";",TokString "!=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Neq",TokSymbol ";",TokString "<",TokArrow,TokTypeIdent "Just",TokTypeIdent "Lt",TokSymbol ";",TokString ">",TokArrow,TokTypeIdent "Just",TokTypeIdent "Gt",TokSymbol ";",TokString "<=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Le",TokSymbol ";",TokString ">=",TokArrow,TokTypeIdent "Just",TokTypeIdent "Ge",TokSymbol ";",TokString "&&",TokArrow,TokTypeIdent "Just",TokTypeIdent "And",TokSymbol ";",TokString "||",TokArrow,TokTypeIdent "Just",TokTypeIdent "Or",TokSymbol ";",TokString "++",TokArrow,TokTypeIdent "Just",TokTypeIdent "Concat",TokSymbol ";",TokString ":",TokArrow,TokTypeIdent "Just",TokTypeIdent "Cons",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "operator",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "operator",TokSymbol "=",TokIdent "choice",TokSymbol "(",TokIdent "map",TokSymbol "(",TokSymbol "\\",TokIdent "s",TokArrow,TokIdent "symbol",TokIdent "s",TokOperator ">>",TokKeyword "return",TokIdent "s",TokSymbol ")",TokIdent "allOps",TokSymbol ")",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "allOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokString "==",TokSymbol ",",TokVLBrace,TokString "/=",TokSymbol ",",TokSymbol ";",TokString ">=",TokSymbol ",",TokSymbol ";",TokString "<=",TokSymbol ",",TokSymbol ";",TokString "+",TokSymbol ",",TokSymbol ";",TokString "-",TokSymbol ",",TokSymbol ";",TokString "*",TokSymbol ",",TokSymbol ";",TokString "/",TokSymbol ",",TokSymbol ";",TokString ">",TokSymbol ",",TokSymbol ";",TokString "<",TokSymbol ",",TokSymbol ";",TokString ":",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "operatorVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "operatorVar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "op",TokSymbol "<-",TokIdent "satisfyToken",TokIdent "isOp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EVar",TokIdent "op",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "isOp",TokSymbol "(",TokTypeIdent "TokOperator",TokIdent "s",TokSymbol ")",TokSymbol "=",TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokIdent "isOp",TokSymbol "_",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "name",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "name",TokSymbol "=",TokIdent "try",TokIdent "parenOp",TokOperator "<|>",TokIdent "ident",TokOperator "<|>",TokIdent "symbolOp",TokNewline,TokIdent "parenOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "parenOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "op",TokSymbol "<-",TokIdent "symbolOp",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokIdent "op",TokVRBrace,TokNewline,TokIdent "symbolOp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "symbolOp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tok",TokSymbol "<-",TokIdent "satisfy",TokIdent "isSymbol",TokSymbol ";",TokKeyword "case",TokIdent "tok",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokIdent "s",TokArrow,TokKeyword "return",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isSymbol",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isSymbol",TokSymbol "(",TokTypeIdent "TokSymbol",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isSymbol",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "bracedBlock",TokSymbol "::",TokTypeIdent "Parser",TokIdent "a",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokIdent "a",TokSymbol "]",TokNewline,TokIdent "bracedBlock",TokIdent "p",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "go",TokNumber 1,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "go",TokNumber 0,TokIdent "acc",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "reverse",TokIdent "acc",TokSymbol ")",TokSymbol ";",TokIdent "go",TokIdent "n",TokIdent "acc",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokSymbol",TokString "{",TokArrow,TokIdent "symbol",TokString "{",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "}",TokArrow,TokIdent "symbol",TokString "}",TokOperator ">>",TokIdent "go",TokSymbol "(",TokIdent "n",TokOperator "-",TokNumber 1,TokSymbol ")",TokIdent "acc",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "x",TokSymbol "<-",TokIdent "p",TokSymbol ";",TokIdent "go",TokIdent "n",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "acc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "symbolToken",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Token",TokNewline,TokIdent "symbolToken",TokIdent "tok",TokSymbol "=",TokIdent "satisfyToken",TokIdent "match",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "match",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokIdent "tok",TokSymbol "=",TokTypeIdent "Just",TokIdent "t",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/CaseParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.CaseParserCore (caseExprCore) where

import AST.Expr
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

caseExprCore :: Parser Expr -> Parser Expr
caseExprCore expr = do
  keyword "case"
  scrut <- expr
  keyword "of"
  alts <-
    bracesV (sepBy1 (caseAlt expr) caseSep)
      <|> sepBy1 (caseAlt expr) caseSep
  return (ECase scrut alts)

caseSep :: Parser ()
caseSep =
  symbol ";"
    <|> void (token TokNewline) -- newline
    <|> lookAhead patternStart

newline :: Parser ()
newline = void (token TokNewline)

caseAlt :: Parser Expr -> Parser CaseAlt
caseAlt expr = do
  skipNewlines
  pat <- pattern
  guards <- many (guardExpr expr)
  -- guards <- many (caseGuard expr)
  case guards of
    [] -> do
      token TokArrow
      body <- expr
      return (CaseAlt pat body)
    _ ->
      return (CaseAltGuard pat guards)

guardExpr :: Parser Expr -> Parser (Expr, Expr)
guardExpr expr = do
  skipNewlines
  symbol "|"
  cond <- expr
  token TokArrow
  body <- expr
  return (cond, body)

caseGuard :: Parser Expr -> Parser (Expr, Expr)
caseGuard expr = do
  -- optional (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< caseGuard next token: " ++ show t)
  symbol "|"
  cond <- expr
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  -- token TokArrow
  body <- expr
  -- optional (token TokNewline)
  return (cond, body)

caseAltSimple :: Parser Expr -> Parser CaseAlt
caseAltSimple expr = do
  t <- lookAhead anyToken
  myTrace ("<< caseAltSimple next token: " ++ show t)
  pat <- pattern
  token TokArrow
  body <- expr
  return (CaseAlt pat body)

unguarded :: Pattern -> Parser Expr -> Parser CaseAlt
unguarded pat expr = do
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- expr
  return (CaseAlt pat body)

guarded :: Pattern -> Parser Expr -> Parser CaseAlt
guarded pat expr = do
  guards <- many1 (try (guardExpr expr))
  return (CaseAltGuard pat guards)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "caseExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "caseExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "case",TokSymbol ";",TokIdent "scrut",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "of",TokSymbol ";",TokIdent "alts",TokSymbol "<-",TokVLBrace,TokIdent "bracesV",TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "return",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "caseSep",TokSymbol "=",TokVLBrace,TokIdent "symbol",TokString ";",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "lookAhead",TokIdent "patternStart",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "caseAlt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokIdent "guards",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseGuard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseAltSimple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unguarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "many1",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "caseExprCore"
<< declBody: return DeclModule "Parser.Expr.CaseParserCore" (Just [ExportVar "caseExprCore"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "caseExprCore"
<< decl parser called
<< decl dispatch: TokIdent "caseExprCore"
<< funDecl: next token=TokIdent "caseExprCore"
<< funClause: next token=TokIdent "caseExprCore"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "caseExprCore"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parseTypeCore: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< parsed type signature: caseExprCore :: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< returning DeclTypeSig: DeclTypeSig "caseExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< declBody: return DeclTypeSig "caseExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< decl next token: TokIdent "caseExprCore"
<< decl parser called
<< decl dispatch: TokIdent "caseExprCore"
<< funDecl: next token=TokIdent "caseExprCore"
<< funClause: next token=TokIdent "caseExprCore"
<< patternParser: (pAs <|> makeCons)PApp (PVar "expr") []
<< funClause: args=[PApp (PVar "expr") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "case"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "case"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "scrut"
<< pattern1: (pAs <|> makeCons)PApp (PVar "scrut") []
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "of"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "of"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "alts"
<< pattern1: (pAs <|> makeCons)PApp (PVar "alts") []
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< expr dispatch: TokIdent "alts"
<< exprCore next token: TokIdent "alts"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol "<-"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "keyword"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "caseExprCore" [FunClause [PApp (PVar "expr") []] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Expr.CaseParserCore" (Just [ExportVar "caseExprCore"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "caseExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))),DeclFunGroup "caseExprCore" [FunClause [PApp (PVar "expr") []] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "keyword",TokString "case",TokSymbol ";",TokIdent "scrut",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "of",TokSymbol ";",TokIdent "alts",TokSymbol "<-",TokVLBrace,TokIdent "bracesV",TokSymbol "(",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy1",TokSymbol "(",TokIdent "caseAlt",TokIdent "expr",TokSymbol ")",TokIdent "caseSep",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "return",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "caseSep",TokSymbol "=",TokVLBrace,TokIdent "symbol",TokString ";",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "lookAhead",TokIdent "patternStart",TokVRBrace,TokVRBrace,TokNewline,TokIdent "newline",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "newline",TokSymbol "=",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokNewline,TokIdent "caseAlt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAlt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "guards",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "case",TokIdent "guards",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "guardExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "guardExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseGuard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Expr",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "caseGuard",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseGuard next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "cond",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "caseAltSimple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "caseAltSimple",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< caseAltSimple next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unguarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "unguarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guarded",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "CaseAlt",TokNewline,TokIdent "guarded",TokIdent "pat",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "guards",TokSymbol "<-",TokIdent "many1",TokSymbol "(",TokIdent "try",TokSymbol "(",TokIdent "guardExpr",TokIdent "expr",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "CaseAltGuard",TokIdent "pat",TokIdent "guards",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/DoParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.DoParserCore (doExprCore) where

import AST.Expr
import Control.Applicative (empty, many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser
import Utils.MyTrace

doExprCore :: Parser Expr -> Parser Expr
doExprCore expr = do
  keyword "do"
  bracesV3 $ do
    stmts <- doBlock expr
    -- many (token TokNewline)
    return (EDo stmts)

doBlock :: Parser Expr -> Parser [Stmt]
doBlock expr = do
  sepBy (doStmt expr) doSemi

doStmt :: Parser Expr -> Parser Stmt
doStmt expr = do
  many (token TokNewline)
  t <- lookAhead anyToken
  myTrace ("<< doStmt next token: " ++ show t)
  try (bindStmt expr)
    <|> try (letStmt expr)
    <|> ExprStmt <$> expr

bindStmt :: Parser Expr -> Parser Stmt
bindStmt expr = do
  pat <- pattern
  symbol "<-"
  e <- expr
  return (Bind pat e)

letStmt :: Parser Expr -> Parser Stmt
letStmt expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ";")
  t <- lookAhead anyToken
  myTrace ("<< letStmt:binding next token: " ++ show t)
  case t of
    TokKeyword "in" -> empty
    _ -> return (LetStmt binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)

doSemi :: Parser ()
doSemi = do
  -- optional (token TokNewline)
  symbol ";"


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "doExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "doExprCore",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "do",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "stmts",TokSymbol "<-",TokIdent "doBlock",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "doBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sepBy",TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokIdent "doSemi",TokVRBrace,TokNewline,TokIdent "doStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokTypeIdent "ExprStmt",TokOperator "<$>",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "in",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "doSemi",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "doSemi",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "symbol",TokString ";",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "doExprCore"
<< declBody: return DeclModule "Parser.Expr.DoParserCore" (Just [ExportVar "doExprCore"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "doExprCore"
<< decl parser called
<< decl dispatch: TokIdent "doExprCore"
<< funDecl: next token=TokIdent "doExprCore"
<< funClause: next token=TokIdent "doExprCore"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "doExprCore"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parseTypeCore: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< parsed type signature: doExprCore :: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< returning DeclTypeSig: DeclTypeSig "doExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< declBody: return DeclTypeSig "doExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< decl next token: TokIdent "doExprCore"
<< decl parser called
<< decl dispatch: TokIdent "doExprCore"
<< funDecl: next token=TokIdent "doExprCore"
<< funClause: next token=TokIdent "doExprCore"
<< patternParser: (pAs <|> makeCons)PApp (PVar "expr") []
<< funClause: args=[PApp (PVar "expr") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "keyword"
<< pattern1: (pAs <|> makeCons)PApp (PVar "keyword") [PString "do"]
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "do"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "bracesV3"
<< pattern1: (pAs <|> makeCons)PApp (PVar "bracesV3") []
<< expr dispatch: TokIdent "bracesV3"
<< exprCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokIdent "bracesV3"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokKeyword "do"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "keyword"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "doExprCore" [FunClause [PApp (PVar "expr") []] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Expr.DoParserCore" (Just [ExportVar "doExprCore"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "doExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))),DeclFunGroup "doExprCore" [FunClause [PApp (PVar "expr") []] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "keyword",TokString "do",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "stmts",TokSymbol "<-",TokIdent "doBlock",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "doBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokNewline,TokIdent "doBlock",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sepBy",TokSymbol "(",TokIdent "doStmt",TokIdent "expr",TokSymbol ")",TokIdent "doSemi",TokVRBrace,TokNewline,TokIdent "doStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "doStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "many",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< doStmt next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokSymbol "(",TokIdent "bindStmt",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letStmt",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokTypeIdent "ExprStmt",TokOperator "<$>",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "bindStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letStmt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Stmt",TokNewline,TokIdent "letStmt",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letStmt:binding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "in",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "doSemi",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "doSemi",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "symbol",TokString ";",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprCore
  ( exprCore,
    exprLevel1Core,
    exprLevel2Core,
    exprLevel3Core,
    appExprCore,
    atomCore,
    atomBaseCore,
    parenExprCore,
    tupleExprCore,
    oPsectionCore,
    pRecordExpr,
    lambdaExpr,
  )
where

import AST.Expr
import AST.Expr (BinOp (..), Expr (..))
import Control.Applicative (empty, many, (<|>))
import Control.Monad (guard)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.PatternParser (pattern)
import Parser.SQL.SQLParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace

pRecordExpr :: Parser Expr
pRecordExpr = do
  symbol "{"
  fields <- sepBy1 field (symbol ",")
  symbol "}"
  return (ERecord fields)

field :: Parser (String, Expr)
field = do
  name <- ident
  symbol "="
  value <- exprCore
  return (name, value)

-- ============================================
--  lambdaExprÅiExprCore Ç…ñﬂÇ∑Åj
-- ============================================

lambdaExpr :: Parser Expr
lambdaExpr = do
  symbol "\\"
  arg <- pattern
  tokenIs (\case TokArrow -> Just (); _ -> Nothing)
  body <- exprCore
  return (ELam arg body)

-- ============================================
--  exprCoreÅièÉêàÇ»éÆÉpÅ[ÉTÅ[Åj
-- ============================================

exprCore :: Parser Expr
exprCore = do
  t <- lookAhead anyToken
  myTrace ("<< exprCore next token: " ++ show t)
  -- guard (t /= TokKeyword "let")
  try lambdaExpr
    -- <|> void (token TokEllipsis >> return EPlaceholder)
    <|> try binOpExprCore
    <|> try parseSQL

-- <|> exprLevel1Core

-- ===== ââéZéqäKëw =====

binOpExprCore :: Parser Expr
binOpExprCore = exprCmpCore

exprCmpCore :: Parser Expr
exprCmpCore = chainl1 exprLevel1Core (binOp [">", "<", ">=", "<=", "==", "/="])

exprLevel1Core :: Parser Expr
exprLevel1Core = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< exprLevel1Core next token: " ++ show t)
  chainl1 exprLevel2Core (binOp ["+", "-", "++", ":"])

exprLevel2Core :: Parser Expr
exprLevel2Core = chainl1 exprLevel3Core (binOp ["*", "/"])

exprLevel3Core :: Parser Expr
exprLevel3Core = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< exprLevel3Core next token: " ++ show t)
  try lambdaExpr
    <|> appExprCore

-- ============================================
--  ä÷êîìKóp
-- ============================================

appExprCore :: Parser Expr
appExprCore = do
  f <- atomCore
  args <- many atomCore
  return (foldl EApp f args)

-- ============================================
--  atom
-- ============================================

atomCore :: Parser Expr
atomCore =
  parens parenExprCore
    <|> atomBaseCore

parenExprCore :: Parser Expr
parenExprCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< parenExprCore next token: " ++ show t)
  try oPsectionCore
    <|> try tupleExprCore
    <|> exprCore

tupleExprCore :: Parser Expr
tupleExprCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< tupleExprCore next token: " ++ show t)
  e1 <- exprCore
  symbol ","
  es <- exprCore `sepBy1` symbol ","
  return (ETuple (e1 : es))

oPsectionCore :: Parser Expr
oPsectionCore = do
  -- t <- lookAhead anyToken
  -- myTrace ("<< oPsectionCore next token: " ++ show t)
  try (EOpSectionL <$> operator <*> exprCore)
    <|> (EOpSectionR <$> exprCore <*> operator)

atomBaseCore :: Parser Expr
atomBaseCore = do
  t <- lookAhead anyToken
  myTrace ("<< atomBaseCore next token: " ++ show t)

  --  case t of
  --    TokKeyword "let" -> empty
  --    _ ->
  lambdaExpr
    <|> EVar <$> ident
    <|> EInt <$> int
    <|> EVarType <$> typeIdent
    <|> (ellipsis >> return EPlaceholder)
    <|> elistExpr
    <|> EString <$> stringLiteralExpr
    <|> EChar <$> charLiteralExpr
    <|> pRecordExpr
    <|> operatorVar
    <|> emptyListExpr

elistExpr :: Parser Expr
elistExpr = do
  symbol "["
  elems <- exprCore `sepBy` symbol ","
  symbol "]"
  return (EList elems)

ellipsis :: Parser ()
ellipsis = tokenIs (\t -> if t == TokEllipsis then Just () else Nothing)

emptyListExpr :: Parser Expr
emptyListExpr = do
  symbol "["
  symbol "]"
  return (EList [])


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokVLBrace,TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprLevel1Core",TokSymbol ",",TokIdent "exprLevel2Core",TokSymbol ",",TokIdent "exprLevel3Core",TokSymbol ",",TokIdent "appExprCore",TokSymbol ",",TokIdent "atomCore",TokSymbol ",",TokIdent "atomBaseCore",TokSymbol ",",TokIdent "parenExprCore",TokSymbol ",",TokIdent "tupleExprCore",TokSymbol ",",TokIdent "oPsectionCore",TokSymbol ",",TokIdent "pRecordExpr",TokSymbol ",",TokIdent "lambdaExpr",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "guard",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "pRecordExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pRecordExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "{",TokSymbol ";",TokIdent "fields",TokSymbol "<-",TokIdent "sepBy1",TokIdent "field",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERecord",TokIdent "fields",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "field",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "field",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "value",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "value",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "lambdaExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "lambdaExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "\\",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "parseSQL",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binOpExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSymbol "=",TokIdent "exprCmpCore",TokNewline,TokIdent "exprCmpCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel1Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel1Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "chainl1",TokIdent "exprLevel2Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol ",",TokString ":",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprLevel2Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel3Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel3Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokIdent "appExprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "appExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "atomCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSymbol "=",TokVLBrace,TokIdent "parens",TokIdent "parenExprCore",TokVLBrace,TokOperator "<|>",TokIdent "atomBaseCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parenExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "oPsectionCore",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "tupleExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tupleExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "es",TokSymbol "<-",TokIdent "exprCore",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokOperator ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "oPsectionCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<$>",TokIdent "operator",TokOperator "<*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<$>",TokIdent "exprCore",TokOperator "<*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "atomBaseCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokTypeIdent "EVar",TokOperator "<$>",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EInt",TokOperator "<$>",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EVarType",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "ellipsis",TokOperator ">>",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "elistExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EChar",TokOperator "<$>",TokIdent "charLiteralExpr",TokSymbol ";",TokOperator "<|>",TokIdent "pRecordExpr",TokSymbol ";",TokOperator "<|>",TokIdent "operatorVar",TokSymbol ";",TokOperator "<|>",TokIdent "emptyListExpr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "elistExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "elistExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "elems",TokSymbol "<-",TokIdent "exprCore",TokUnknown '`',TokIdent "sepBy`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ellipsis",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "ellipsis",TokSymbol "=",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "()",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "emptyListExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "emptyListExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "exprCore"
<< exportItem: next token=TokIdent "exprLevel1Core"
<< exportItem: next token=TokIdent "exprLevel2Core"
<< exportItem: next token=TokIdent "exprLevel3Core"
<< exportItem: next token=TokIdent "appExprCore"
<< exportItem: next token=TokIdent "atomCore"
<< exportItem: next token=TokIdent "atomBaseCore"
<< exportItem: next token=TokIdent "parenExprCore"
<< exportItem: next token=TokIdent "tupleExprCore"
<< exportItem: next token=TokIdent "oPsectionCore"
<< exportItem: next token=TokIdent "pRecordExpr"
<< exportItem: next token=TokIdent "lambdaExpr"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprCore" (Just [ExportVar "exprCore",ExportVar "exprLevel1Core",ExportVar "exprLevel2Core",ExportVar "exprLevel3Core",ExportVar "appExprCore",ExportVar "atomCore",ExportVar "atomBaseCore",ExportVar "parenExprCore",ExportVar "tupleExprCore",ExportVar "oPsectionCore",ExportVar "pRecordExpr",ExportVar "lambdaExpr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "guard"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.SQL.SQLParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "pRecordExpr"
<< decl parser called
<< decl dispatch: TokIdent "pRecordExpr"
<< funDecl: next token=TokIdent "pRecordExpr"
<< funClause: next token=TokIdent "pRecordExpr"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "pRecordExpr"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parsed type signature: pRecordExpr :: TApp (TCon "Parser") (TCon "Expr")
<< returning DeclTypeSig: DeclTypeSig "pRecordExpr" (TApp (TCon "Parser") (TCon "Expr"))
<< declBody: return DeclTypeSig "pRecordExpr" (TApp (TCon "Parser") (TCon "Expr"))
<< decl next token: TokIdent "pRecordExpr"
<< decl parser called
<< decl dispatch: TokIdent "pRecordExpr"
<< funDecl: next token=TokIdent "pRecordExpr"
<< funClause: next token=TokIdent "pRecordExpr"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "{"]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "{"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "fields"
<< pattern1: (pAs <|> makeCons)PApp (PVar "fields") []
<< expr dispatch: TokIdent "sepBy1"
<< exprCore next token: TokIdent "sepBy1"
<< atomBaseCore next token: TokIdent "sepBy1"
<< atomBaseCore next token: TokIdent "field"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ","
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ","
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ","
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "}"]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "}"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokIdent "fields"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokIdent "fields"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokTypeIdent "ERecord"
<< atomBaseCore next token: TokIdent "fields"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "field"
<< funClauseWithName: next token=TokIdent "field"
<< declBody: return DeclFunGroup "pRecordExpr" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "symbol") (EString "{")),Bind (PApp (PVar "fields") []) (EApp (EApp (EVar "sepBy1") (EVar "field")) (EApp (EVar "symbol") (EString ","))),ExprStmt (EApp (EVar "symbol") (EString "}")),ExprStmt (EReturn (EApp (EVarType "ERecord") (EVar "fields")))])) Nothing]
<< decl next token: TokIdent "field"
<< decl parser called
<< decl dispatch: TokIdent "field"
<< funDecl: next token=TokIdent "field"
<< funClause: next token=TokIdent "field"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "field"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])
<< parsed type signature: field :: TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])
<< returning DeclTypeSig: DeclTypeSig "field" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"]))
<< declBody: return DeclTypeSig "field" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"]))
<< decl next token: TokIdent "field"
<< decl parser called
<< decl dispatch: TokIdent "field"
<< funDecl: next token=TokIdent "field"
<< funClause: next token=TokIdent "field"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "name"
<< pattern1: (pAs <|> makeCons)PApp (PVar "name") []
<< expr dispatch: TokIdent "ident"
<< exprCore next token: TokIdent "ident"
<< atomBaseCore next token: TokIdent "ident"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "="]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "="
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "value"
<< pattern1: (pAs <|> makeCons)PApp (PVar "value") []
<< expr dispatch: TokIdent "exprCore"
<< exprCore next token: TokIdent "exprCore"
<< atomBaseCore next token: TokIdent "exprCore"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "name"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "value"
<< atomBaseCore next token: TokIdent "value"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "lambdaExpr"
<< funClauseWithName: next token=TokIdent "lambdaExpr"
<< declBody: return DeclFunGroup "field" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "name") []) (EVar "ident"),ExprStmt (EApp (EVar "symbol") (EString "=")),Bind (PApp (PVar "value") []) (EVar "exprCore"),ExprStmt (EReturn (ETuple [EVar "name",EVar "value"]))])) Nothing]
<< decl next token: TokIdent "lambdaExpr"
<< decl parser called
<< decl dispatch: TokIdent "lambdaExpr"
<< funDecl: next token=TokIdent "lambdaExpr"
<< funClause: next token=TokIdent "lambdaExpr"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "lambdaExpr"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parsed type signature: lambdaExpr :: TApp (TCon "Parser") (TCon "Expr")
<< returning DeclTypeSig: DeclTypeSig "lambdaExpr" (TApp (TCon "Parser") (TCon "Expr"))
<< declBody: return DeclTypeSig "lambdaExpr" (TApp (TCon "Parser") (TCon "Expr"))
<< decl next token: TokIdent "lambdaExpr"
<< decl parser called
<< decl dispatch: TokIdent "lambdaExpr"
<< funDecl: next token=TokIdent "lambdaExpr"
<< funClause: next token=TokIdent "lambdaExpr"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "symbol"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString "\\"]
<< expr dispatch: TokIdent "symbol"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString "\\"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "arg"
<< pattern1: (pAs <|> makeCons)PApp (PVar "arg") []
<< expr dispatch: TokIdent "pattern"
<< exprCore next token: TokIdent "pattern"
<< atomBaseCore next token: TokIdent "pattern"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "tokenIs"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tokenIs") []
<< expr dispatch: TokIdent "tokenIs"
<< exprCore next token: TokIdent "tokenIs"
<< atomBaseCore next token: TokIdent "tokenIs"
<< exprCore next token: TokSymbol "\\"
<< atomBaseCore next token: TokSymbol "\\"
<< exprCore next token: TokSymbol "\\"
<< atomBaseCore next token: TokSymbol "\\"
<< exprCore next token: TokSymbol "\\"
<< atomBaseCore next token: TokSymbol "\\"
<< atomBaseCore next token: TokSymbol "("
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "symbol"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "lambdaExpr" [FunClause [] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Expr.ExprCore" (Just [ExportVar "exprCore",ExportVar "exprLevel1Core",ExportVar "exprLevel2Core",ExportVar "exprLevel3Core",ExportVar "appExprCore",ExportVar "atomCore",ExportVar "atomBaseCore",ExportVar "parenExprCore",ExportVar "tupleExprCore",ExportVar "oPsectionCore",ExportVar "pRecordExpr",ExportVar "lambdaExpr"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "guard"]},DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]},DeclImport {importQualified = False, importModule = "Parser.SQL.SQLParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "pRecordExpr" (TApp (TCon "Parser") (TCon "Expr")),DeclFunGroup "pRecordExpr" [FunClause [] Nothing (Just (EDo [ExprStmt (EApp (EVar "symbol") (EString "{")),Bind (PApp (PVar "fields") []) (EApp (EApp (EVar "sepBy1") (EVar "field")) (EApp (EVar "symbol") (EString ","))),ExprStmt (EApp (EVar "symbol") (EString "}")),ExprStmt (EReturn (EApp (EVarType "ERecord") (EVar "fields")))])) Nothing],DeclTypeSig "field" (TApp (TCon "Parser") (TTuple [TCon "String",TCon "Expr"])),DeclFunGroup "field" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "name") []) (EVar "ident"),ExprStmt (EApp (EVar "symbol") (EString "=")),Bind (PApp (PVar "value") []) (EVar "exprCore"),ExprStmt (EReturn (ETuple [EVar "name",EVar "value"]))])) Nothing],DeclTypeSig "lambdaExpr" (TApp (TCon "Parser") (TCon "Expr")),DeclFunGroup "lambdaExpr" [FunClause [] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "symbol",TokString "\\",TokSymbol ";",TokIdent "arg",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokKeyword "case",TokTypeIdent "TokArrow",TokArrow,TokTypeIdent "Just",TokSymbol "()",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokSymbol ")",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELam",TokIdent "arg",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< exprCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "binOpExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokIdent "parseSQL",TokVRBrace,TokVRBrace,TokNewline,TokIdent "binOpExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "binOpExprCore",TokSymbol "=",TokIdent "exprCmpCore",TokNewline,TokIdent "exprCmpCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprCmpCore",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel1Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString ">",TokSymbol ",",TokString "<",TokSymbol ",",TokString ">=",TokSymbol ",",TokString "<=",TokSymbol ",",TokString "==",TokSymbol ",",TokString "/=",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel1Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel1Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "chainl1",TokIdent "exprLevel2Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "+",TokSymbol ",",TokString "-",TokSymbol ",",TokString "++",TokSymbol ",",TokString ":",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "exprLevel2Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel2Core",TokSymbol "=",TokIdent "chainl1",TokIdent "exprLevel3Core",TokSymbol "(",TokIdent "binOp",TokSymbol "[",TokString "*",TokSymbol ",",TokString "/",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "exprLevel3Core",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprLevel3Core",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokIdent "appExprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "appExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "appExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "atomCore",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "atomCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl",TokTypeIdent "EApp",TokIdent "f",TokIdent "args",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "atomCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomCore",TokSymbol "=",TokVLBrace,TokIdent "parens",TokIdent "parenExprCore",TokVLBrace,TokOperator "<|>",TokIdent "atomBaseCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parenExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parenExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokIdent "oPsectionCore",TokVLBrace,TokOperator "<|>",TokIdent "try",TokIdent "tupleExprCore",TokSymbol ";",TokOperator "<|>",TokIdent "exprCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "tupleExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "tupleExprCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "es",TokSymbol "<-",TokIdent "exprCore",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ETuple",TokSymbol "(",TokIdent "e1",TokOperator ":",TokIdent "es",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "oPsectionCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "oPsectionCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "try",TokSymbol "(",TokTypeIdent "EOpSectionL",TokOperator "<$>",TokIdent "operator",TokOperator "<*",TokOperator ">",TokIdent "exprCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokTypeIdent "EOpSectionR",TokOperator "<$>",TokIdent "exprCore",TokOperator "<*",TokOperator ">",TokIdent "operator",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "atomBaseCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "atomBaseCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< atomBaseCore next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "lambdaExpr",TokVLBrace,TokOperator "<|>",TokTypeIdent "EVar",TokOperator "<$>",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EInt",TokOperator "<$>",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EVarType",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "ellipsis",TokOperator ">>",TokKeyword "return",TokTypeIdent "EPlaceholder",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "elistExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokSymbol ";",TokOperator "<|>",TokTypeIdent "EChar",TokOperator "<$>",TokIdent "charLiteralExpr",TokSymbol ";",TokOperator "<|>",TokIdent "pRecordExpr",TokSymbol ";",TokOperator "<|>",TokIdent "operatorVar",TokSymbol ";",TokOperator "<|>",TokIdent "emptyListExpr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "elistExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "elistExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "elems",TokSymbol "<-",TokIdent "exprCore",TokUnknown '`',TokIdent "sepBy`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ellipsis",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "ellipsis",TokSymbol "=",TokIdent "tokenIs",TokSymbol "(",TokSymbol "\\",TokIdent "t",TokArrow,TokKeyword "if",TokIdent "t",TokSymbol "==",TokTypeIdent "TokEllipsis",TokKeyword "then",TokTypeIdent "Just",TokSymbol "()",TokKeyword "else",TokTypeIdent "Nothing",TokSymbol ")",TokNewline,TokIdent "emptyListExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "emptyListExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "[",TokSymbol ";",TokIdent "symbol",TokString "]",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprExtensions.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprExtensions
  ( expr,
    exprTop,
    exprSeq,
    exprSep,
    letExpr,
    ifExpr,
    returnExpr,
    forExpr,
    postfix,
    skipNewlines,
  )
where

-- import Expr.CaseParserCore (caseExpr)

-- import Expr.DoParserCore (doExpr)

-- import Expr.ListParserCore (listExpr)

import AST.Expr
-- import AST.Decl
import AST.Pattern
import Control.Applicative (empty, many, optional, some, (<|>))
-- (keyword) -- , whereClause)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.CaseParserCore (caseExprCore)
import Parser.Expr.DoParserCore (doExprCore)
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ListParserCore (listExprCore)
import Parser.Expr.PatternParser (pattern)
import Parser.SQL.SQLParser
import Utils.MyTrace

expr :: Parser Expr
expr = do
  e <- exprDispatch
  postfix e
  where
    -- Ç∑Ç◊ÇƒÇÃç\ï∂ÇÃì¸å˚
    exprDispatch = do
      t <- lookAhead anyToken
      myTrace ("<< expr dispatch: " ++ show t)
      case t of
        TokKeyword "do" -> doExprCore expr
        TokKeyword "case" -> caseExprCore expr
        -- TokKeyword "let" -> (try letExpr <|> pLetExpr)
        TokKeyword "let" -> letBlock
        TokKeyword "if" -> ifExpr
        TokKeyword "for" -> forExpr
        TokKeyword "return" -> returnExpr
        TokKeyword "sql" -> parseSQL
        TokSymbol "[" -> listExprCore expr
        _ -> exprCore

letBlock :: Parser Expr
letBlock = do
  t <- lookAhead anyToken
  myTrace ("<< letBlock next token: " ++ show t)
  try letExpr <|> pLetExpr

-- letBlock = try pLetExpr <|> letExpr

{-}
-- å„íuç\ï∂Åiwhere Ç»Ç«Åj
postfix :: Expr -> Parser Expr
postfix e =
  try
    ( do
        skipNewlines
        -- t <- lookAhead anyToken
        -- myTrace ("<< postfix next token: " ++ show t)
        binds <- whereClause
        postfix (EWhere e binds)
    )
    <|> return e
-}

postfix :: Expr -> Parser Expr
postfix e = do
  skipNewlines
  mbBinds <- whereClause
  case mbBinds of
    Just binds -> postfix (EWhere e binds)
    Nothing -> return e

whereClause :: Parser (Maybe [Binding])
whereClause =
  try (keyword "where" >> bindings >>= \bs -> return (Just bs))
    <|> return Nothing

{-}
bindings = do
  b <- binding
  bs <- many binding
  return (b : bs)
-}
bindings :: Parser [Binding]
bindings = do
  skipNewlines
  b <- binding
  bs <- many (skipSeparators >> binding)
  return (b : bs)

-- bindings :: Parser [Binding]
-- bindings = some binding

binding :: Parser Binding
binding = try valueBinding <|> funBinding

{-}
binding :: Parser Binding
binding = do
  pat <- pattern
  _ <- symbol "="   -- Ç±Ç±Ç≈ '=' Ç™ñ≥ÇØÇÍÇŒ binding ÇÕé∏îsÇ∑ÇÈ
  val <- expr
  return (pat, val)
-}
-- ============================================
--  exprTop / exprSeq
-- ============================================

exprTop :: Parser Expr
exprTop = try exprSeq <|> expr

exprSeq :: Parser Expr
exprSeq = do
  es <- sepEndBy1 (try expr) exprSep
  return $ if length es == 1 then head es else ESeq es

exprSep :: Parser ()
exprSep = skipMany1 (symbol ";" <|> newline)

-- ============================================
--  let / if / return / for
-- ============================================
def :: Parser (Pattern, Expr)
def = do
  p <- pattern
  symbol "="
  e <- expr
  return (p, e)

ifExpr :: Parser Expr
ifExpr = do
  keyword "if"
  cond <- expr
  keyword "then"
  th <- expr
  keyword "else"
  el <- expr
  return (EIf cond th el)

returnExpr :: Parser Expr
returnExpr = do
  keyword "return"
  e <- expr
  return (EReturn e)

forExpr :: Parser Expr
forExpr = do
  keyword "for"
  qs <- sepBy1 qualifier (symbol ",")
  token TokArrow
  body <- expr
  return (EListComp body qs)

qualifier :: Parser Qualifier
qualifier =
  try genQualifier
    <|> guardQualifier

genQualifier :: Parser Qualifier
genQualifier = do
  pat <- pattern
  keyword "in"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Qualifier
guardQualifier = QGuard <$> expr

{-}
funDecl :: Parser Decl
funDecl = do
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  return (FunDecl name args body)
-}

-- binding = try funBinding <|> valueBinding
{-}
funBinding :: Parser Binding
funBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  args <- many pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (PApp (PVar name) args, body)
-}

funBinding :: Parser Binding
funBinding = do
  optional newline
  t <- lookAhead anyToken
  myTrace ("<< funBinding next token: " ++ show t)
  name <- ident
  -- éüÇÃÉgÅ[ÉNÉìÇ™ "=" Ç»ÇÁ funBinding Ç≈ÇÕÇ»Ç¢
  next <- lookAhead anyToken
  if next == TokOperator "="
    then empty -- Å© guard ÇÃë„ÇÌÇËÇ… empty ÇégÇ§
    else return ()
  args <- many pattern
  symbol "="
  body <- expr
  return (PApp (PVar name) args, body)

valueBinding :: Parser Binding
valueBinding = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< valueBinding next token: " ++ show t)
  pat <- pattern
  symbol "="
  body <- expr
  -- optional (newline)
  return (pat, body)

{-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  -- myTrace ("<< letExpr")
  binds <- bindingsBlock
  optional (newline)
  mIn <- optional (keyword "in")
  optional (newline)
  case mIn of
    Just _ -> do
      body <- expr
      return (ELet binds body)
    Nothing ->
      return (ELet binds (EVar "__unit__"))
-}
letExpr :: Parser Expr
letExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< letExpr next token: " ++ show t)
  binds <- bindingsBlock
  optional newline
  bracesV3 $ do
    mIn <- optional (keyword "in")
    optional newline
    case mIn of
      Just _ -> do
        body <- expr
        return (ELetBlock binds body)
      Nothing ->
        if null binds
          then empty -- Å© Ç±ÇÍÇ™ê≥ÇµÇ¢
          else return (ELetBlock binds (EVar "__unit__"))

{-}
  case mIn of
    Just _ -> do
      body <- expr
      return (ELetBlock binds body)
    Nothing ->
      return (ELetBlock binds (EVar "__unit__"))
-}

pLetExpr :: Parser Expr
pLetExpr = do
  keyword "let"
  t <- lookAhead anyToken
  myTrace ("<< pLetExpr next token: " ++ show t)
  pat <- pattern
  symbol "="
  e1 <- expr
  bracesV3 $ do
    keyword "in"
    e2 <- expr
    return (ELet pat e1 e2)

bindingsBlock :: Parser [Binding]
bindingsBlock = do
  -- optional (token TokNewline)
  braces (sepBy binding (symbol ";"))
    <|> sepBy binding (symbol ";")

{-}
whereClause :: Parser [Binding]
whereClause = do
  optional (newline)
  t <- lookAhead anyToken
  myTrace ("<< whereClause next token: " ++ show t)
  keyword "where"
  bindingsBlock
-}


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokVLBrace,TokSymbol "(",TokIdent "expr",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokIdent "letExpr",TokSymbol ",",TokIdent "ifExpr",TokSymbol ",",TokIdent "returnExpr",TokSymbol ",",TokIdent "forExpr",TokSymbol ",",TokIdent "postfix",TokSymbol ",",TokIdent "skipNewlines",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "empty",TokSymbol ",",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokIdent "some",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "CaseParserCore",TokSymbol "(",TokIdent "caseExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "DoParserCore",TokSymbol "(",TokIdent "doExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "expr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokSymbol ";",TokKeyword "where",TokVLBrace,TokSymbol ";",TokIdent "exprDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "do",TokArrow,TokIdent "doExprCore",TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "case",TokArrow,TokIdent "caseExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "let",TokArrow,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "if",TokArrow,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "for",TokArrow,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "return",TokArrow,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "sql",TokArrow,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "[",TokArrow,TokIdent "listExprCore",TokIdent "expr",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "exprCore",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "letBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokIdent "letExpr",TokOperator "<|>",TokIdent "pLetExpr",TokVRBrace,TokNewline,TokIdent "postfix",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokIdent "e",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "mbBinds",TokSymbol "<-",TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokIdent "mbBinds",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "binds",TokArrow,TokIdent "postfix",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "e",TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">>",TokIdent "bindings",TokOperator ">>",TokSymbol "=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindings",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "b",TokSymbol "<-",TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "skipSeparators",TokOperator ">>",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "b",TokOperator ":",TokIdent "bs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "binding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSymbol "=",TokIdent "try",TokIdent "valueBinding",TokOperator "<|>",TokIdent "funBinding",TokNewline,TokIdent "exprTop",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSymbol "=",TokIdent "try",TokIdent "exprSeq",TokOperator "<|>",TokIdent "expr",TokNewline,TokIdent "exprSeq",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "es",TokSymbol "<-",TokIdent "sepEndBy1",TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "if",TokIdent "length",TokIdent "es",TokSymbol "==",TokNumber 1,TokKeyword "then",TokIdent "head",TokIdent "es",TokKeyword "else",TokTypeIdent "ESeq",TokIdent "es",TokVRBrace,TokNewline,TokIdent "exprSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "exprSep",TokSymbol "=",TokIdent "skipMany1",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ifExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "if",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "then",TokSymbol ";",TokIdent "th",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "else",TokSymbol ";",TokIdent "el",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "returnExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "return",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "forExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "for",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "qualifier",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSymbol "=",TokVLBrace,TokIdent "try",TokIdent "genQualifier",TokVLBrace,TokOperator "<|>",TokIdent "guardQualifier",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "funBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokIdent "next",TokSymbol "==",TokTypeIdent "TokOperator",TokString "=",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "valueBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "mIn",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokKeyword "case",TokIdent "mIn",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "null",TokIdent "binds",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pLetExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "e2",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindingsBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "braces",TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "expr"
<< exportItem: next token=TokIdent "exprTop"
<< exportItem: next token=TokIdent "exprSeq"
<< exportItem: next token=TokIdent "exprSep"
<< exportItem: next token=TokIdent "letExpr"
<< exportItem: next token=TokIdent "ifExpr"
<< exportItem: next token=TokIdent "returnExpr"
<< exportItem: next token=TokIdent "forExpr"
<< exportItem: next token=TokIdent "postfix"
<< exportItem: next token=TokIdent "skipNewlines"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprExtensions" (Just [ExportVar "expr",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep",ExportVar "letExpr",ExportVar "ifExpr",ExportVar "returnExpr",ExportVar "forExpr",ExportVar "postfix",ExportVar "skipNewlines"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.CaseParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "caseExprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.DoParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "doExprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ListParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "listExprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.SQL.SQLParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "expr"
<< decl parser called
<< decl dispatch: TokIdent "expr"
<< funDecl: next token=TokIdent "expr"
<< funClause: next token=TokIdent "expr"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "expr"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parsed type signature: expr :: TApp (TCon "Parser") (TCon "Expr")
<< returning DeclTypeSig: DeclTypeSig "expr" (TApp (TCon "Parser") (TCon "Expr"))
<< declBody: return DeclTypeSig "expr" (TApp (TCon "Parser") (TCon "Expr"))
<< decl next token: TokIdent "expr"
<< decl parser called
<< decl dispatch: TokIdent "expr"
<< funDecl: next token=TokIdent "expr"
<< funClause: next token=TokIdent "expr"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "e"
<< pattern1: (pAs <|> makeCons)PApp (PVar "e") []
<< expr dispatch: TokIdent "exprDispatch"
<< exprCore next token: TokIdent "exprDispatch"
<< atomBaseCore next token: TokIdent "exprDispatch"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "postfix"
<< pattern1: (pAs <|> makeCons)PApp (PVar "postfix") [PVar "e"]
<< expr dispatch: TokIdent "postfix"
<< exprCore next token: TokIdent "postfix"
<< atomBaseCore next token: TokIdent "postfix"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "where"
<< expr dispatch: TokKeyword "where"
<< exprCore next token: TokKeyword "where"
<< atomBaseCore next token: TokKeyword "where"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "e"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "expr" [FunClause [] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Expr.ExprExtensions" (Just [ExportVar "expr",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep",ExportVar "letExpr",ExportVar "ifExpr",ExportVar "returnExpr",ExportVar "forExpr",ExportVar "postfix",ExportVar "skipNewlines"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "empty",ImportVar "many",ImportVar "optional",ImportVar "some",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.CaseParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "caseExprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.DoParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "doExprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.ListParserCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "listExprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]},DeclImport {importQualified = False, importModule = "Parser.SQL.SQLParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "expr" (TApp (TCon "Parser") (TCon "Expr")),DeclFunGroup "expr" [FunClause [] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "e",TokSymbol "<-",TokIdent "exprDispatch",TokSymbol ";",TokIdent "postfix",TokIdent "e",TokSymbol ";",TokKeyword "where",TokVLBrace,TokSymbol ";",TokIdent "exprDispatch",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< expr dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokString "do",TokArrow,TokIdent "doExprCore",TokIdent "expr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "case",TokArrow,TokIdent "caseExprCore",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "let",TokArrow,TokIdent "letBlock",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "if",TokArrow,TokIdent "ifExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "for",TokArrow,TokIdent "forExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "return",TokArrow,TokIdent "returnExpr",TokSymbol ";",TokTypeIdent "TokKeyword",TokString "sql",TokArrow,TokIdent "parseSQL",TokSymbol ";",TokTypeIdent "TokSymbol",TokString "[",TokArrow,TokIdent "listExprCore",TokIdent "expr",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "exprCore",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "letBlock",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letBlock next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "try",TokIdent "letExpr",TokOperator "<|>",TokIdent "pLetExpr",TokVRBrace,TokNewline,TokIdent "postfix",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "postfix",TokIdent "e",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "mbBinds",TokSymbol "<-",TokIdent "whereClause",TokSymbol ";",TokKeyword "case",TokIdent "mbBinds",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "binds",TokArrow,TokIdent "postfix",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "e",TokVRBrace,TokVRBrace,TokNewline,TokIdent "whereClause",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Maybe",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "whereClause",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "keyword",TokString "where",TokOperator ">>",TokIdent "bindings",TokOperator ">>",TokSymbol "=",TokSymbol "\\",TokIdent "bs",TokArrow,TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokIdent "bs",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindings",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindings",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipNewlines",TokSymbol ";",TokIdent "b",TokSymbol "<-",TokIdent "binding",TokSymbol ";",TokIdent "bs",TokSymbol "<-",TokIdent "many",TokSymbol "(",TokIdent "skipSeparators",TokOperator ">>",TokIdent "binding",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "b",TokOperator ":",TokIdent "bs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "binding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "binding",TokSymbol "=",TokIdent "try",TokIdent "valueBinding",TokOperator "<|>",TokIdent "funBinding",TokNewline,TokIdent "exprTop",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprTop",TokSymbol "=",TokIdent "try",TokIdent "exprSeq",TokOperator "<|>",TokIdent "expr",TokNewline,TokIdent "exprSeq",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "exprSeq",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "es",TokSymbol "<-",TokIdent "sepEndBy1",TokSymbol "(",TokIdent "try",TokIdent "expr",TokSymbol ")",TokIdent "exprSep",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "if",TokIdent "length",TokIdent "es",TokSymbol "==",TokNumber 1,TokKeyword "then",TokIdent "head",TokIdent "es",TokKeyword "else",TokTypeIdent "ESeq",TokIdent "es",TokVRBrace,TokNewline,TokIdent "exprSep",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "exprSep",TokSymbol "=",TokIdent "skipMany1",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokNewline,TokIdent "def",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "p",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ifExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "ifExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "if",TokSymbol ";",TokIdent "cond",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "then",TokSymbol ";",TokIdent "th",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "keyword",TokString "else",TokSymbol ";",TokIdent "el",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "th",TokIdent "el",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "returnExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "returnExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "return",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EReturn",TokIdent "e",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "forExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "forExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "for",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "qualifier",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokSymbol "=",TokVLBrace,TokIdent "try",TokIdent "genQualifier",TokVLBrace,TokOperator "<|>",TokIdent "guardQualifier",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "funBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "funBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< funBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokSymbol ";",TokIdent "next",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "if",TokIdent "next",TokSymbol "==",TokTypeIdent "TokOperator",TokString "=",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokIdent "args",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "valueBinding",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Binding",TokNewline,TokIdent "valueBinding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "optional",TokSymbol "(",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< valueBinding next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "letExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "letExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< letExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "bindingsBlock",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "mIn",TokSymbol "<-",TokIdent "optional",TokSymbol "(",TokIdent "keyword",TokString "in",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokIdent "newline",TokSymbol ";",TokKeyword "case",TokIdent "mIn",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokVLBrace,TokKeyword "if",TokIdent "null",TokIdent "binds",TokVLBrace,TokKeyword "then",TokIdent "empty",TokSymbol ";",TokKeyword "else",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokSymbol "(",TokTypeIdent "EVar",TokString "__unit__",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "pLetExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "pLetExpr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pLetExpr next token: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e1",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokIdent "bracesV3",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "in",TokSymbol ";",TokIdent "e2",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "bindingsBlock",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Binding",TokSymbol "]",TokNewline,TokIdent "bindingsBlock",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokIdent "braces",TokSymbol "(",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "sepBy",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ";",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/ExprParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ExprParser
  ( exprCore,
    exprTop,
    exprSeq,
    exprSep,
  )
where

import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.ExprExtensions (exprSep, exprSeq, exprTop)

-- import Parser.SQL.SQLParser

-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprParser",TokVLBrace,TokSymbol "(",TokIdent "exprCore",TokSymbol ",",TokIdent "exprTop",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprSep",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprExtensions",TokSymbol "(",TokIdent "exprSep",TokSymbol ",",TokIdent "exprSeq",TokSymbol ",",TokIdent "exprTop",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "exprCore"
<< exportItem: next token=TokIdent "exprTop"
<< exportItem: next token=TokIdent "exprSeq"
<< exportItem: next token=TokIdent "exprSep"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.ExprParser" (Just [ExportVar "exprCore",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprSep",ImportVar "exprSeq",ImportVar "exprTop"]}
Just ([DeclModule "Parser.Expr.ExprParser" (Just [ExportVar "exprCore",ExportVar "exprTop",ExportVar "exprSeq",ExportVar "exprSep"]),DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprExtensions", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprSep",ImportVar "exprSeq",ImportVar "exprTop"]}],[TokNewline])

=== Running: src/Parser/Expr/ListParserCore.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.ListParserCore (listExprCore) where

import AST.Expr
import Control.Applicative (many, optional, (<|>))
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Expr.ExprCore (exprCore)
import Parser.Expr.PatternParser (pattern)
import Utils.MyTrace

listExprCore :: Parser Expr -> Parser Expr
listExprCore expr =
  brackets $
    try (listCompExpr expr) -- Åö ç≈óDêÊ
      <|> try (stepRangeExpr expr)
      <|> try (rangeExpr expr)
      <|> listLiteralExpr expr

-- [a, b .. c]
stepRangeExpr :: Parser Expr -> Parser Expr
stepRangeExpr expr = do
  start <- exprCore
  symbol ","
  step <- exprCore
  symbol ".."
  end <- exprCore
  return (ERangeStep start step end)

-- [a .. b]
rangeExpr :: Parser Expr -> Parser Expr
rangeExpr expr = do
  start <- exprCore
  symbol ".."
  end <- exprCore
  return (ERange start end)

-- [a, b, c]
listLiteralExpr :: Parser Expr -> Parser Expr
listLiteralExpr expr = do
  elems <- sepBy exprCore (symbol ",")
  optional (symbol ",")
  return (EList elems)

-- [x | ...]
listCompExpr :: Parser Expr -> Parser Expr
listCompExpr expr = do
  body <- exprCore
  symbol "|"
  qs <- sepBy1 (qualifier expr) (symbol ",")
  return (EListComp body qs)

qualifier :: Parser Expr -> Parser Qualifier
qualifier expr =
  try (genQualifier expr) -- Åö ç≈óDêÊ
    <|> try (letQualifier expr)
    <|> guardQualifier expr

genQualifier :: Parser Expr -> Parser Qualifier
genQualifier expr = do
  pat <- pattern
  symbol "<-"
  src <- expr
  return (QGenerator pat src)

guardQualifier :: Parser Expr -> Parser Qualifier
guardQualifier expr = QGuard <$> expr

{-}
letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QGuard (ELet binds (EVar "__unit__")))
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)
-}

letQualifier :: Parser Expr -> Parser Qualifier
letQualifier expr = do
  keyword "let"
  binds <- sepBy1 binding (symbol ",")
  return (QLet binds)
  where
    binding = do
      pat <- pattern
      symbol "="
      e <- expr
      return (pat, e)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ListParserCore",TokSymbol "(",TokIdent "listExprCore",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokSymbol "(",TokIdent "many",TokSymbol ",",TokIdent "optional",TokSymbol ",",TokSymbol "(",TokOperator "<|>",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCore",TokSymbol "(",TokIdent "exprCore",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokSymbol "(",TokIdent "pattern",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "listExprCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listExprCore",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "brackets",TokOperator "$",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "listLiteralExpr",TokIdent "expr",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "stepRangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "step",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "rangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "elems",TokSymbol "<-",TokIdent "sepBy",TokIdent "exprCore",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listCompExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "guardQualifier",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokIdent "expr",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "letQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "listExprCore"
<< declBody: return DeclModule "Parser.Expr.ListParserCore" (Just [ExportVar "listExprCore"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "many",ImportVar "optional",ImportVar "<|>"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "listExprCore"
<< decl parser called
<< decl dispatch: TokIdent "listExprCore"
<< funDecl: next token=TokIdent "listExprCore"
<< funClause: next token=TokIdent "listExprCore"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "listExprCore"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parseTypeCore: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< parsed type signature: listExprCore :: TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr"))
<< returning DeclTypeSig: DeclTypeSig "listExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< declBody: return DeclTypeSig "listExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))
<< decl next token: TokIdent "listExprCore"
<< decl parser called
<< decl dispatch: TokIdent "listExprCore"
<< funDecl: next token=TokIdent "listExprCore"
<< funClause: next token=TokIdent "listExprCore"
<< patternParser: (pAs <|> makeCons)PApp (PVar "expr") []
<< funClause: args=[PApp (PVar "expr") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokIdent "brackets"
<< exprCore next token: TokIdent "brackets"
<< atomBaseCore next token: TokIdent "brackets"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "try"
<< whereBlock: next tokenTokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< typeSigDecl: TokIdent "listExprCore"
<< valueDecl: TokIdent "listExprCore"
<< patternParser: (pAs <|> makeCons)PApp (PVar "listExprCore") [PVar "expr"]
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
Just ([DeclModule "Parser.Expr.ListParserCore" (Just [ExportVar "listExprCore"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "many",ImportVar "optional",ImportVar "<|>"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Expr.ExprCore", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "exprCore"]},DeclImport {importQualified = False, importModule = "Parser.Expr.PatternParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "pattern"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "listExprCore" (TFun (TApp (TCon "Parser") (TCon "Expr")) (TApp (TCon "Parser") (TCon "Expr")))],[TokNewline,TokIdent "listExprCore",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "brackets",TokOperator "$",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "listCompExpr",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "rangeExpr",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "listLiteralExpr",TokIdent "expr",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "stepRangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "stepRangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "step",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERangeStep",TokIdent "start",TokIdent "step",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "rangeExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "rangeExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "start",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "..",TokSymbol ";",TokIdent "end",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ERange",TokIdent "start",TokIdent "end",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listLiteralExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listLiteralExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "elems",TokSymbol "<-",TokIdent "sepBy",TokIdent "exprCore",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "optional",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EList",TokIdent "elems",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "listCompExpr",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "listCompExpr",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "body",TokSymbol "<-",TokIdent "exprCore",TokSymbol ";",TokIdent "symbol",TokString "|",TokSymbol ";",TokIdent "qs",TokSymbol "<-",TokIdent "sepBy1",TokSymbol "(",TokIdent "qualifier",TokIdent "expr",TokSymbol ")",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "EListComp",TokIdent "body",TokIdent "qs",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "qualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "qualifier",TokIdent "expr",TokSymbol "=",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "genQualifier",TokIdent "expr",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "try",TokSymbol "(",TokIdent "letQualifier",TokIdent "expr",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "guardQualifier",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "genQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "genQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "<-",TokSymbol ";",TokIdent "src",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QGenerator",TokIdent "pat",TokIdent "src",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "guardQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "guardQualifier",TokIdent "expr",TokSymbol "=",TokTypeIdent "QGuard",TokOperator "<$>",TokIdent "expr",TokNewline,TokIdent "letQualifier",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokArrow,TokTypeIdent "Parser",TokTypeIdent "Qualifier",TokNewline,TokIdent "letQualifier",TokIdent "expr",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "keyword",TokString "let",TokSymbol ";",TokIdent "binds",TokSymbol "<-",TokIdent "sepBy1",TokIdent "binding",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "QLet",TokIdent "binds",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "binding",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "pat",TokSymbol "<-",TokIdent "pattern",TokSymbol ";",TokIdent "symbol",TokString "=",TokSymbol ";",TokIdent "e",TokSymbol "<-",TokIdent "expr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "e",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/Parser/Expr/PatternParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Expr.PatternParser
  ( pattern,
    patternParser,
    patternStart,
    pConstrOrVar,
    patternVar,
    constraintP,
    pParenOrTuple,
    pList,
    pWildcard,
    pInt,
  )
where

import AST.Pattern
import Control.Applicative
import Data.Char (isUpper)
import Data.Functor (void)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Type.TypeParser (typeIdent)
import Utils.MyTrace (myTrace)

patternParser :: Parser Pattern
patternParser = do
  p <- pAs <|> makeCons
  myTrace ("<< patternParser: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

pattern :: Parser Pattern
pattern = do
  p <- pAs <|> makeCons
  myTrace ("<< pattern1: (pAs <|> makeCons)" ++ show p)
  -- stopPattern
  -- t <- lookAhead anyToken
  -- myTrace ("<< patten2 next token: stopPattern" ++ show t)
  return p

patternStart :: Parser ()
patternStart =
  void (symbol "_")
    <|> void ident
    <|> void typeIdent
    <|> void int
    <|> void (symbol "(")

stopPattern :: Parser ()
stopPattern =
  lookAhead $
    symbol "|"
      <|> void (token TokArrow)
      <|> void (token TokNewline)
      <|> symbol ";"
      <|> symbol "}"
      <|> keyword "in"
      <|> keyword "for"
      <|> keyword "return"
      <|> keyword "case"
      <|> keyword "let"
      <|> keyword "if"
      <|> keyword "do"
      <|> eof

eof :: Parser ()
eof = Parser $ \ts ->
  case ts of
    [] -> Just ((), [])
    _ -> Nothing

makeCons :: Parser Pattern
makeCons = do
  p <- makeApp
  rest p
  where
    rest p =
      ( do
          symbol ":"
          p2 <- makeCons
          return (PCons p p2)
      )
        <|> return p

makeApp :: Parser Pattern
makeApp = do
  p <- pAtom
  ps <- many pAtom
  return (PApp p ps)

pAtom :: Parser Pattern
pAtom = do
  t <- lookAhead anyToken
  case t of
    TokKeyword _ -> empty -- Åö ÉLÅ[ÉèÅ[ÉhÇÕÉpÉ^Å[ÉìÇ…Ç»ÇÁÇ»Ç¢
    _ -> pure ()
  pAs
    <|> pList
    <|> pParenOrTuple
    <|> pConstrOrVar
    <|> pInt
    <|> pChar
    <|> pString
    <|> (symbol "_" >> return PWildcard)

pAs :: Parser Pattern
pAs = do
  name <- ident
  symbol "@"
  pat <- pAtom
  return (PAs name pat)

pConstrOrVar :: Parser Pattern
pConstrOrVar =
  do
    patternVar
    <|> constraintP

patternVar :: Parser Pattern
patternVar = tokenIs $ \case
  TokIdent name -> Just (PVar name)
  -- TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

constraintP :: Parser Pattern
constraintP = tokenIs $ \case
  -- TokIdent name -> Just (PVar name)
  TokTypeIdent name -> Just (PConstr name [])
  _ -> Nothing

isKeyword :: String -> Bool
isKeyword s =
  s
    `elem` [ "case",
             "of",
             "let",
             "in",
             "if",
             "then",
             "else",
             "do",
             "return"
           ]

isIdentOnly :: Token -> Bool
isIdentOnly (TokIdent _) = True
isIdentOnly _ = False

pParenOrTuple :: Parser Pattern
pParenOrTuple = parens $ do
  pats <- pattern `sepBy1` symbol ","
  return $ case pats of
    [single] -> single
    _ -> PTuple pats

pList :: Parser Pattern
pList = PList <$> brackets (pattern `sepBy` symbol ",")

pWildcard :: Parser Pattern
pWildcard = symbol "_" >> return PWildcard

pInt :: Parser Pattern
pInt = PInt <$> int

pChar :: Parser Pattern
pChar = do
  c <- charLiteralExpr -- Ç∑Ç≈Ç…íËã`çœÇ›Ç»ÇÁÇªÇÍÇégÇ§
  return (PChar c)

pString :: Parser Pattern
pString = PString <$> stringLiteralExpr


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "PatternParser",TokVLBrace,TokSymbol "(",TokIdent "pattern",TokSymbol ",",TokIdent "patternParser",TokSymbol ",",TokIdent "patternStart",TokSymbol ",",TokIdent "pConstrOrVar",TokSymbol ",",TokIdent "patternVar",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "pParenOrTuple",TokSymbol ",",TokIdent "pList",TokSymbol ",",TokIdent "pWildcard",TokSymbol ",",TokIdent "pInt",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Functor",TokSymbol "(",TokIdent "void",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokSymbol "(",TokIdent "typeIdent",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ")",TokNewline,TokIdent "patternParser",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternParser",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "pattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "patternStart",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "patternStart",TokSymbol "=",TokVLBrace,TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "void",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "stopPattern",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "stopPattern",TokSymbol "=",TokVLBrace,TokIdent "lookAhead",TokOperator "$",TokVLBrace,TokIdent "symbol",TokString "|",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString ";",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString "}",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "in",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "for",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "return",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "case",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "let",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "if",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "do",TokSymbol ";",TokOperator "<|>",TokIdent "eof",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "eof",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "eof",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeCons",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokIdent "p",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "p",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "p",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSymbol "<-",TokIdent "many",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokSymbol "_",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "pure",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "pAs",TokVLBrace,TokOperator "<|>",TokIdent "pList",TokSymbol ";",TokOperator "<|>",TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<|>",TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<|>",TokIdent "pInt",TokSymbol ";",TokOperator "<|>",TokIdent "pChar",TokSymbol ";",TokOperator "<|>",TokIdent "pString",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pAs",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "@",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pConstrOrVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSymbol "=",TokVLBrace,TokKeyword "do",TokVLBrace,TokIdent "patternVar",TokSymbol ";",TokOperator "<|>",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "patternVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokSymbol ";",TokTypeIdent "TokTypeIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isKeyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokIdent "s",TokSymbol "=",TokVLBrace,TokIdent "s",TokVLBrace,TokUnknown '`',TokIdent "elem`",TokSymbol "[",TokString "case",TokSymbol ",",TokVLBrace,TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isIdentOnly",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSymbol "(",TokTypeIdent "TokIdent",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "pParenOrTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSymbol "=",TokIdent "parens",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "pats",TokSymbol "<-",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "pats",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "single",TokSymbol "]",TokArrow,TokIdent "single",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "PTuple",TokIdent "pats",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pList",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSymbol "=",TokTypeIdent "PList",TokOperator "<$>",TokIdent "brackets",TokSymbol "(",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokIdent "pWildcard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSymbol "=",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokNewline,TokIdent "pInt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSymbol "=",TokTypeIdent "PInt",TokOperator "<$>",TokIdent "int",TokNewline,TokIdent "pChar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pChar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "c",TokSymbol "<-",TokIdent "charLiteralExpr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PChar",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pString",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pString",TokSymbol "=",TokTypeIdent "PString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "pattern"
<< exportItem: next token=TokIdent "patternParser"
<< exportItem: next token=TokIdent "patternStart"
<< exportItem: next token=TokIdent "pConstrOrVar"
<< exportItem: next token=TokIdent "patternVar"
<< exportItem: next token=TokIdent "constraintP"
<< exportItem: next token=TokIdent "pParenOrTuple"
<< exportItem: next token=TokIdent "pList"
<< exportItem: next token=TokIdent "pWildcard"
<< exportItem: next token=TokIdent "pInt"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Expr.PatternParser" (Just [ExportVar "pattern",ExportVar "patternParser",ExportVar "patternStart",ExportVar "pConstrOrVar",ExportVar "patternVar",ExportVar "constraintP",ExportVar "pParenOrTuple",ExportVar "pList",ExportVar "pWildcard",ExportVar "pInt"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "myTrace"]}
<< decl next token: TokIdent "patternParser"
<< decl parser called
<< decl dispatch: TokIdent "patternParser"
<< funDecl: next token=TokIdent "patternParser"
<< funClause: next token=TokIdent "patternParser"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "patternParser"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Pattern")
<< parsed type signature: patternParser :: TApp (TCon "Parser") (TCon "Pattern")
<< returning DeclTypeSig: DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern"))
<< declBody: return DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern"))
<< decl next token: TokIdent "patternParser"
<< decl parser called
<< decl dispatch: TokIdent "patternParser"
<< funDecl: next token=TokIdent "patternParser"
<< funClause: next token=TokIdent "patternParser"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "p"
<< pattern1: (pAs <|> makeCons)PApp (PVar "p") []
<< expr dispatch: TokIdent "pAs"
<< exprCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokIdent "pAs"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "makeCons"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< patternParser: (pAs <|> makeCons)") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokString "<< patternParser: (pAs <|> makeCons)"
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "p"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "p"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "patternParser" [FunClause [] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Expr.PatternParser" (Just [ExportVar "pattern",ExportVar "patternParser",ExportVar "patternStart",ExportVar "pConstrOrVar",ExportVar "patternVar",ExportVar "constraintP",ExportVar "pParenOrTuple",ExportVar "pList",ExportVar "pWildcard",ExportVar "pInt"]),DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]},DeclImport {importQualified = False, importModule = "Data.Functor", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "void"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Type.TypeParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "typeIdent"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "myTrace"]},DeclTypeSig "patternParser" (TApp (TCon "Parser") (TCon "Pattern")),DeclFunGroup "patternParser" [FunClause [] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< patternParser: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "pattern",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pattern",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAs",TokOperator "<|>",TokIdent "makeCons",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< pattern1: (pAs <|> makeCons)",TokOperator "++",TokIdent "show",TokIdent "p",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokIdent "p",TokVRBrace,TokNewline,TokIdent "patternStart",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "patternStart",TokSymbol "=",TokVLBrace,TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "_",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "void",TokIdent "ident",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "typeIdent",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokIdent "int",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "symbol",TokString "(",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "stopPattern",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "stopPattern",TokSymbol "=",TokVLBrace,TokIdent "lookAhead",TokOperator "$",TokVLBrace,TokIdent "symbol",TokString "|",TokVLBrace,TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "void",TokSymbol "(",TokIdent "token",TokTypeIdent "TokNewline",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString ";",TokSymbol ";",TokOperator "<|>",TokIdent "symbol",TokString "}",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "in",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "for",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "return",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "case",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "let",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "if",TokSymbol ";",TokOperator "<|>",TokIdent "keyword",TokString "do",TokSymbol ";",TokOperator "<|>",TokIdent "eof",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "eof",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "eof",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "ts",TokArrow,TokVLBrace,TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeCons",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeCons",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "makeApp",TokSymbol ";",TokIdent "rest",TokIdent "p",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "rest",TokIdent "p",TokSymbol "=",TokVLBrace,TokSymbol "(",TokKeyword "do",TokIdent "symbol",TokString ":",TokIdent "p2",TokSymbol "<-",TokIdent "makeCons",TokKeyword "return",TokSymbol "(",TokTypeIdent "PCons",TokIdent "p",TokIdent "p2",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokKeyword "return",TokIdent "p",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "makeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "makeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "p",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokIdent "ps",TokSymbol "<-",TokIdent "many",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PApp",TokIdent "p",TokIdent "ps",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAtom",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokKeyword",TokSymbol "_",TokArrow,TokIdent "empty",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "pure",TokSymbol "()",TokVRBrace,TokNewline,TokIdent "pAs",TokVLBrace,TokOperator "<|>",TokIdent "pList",TokSymbol ";",TokOperator "<|>",TokIdent "pParenOrTuple",TokSymbol ";",TokOperator "<|>",TokIdent "pConstrOrVar",TokSymbol ";",TokOperator "<|>",TokIdent "pInt",TokSymbol ";",TokOperator "<|>",TokIdent "pChar",TokSymbol ";",TokOperator "<|>",TokIdent "pString",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pAs",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pAs",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "name",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "symbol",TokString "@",TokSymbol ";",TokIdent "pat",TokSymbol "<-",TokIdent "pAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PAs",TokIdent "name",TokIdent "pat",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pConstrOrVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pConstrOrVar",TokSymbol "=",TokVLBrace,TokKeyword "do",TokVLBrace,TokIdent "patternVar",TokSymbol ";",TokOperator "<|>",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "patternVar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "patternVar",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PVar",TokIdent "name",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "constraintP",TokSymbol "=",TokIdent "tokenIs",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokSymbol ";",TokTypeIdent "TokTypeIdent",TokIdent "name",TokArrow,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "PConstr",TokIdent "name",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "isKeyword",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isKeyword",TokIdent "s",TokSymbol "=",TokVLBrace,TokIdent "s",TokVLBrace,TokUnknown '`',TokIdent "elem`",TokSymbol "[",TokString "case",TokSymbol ",",TokVLBrace,TokString "of",TokSymbol ",",TokSymbol ";",TokString "let",TokSymbol ",",TokSymbol ";",TokString "in",TokSymbol ",",TokSymbol ";",TokString "if",TokSymbol ",",TokSymbol ";",TokString "then",TokSymbol ",",TokSymbol ";",TokString "else",TokSymbol ",",TokSymbol ";",TokString "do",TokSymbol ",",TokSymbol ";",TokString "return",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokVRBrace,TokNewline,TokIdent "isIdentOnly",TokSymbol "::",TokTypeIdent "Token",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "isIdentOnly",TokSymbol "(",TokTypeIdent "TokIdent",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "True",TokNewline,TokIdent "isIdentOnly",TokSymbol "_",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "pParenOrTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pParenOrTuple",TokSymbol "=",TokIdent "parens",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "pats",TokSymbol "<-",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokKeyword "return",TokOperator "$",TokKeyword "case",TokIdent "pats",TokKeyword "of",TokVLBrace,TokSymbol "[",TokIdent "single",TokSymbol "]",TokArrow,TokIdent "single",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "PTuple",TokIdent "pats",TokVRBrace,TokVRBrace,TokNewline,TokIdent "pList",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pList",TokSymbol "=",TokTypeIdent "PList",TokOperator "<$>",TokIdent "brackets",TokSymbol "(",TokIdent "pattern",TokUnknown '`',TokIdent "sepBy`",TokIdent "symbol",TokString ",",TokSymbol ")",TokNewline,TokIdent "pWildcard",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pWildcard",TokSymbol "=",TokIdent "symbol",TokString "_",TokOperator ">>",TokKeyword "return",TokTypeIdent "PWildcard",TokNewline,TokIdent "pInt",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pInt",TokSymbol "=",TokTypeIdent "PInt",TokOperator "<$>",TokIdent "int",TokNewline,TokIdent "pChar",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pChar",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "c",TokSymbol "<-",TokIdent "charLiteralExpr",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "PChar",TokIdent "c",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "pString",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Pattern",TokNewline,TokIdent "pString",TokSymbol "=",TokTypeIdent "PString",TokOperator "<$>",TokIdent "stringLiteralExpr",TokNewline])

=== Running: src/Parser/SQL/SQLParser.hs ===
-- Raw Source --
module Parser.SQL.SQLParser (parseSQL) where

import AST.Expr -- (Expr (..))

-- {var} íäèoópÅiå„Ç≈çÏÇÈÅj
import Parser.Core.Combinator
import Parser.Core.TokenParser
-- import Parser.Expr.ExprCore
import Utils.SQLUtils

parseSQL :: Parser Expr
parseSQL = do
  _ <- keyword "sql"
  sqlText <- stringLiteralExpr
  let (sqlBody, vars) = extractSQLVars sqlText
  return (ESQL sqlBody (map EVar vars))


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "SQL",TokDot,TokTypeIdent "SQLParser",TokSymbol "(",TokIdent "parseSQL",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokNewline,TokIdent "parseSQL",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Expr",TokNewline,TokIdent "parseSQL",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "_",TokSymbol "<-",TokIdent "keyword",TokString "sql",TokSymbol ";",TokIdent "sqlText",TokSymbol "<-",TokIdent "stringLiteralExpr",TokSymbol ";",TokKeyword "let",TokSymbol "(",TokIdent "sqlBody",TokSymbol ",",TokIdent "vars",TokSymbol ")",TokSymbol "=",TokIdent "extractSQLVars",TokIdent "sqlText",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "ESQL",TokIdent "sqlBody",TokSymbol "(",TokIdent "map",TokTypeIdent "EVar",TokIdent "vars",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseSQL"
<< declBody: return DeclModule "Parser.SQL.SQLParser" (Just [ExportVar "parseSQL"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.SQLUtils", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "parseSQL"
<< decl parser called
<< decl dispatch: TokIdent "parseSQL"
<< funDecl: next token=TokIdent "parseSQL"
<< funClause: next token=TokIdent "parseSQL"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseSQL"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Expr")
<< parsed type signature: parseSQL :: TApp (TCon "Parser") (TCon "Expr")
<< returning DeclTypeSig: DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr"))
<< declBody: return DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr"))
<< decl next token: TokIdent "parseSQL"
<< decl parser called
<< decl dispatch: TokIdent "parseSQL"
<< funDecl: next token=TokIdent "parseSQL"
<< funClause: next token=TokIdent "parseSQL"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "_"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokIdent "keyword"
<< exprCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokIdent "keyword"
<< atomBaseCore next token: TokString "sql"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "sqlText"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlText") []
<< expr dispatch: TokIdent "stringLiteralExpr"
<< exprCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokIdent "stringLiteralExpr"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sqlBody") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "vars") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sqlBody") [],PApp (PVar "vars") []]) []
<< expr dispatch: TokIdent "extractSQLVars"
<< exprCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "extractSQLVars"
<< atomBaseCore next token: TokIdent "sqlText"
<< atomBaseCore next token: TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokTypeIdent "ESQL"
<< atomBaseCore next token: TokIdent "sqlBody"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokTypeIdent "EVar"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< declBody: return DeclFunGroup "parseSQL" [FunClause [] Nothing (Just (EDo [Bind (PApp PWildcard []) (EApp (EVar "keyword") (EString "sql")),Bind (PApp (PVar "sqlText") []) (EVar "stringLiteralExpr"),LetStmt [(PApp (PTuple [PApp (PVar "sqlBody") [],PApp (PVar "vars") []]) [],EApp (EVar "extractSQLVars") (EVar "sqlText"))],ExprStmt (EReturn (EApp (EApp (EVarType "ESQL") (EVar "sqlBody")) (EApp (EApp (EVar "map") (EVarType "EVar")) (EVar "vars"))))])) Nothing]
Just ([DeclModule "Parser.SQL.SQLParser" (Just [ExportVar "parseSQL"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Utils.SQLUtils", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "parseSQL" (TApp (TCon "Parser") (TCon "Expr")),DeclFunGroup "parseSQL" [FunClause [] Nothing (Just (EDo [Bind (PApp PWildcard []) (EApp (EVar "keyword") (EString "sql")),Bind (PApp (PVar "sqlText") []) (EVar "stringLiteralExpr"),LetStmt [(PApp (PTuple [PApp (PVar "sqlBody") [],PApp (PVar "vars") []]) [],EApp (EVar "extractSQLVars") (EVar "sqlText"))],ExprStmt (EReturn (EApp (EApp (EVarType "ESQL") (EVar "sqlBody")) (EApp (EApp (EVar "map") (EVarType "EVar")) (EVar "vars"))))])) Nothing]],[])

=== Running: src/Parser/Type/TypeParser.hs ===
-- Raw Source --
{-# LANGUAGE LambdaCase #-}

module Parser.Type.TypeParser
  ( parseType,
    parseForall,
    arrowType,
    typeApp,
    typeAtom,
    typeIdent,
    constraintP,
    constraintList,
    typeP,
  )
where

import AST.Decl
import AST.Expr
import AST.Type
import Control.Applicative
import Data.Char (isUpper)
import Data.List (isPrefixOf)
import Lexer.Token (Token (..))
import Parser.Core.Combinator
import Parser.Core.TokenParser
import Parser.Core.TokenParser (skipNewlines)
import Utils.MyTrace

parseType :: Parser Type
parseType = do
  t <- lookAhead anyToken
  myTrace ("<< parseType dispatch: " ++ show t)
  case t of
    TokVLBrace -> bracesV parseTypeCore
    _ -> parseTypeCore

parseTypeCore :: Parser Type
parseTypeCore = do
  skipMany (symbol ";" <|> newline)
  -- t <- lookAhead anyToken
  -- myTrace ("<< parseTypeCore next token: " ++ show t)
  t1 <- arrowType
  myTrace ("<< parseTypeCore: " ++ show t1)
  rest <- optional $ do
    token (TokKeyword "=>")
    t2 <- parseTypeCore
    return (t1, t2)
  case rest of
    Just (TApp (TCon cls) arg, body) ->
      return $ TConstraint [Constraint cls [arg]] body
    Just (TCon cls, body) ->
      return $ TConstraint [Constraint cls []] body
    Just (TTuple cs, body) ->
      return $ TConstraint (map toConstraint cs) body
    Nothing -> return t1
    _ -> empty

arrowType :: Parser Type
arrowType = do
  t1 <- typeApp
  -- t <- lookAhead anyToken
  -- myTrace ("<< arrowType next token: " ++ show t)
  rest <- optional $ do
    token (TokArrow)
    parseTypeCore
  return $ maybe t1 (TFun t1) rest

parensTuple :: Parser Type
parensTuple = do
  symbol "("
  ts <- parseTypeCore `sepBy1` symbol ","
  symbol ")"
  return (TTuple ts)

toConstraint :: Type -> Constraint
toConstraint (TApp (TCon cls) arg) = (Constraint cls [arg])
toConstraint (TCon cls) = (Constraint cls [])
toConstraint other = error $ "Invalid constraint form: " ++ show other

typeApp :: Parser Type
typeApp = do
  f <- typeTerm -- typeAtom
  args <- many typeTerm -- typeAtom
  return $ foldl TApp f args

typeTerm :: Parser Type
typeTerm = do
  ts <- some typeAtom
  return (foldl1 TApp ts)

typeAtom :: Parser Type
typeAtom =
  (parens parseTypeCore) -- äáå ïtÇ´å^
    <|> (symbol "()" *> pure TUnit) -- íPà å^
    <|> (TCon <$> typeIdent)
    <|> (TVar <$> ident)
    <|> brackets (TList <$> parseTypeCore)
    <|> parensTuple

constrainedType :: Parser Type
constrainedType = do
  symbol "("
  cs <- sepBy1 constraint (symbol ",")
  symbol ")"
  keyword "=>"
  ty <- arrowType
  return (TConstraint cs ty)

parseForall :: Parser Type
parseForall = do
  token TokForall
  vars <- some ident
  token TokDot
  body <- parseTypeCore
  return $ TForall vars body

typeIdent :: Parser String
typeIdent = satisfyMap $ \case
  TokTypeIdent s -> Just s
  _ -> Nothing

constraint :: Parser Constraint
constraint = do
  cls <- ident
  ty <- typeApp
  return (Constraint cls [ty])

constraintP :: Parser Constraint
constraintP = do
  className <- typeIdent
  args <- some typeAtom
  return $ Constraint className args

constraintList :: Parser [Constraint]
constraintList = do
  try (parens (constraintP `sepBy1` symbol ","))
    <|> fmap (: []) constraintP

typeP :: Parser Type
typeP = try forallType <|> typeAtom

forallType :: Parser Type
forallType = do
  token TokForall
  vars <- some ident
  token TokDot
  t <- constrainedType
  return (TForall vars t)


-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Parser",TokDot,TokTypeIdent "Type",TokDot,TokTypeIdent "TypeParser",TokVLBrace,TokSymbol "(",TokIdent "parseType",TokSymbol ",",TokIdent "parseForall",TokSymbol ",",TokIdent "arrowType",TokSymbol ",",TokIdent "typeApp",TokSymbol ",",TokIdent "typeAtom",TokSymbol ",",TokIdent "typeIdent",TokSymbol ",",TokIdent "constraintP",TokSymbol ",",TokIdent "constraintList",TokSymbol ",",TokIdent "typeP",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Applicative",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "Char",TokSymbol "(",TokIdent "isUpper",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "isPrefixOf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Lexer",TokDot,TokTypeIdent "Token",TokSymbol "(",TokTypeIdent "Token",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "TokenParser",TokSymbol "(",TokIdent "skipNewlines",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokNewline,TokIdent "parseType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "lookAhead",TokIdent "anyToken",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseType dispatch: ",TokOperator "++",TokIdent "show",TokIdent "t",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TokVLBrace",TokArrow,TokIdent "bracesV",TokIdent "parseTypeCore",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "parseTypeCore",TokVRBrace,TokVRBrace,TokNewline,TokIdent "parseTypeCore",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseTypeCore",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "skipMany",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "t1",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseTypeCore: ",TokOperator "++",TokIdent "show",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "t1",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "arrowType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t1",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokIdent "parseTypeCore",TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokIdent "maybe",TokIdent "t1",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "parensTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parensTuple",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "ts",TokSymbol "<-",TokIdent "parseTypeCore",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "toConstraint",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokIdent "other",TokSymbol "=",TokIdent "error",TokOperator "$",TokString "Invalid constraint form: ",TokOperator "++",TokIdent "show",TokIdent "other",TokNewline,TokIdent "typeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "typeTerm",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeTerm",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl",TokTypeIdent "TApp",TokIdent "f",TokIdent "args",TokVRBrace,TokNewline,TokIdent "typeTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "parens",TokIdent "parseTypeCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "()",TokOperator "*>",TokIdent "pure",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TVar",TokOperator "<$>",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "brackets",TokSymbol "(",TokTypeIdent "TList",TokOperator "<$>",TokIdent "parseTypeCore",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "parensTuple",TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrainedType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "cs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "constraint",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokIdent "keyword",TokString "=>",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseForall",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "TForall",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline,TokIdent "typeIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSymbol "=",TokIdent "satisfyMap",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokTypeIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraint",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "cls",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "className",TokIdent "args",TokVRBrace,TokNewline,TokIdent "constraintList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "fmap",TokSymbol "(",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSymbol "=",TokIdent "try",TokIdent "forallType",TokOperator "<|>",TokIdent "typeAtom",TokNewline,TokIdent "forallType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "parseType"
<< exportItem: next token=TokIdent "parseForall"
<< exportItem: next token=TokIdent "arrowType"
<< exportItem: next token=TokIdent "typeApp"
<< exportItem: next token=TokIdent "typeAtom"
<< exportItem: next token=TokIdent "typeIdent"
<< exportItem: next token=TokIdent "constraintP"
<< exportItem: next token=TokIdent "constraintList"
<< exportItem: next token=TokIdent "typeP"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "Parser.Type.TypeParser" (Just [ExportVar "parseType",ExportVar "parseForall",ExportVar "arrowType",ExportVar "typeApp",ExportVar "typeAtom",ExportVar "typeIdent",ExportVar "constraintP",ExportVar "constraintList",ExportVar "typeP"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Lexer"
<< declBody: return DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "skipNewlines"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Utils"
<< declBody: return DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "parseType"
<< decl parser called
<< decl dispatch: TokIdent "parseType"
<< funDecl: next token=TokIdent "parseType"
<< funClause: next token=TokIdent "parseType"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseType"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Type")
<< parsed type signature: parseType :: TApp (TCon "Parser") (TCon "Type")
<< returning DeclTypeSig: DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type"))
<< declBody: return DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type"))
<< decl next token: TokIdent "parseType"
<< decl parser called
<< decl dispatch: TokIdent "parseType"
<< funDecl: next token=TokIdent "parseType"
<< funClause: next token=TokIdent "parseType"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "lookAhead"
<< exprCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "lookAhead"
<< atomBaseCore next token: TokIdent "anyToken"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "myTrace"
<< pattern1: (pAs <|> makeCons)PApp (PString "<< parseType dispatch: ") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "myTrace") []
<< expr dispatch: TokIdent "myTrace"
<< exprCore next token: TokIdent "myTrace"
<< atomBaseCore next token: TokIdent "myTrace"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokString "<< parseType dispatch: "
<< atomBaseCore next token: TokOperator "++"
<< atomBaseCore next token: TokIdent "show"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "t"
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TokVLBrace" []) []
<< expr dispatch: TokIdent "bracesV"
<< exprCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokIdent "bracesV"
<< atomBaseCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< expr dispatch: TokIdent "parseTypeCore"
<< exprCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokIdent "parseTypeCore"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "parseTypeCore"
<< funClauseWithName: next token=TokIdent "parseTypeCore"
<< declBody: return DeclFunGroup "parseType" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< parseType dispatch: ") (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PConstr "TokVLBrace" []) []) (EApp (EVar "bracesV") (EVar "parseTypeCore")),CaseAlt (PApp PWildcard []) (EVar "parseTypeCore")])])) Nothing]
<< decl next token: TokIdent "parseTypeCore"
<< decl parser called
<< decl dispatch: TokIdent "parseTypeCore"
<< funDecl: next token=TokIdent "parseTypeCore"
<< funClause: next token=TokIdent "parseTypeCore"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "parseTypeCore"
<< parseType dispatch: TokTypeIdent "Parser"
<< parseTypeCore: TApp (TCon "Parser") (TCon "Type")
<< parsed type signature: parseTypeCore :: TApp (TCon "Parser") (TCon "Type")
<< returning DeclTypeSig: DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type"))
<< declBody: return DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type"))
<< decl next token: TokIdent "parseTypeCore"
<< decl parser called
<< decl dispatch: TokIdent "parseTypeCore"
<< funDecl: next token=TokIdent "parseTypeCore"
<< funClause: next token=TokIdent "parseTypeCore"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "skipMany"
<< pattern1: (pAs <|> makeCons)PApp (PVar "symbol") [PString ";"]
<< pattern1: (pAs <|> makeCons)PApp (PVar "skipMany") []
<< expr dispatch: TokIdent "skipMany"
<< exprCore next token: TokIdent "skipMany"
<< atomBaseCore next token: TokIdent "skipMany"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokIdent "symbol"
<< atomBaseCore next token: TokString ";"
<< atomBaseCore next token: TokOperator "<|>"
<< atomBaseCore next token: TokIdent "newline"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol ";"
<< expr dispatch: TokSymbol ";"
<< exprCore next token: TokSymbol ";"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "skipMany"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "parseTypeCore" [FunClause [] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Parser.Type.TypeParser" (Just [ExportVar "parseType",ExportVar "parseForall",ExportVar "arrowType",ExportVar "typeApp",ExportVar "typeAtom",ExportVar "typeIdent",ExportVar "constraintP",ExportVar "constraintList",ExportVar "typeP"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Applicative", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.Char", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isUpper"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "isPrefixOf"]},DeclImport {importQualified = False, importModule = "Lexer.Token", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Token"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Parser.Core.TokenParser", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "skipNewlines"]},DeclImport {importQualified = False, importModule = "Utils.MyTrace", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "parseType" (TApp (TCon "Parser") (TCon "Type")),DeclFunGroup "parseType" [FunClause [] Nothing (Just (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "lookAhead") (EVar "anyToken")),ExprStmt (EApp (EVar "myTrace") (EApp (EApp (EApp (EString "<< parseType dispatch: ") (EVar "++")) (EVar "show")) (EVar "t"))),ExprStmt (ECase (EVar "t") [CaseAlt (PApp (PConstr "TokVLBrace" []) []) (EApp (EVar "bracesV") (EVar "parseTypeCore")),CaseAlt (PApp PWildcard []) (EVar "parseTypeCore")])])) Nothing],DeclTypeSig "parseTypeCore" (TApp (TCon "Parser") (TCon "Type")),DeclFunGroup "parseTypeCore" [FunClause [] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "skipMany",TokSymbol "(",TokIdent "symbol",TokString ";",TokOperator "<|>",TokIdent "newline",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "t1",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokIdent "myTrace",TokSymbol "(",TokString "<< parseTypeCore: ",TokOperator "++",TokIdent "show",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokKeyword",TokString "=>",TokSymbol ")",TokSymbol ";",TokIdent "t2",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "t1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "case",TokIdent "rest",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol "]",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Just",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "cs",TokSymbol ",",TokIdent "body",TokSymbol ")",TokArrow,TokVLBrace,TokKeyword "return",TokOperator "$",TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokIdent "toConstraint",TokIdent "cs",TokSymbol ")",TokIdent "body",TokVRBrace,TokNewline,TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokIdent "t1",TokSymbol ";",TokSymbol "_",TokArrow,TokIdent "empty",TokVRBrace,TokVRBrace,TokNewline,TokIdent "arrowType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "arrowType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "t1",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokIdent "rest",TokSymbol "<-",TokIdent "optional",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "token",TokSymbol "(",TokTypeIdent "TokArrow",TokSymbol ")",TokSymbol ";",TokIdent "parseTypeCore",TokVRBrace,TokNewline,TokKeyword "return",TokOperator "$",TokIdent "maybe",TokIdent "t1",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t1",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline,TokIdent "parensTuple",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parensTuple",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "ts",TokSymbol "<-",TokIdent "parseTypeCore",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "toConstraint",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokIdent "arg",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "arg",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokSymbol "(",TokTypeIdent "TCon",TokIdent "cls",TokSymbol ")",TokSymbol "=",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "toConstraint",TokIdent "other",TokSymbol "=",TokIdent "error",TokOperator "$",TokString "Invalid constraint form: ",TokOperator "++",TokIdent "show",TokIdent "other",TokNewline,TokIdent "typeApp",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeApp",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "f",TokSymbol "<-",TokIdent "typeTerm",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "many",TokIdent "typeTerm",TokSymbol ";",TokKeyword "return",TokOperator "$",TokIdent "foldl",TokTypeIdent "TApp",TokIdent "f",TokIdent "args",TokVRBrace,TokNewline,TokIdent "typeTerm",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeTerm",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "ts",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "foldl1",TokTypeIdent "TApp",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "typeAtom",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeAtom",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "parens",TokIdent "parseTypeCore",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokSymbol "(",TokIdent "symbol",TokString "()",TokOperator "*>",TokIdent "pure",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TCon",TokOperator "<$>",TokIdent "typeIdent",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokSymbol "(",TokTypeIdent "TVar",TokOperator "<$>",TokIdent "ident",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "brackets",TokSymbol "(",TokTypeIdent "TList",TokOperator "<$>",TokIdent "parseTypeCore",TokSymbol ")",TokSymbol ";",TokOperator "<|>",TokIdent "parensTuple",TokVRBrace,TokVRBrace,TokNewline,TokIdent "constrainedType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "constrainedType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "symbol",TokString "(",TokSymbol ";",TokIdent "cs",TokSymbol "<-",TokIdent "sepBy1",TokIdent "constraint",TokSymbol "(",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ";",TokIdent "symbol",TokString ")",TokSymbol ";",TokIdent "keyword",TokString "=>",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "arrowType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "ty",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "parseForall",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "parseForall",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "body",TokSymbol "<-",TokIdent "parseTypeCore",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "TForall",TokIdent "vars",TokIdent "body",TokVRBrace,TokNewline,TokIdent "typeIdent",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "String",TokNewline,TokIdent "typeIdent",TokSymbol "=",TokIdent "satisfyMap",TokOperator "$",TokSymbol "\\",TokKeyword "case",TokVLBrace,TokTypeIdent "TokTypeIdent",TokIdent "s",TokArrow,TokTypeIdent "Just",TokIdent "s",TokSymbol ";",TokSymbol "_",TokArrow,TokTypeIdent "Nothing",TokVRBrace,TokNewline,TokIdent "constraint",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraint",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "cls",TokSymbol "<-",TokIdent "ident",TokSymbol ";",TokIdent "ty",TokSymbol "<-",TokIdent "typeApp",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "[",TokIdent "ty",TokSymbol "]",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "constraintP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Constraint",TokNewline,TokIdent "constraintP",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "className",TokSymbol "<-",TokIdent "typeIdent",TokSymbol ";",TokIdent "args",TokSymbol "<-",TokIdent "some",TokIdent "typeAtom",TokSymbol ";",TokKeyword "return",TokOperator "$",TokTypeIdent "Constraint",TokIdent "className",TokIdent "args",TokVRBrace,TokNewline,TokIdent "constraintList",TokSymbol "::",TokTypeIdent "Parser",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokNewline,TokIdent "constraintList",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "try",TokSymbol "(",TokIdent "parens",TokSymbol "(",TokIdent "constraintP",TokUnknown '`',TokIdent "sepBy1`",TokIdent "symbol",TokString ",",TokSymbol ")",TokSymbol ")",TokVLBrace,TokOperator "<|>",TokIdent "fmap",TokSymbol "(",TokOperator ":",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokIdent "constraintP",TokVRBrace,TokVRBrace,TokNewline,TokIdent "typeP",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "typeP",TokSymbol "=",TokIdent "try",TokIdent "forallType",TokOperator "<|>",TokIdent "typeAtom",TokNewline,TokIdent "forallType",TokSymbol "::",TokTypeIdent "Parser",TokTypeIdent "Type",TokNewline,TokIdent "forallType",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "token",TokTypeIdent "TokForall",TokSymbol ";",TokIdent "vars",TokSymbol "<-",TokIdent "some",TokIdent "ident",TokSymbol ";",TokIdent "token",TokTypeIdent "TokDot",TokSymbol ";",TokIdent "t",TokSymbol "<-",TokIdent "constrainedType",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "TForall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Error.hs ===
-- Raw Source --
module TypeInference.Error where

import AST.Type (Type (..))
import TypeInference.Unify (UnifyError)

-- å^êÑò_ëSëÃÇ≈égÇ§ÉGÉâÅ[å^
data InferError
  = InferUnboundVariable String
  | InferMismatch Type Type
  | InferUnifyError UnifyError
  | InferOther String
  deriving (Show, Eq)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol ")",TokNewline,TokKeyword "data",TokTypeIdent "InferError",TokVLBrace,TokSymbol "=",TokTypeIdent "InferUnboundVariable",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferMismatch",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferUnifyError",TokTypeIdent "UnifyError",TokSymbol ";",TokSymbol "|",TokTypeIdent "InferOther",TokTypeIdent "String",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.Error" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "UnifyError"]}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "InferUnboundVariable"
<< constrS: next token TokTypeIdent "InferUnboundVariable"
<< dataConstr: next token TokTypeIdent "InferUnboundVariable"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "InferUnboundVariable" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "UnifyError"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "InferUnboundVariable" [TCon "String"],Constraint "InferMismatch" [TCon "Type",TCon "Type"],Constraint "InferUnifyError" [TCon "UnifyError"],Constraint "InferOther" [TCon "String"]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "InferError" [] [Constraint "InferUnboundVariable" [TCon "String"],Constraint "InferMismatch" [TCon "Type",TCon "Type"],Constraint "InferUnifyError" [TCon "UnifyError"],Constraint "InferOther" [TCon "String"]] ["Show","Eq"]
Just ([DeclModule "TypeInference.Error" Nothing,DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "UnifyError"]},DeclData "InferError" [] [Constraint "InferUnboundVariable" [TCon "String"],Constraint "InferMismatch" [TCon "Type",TCon "Type"],Constraint "InferUnifyError" [TCon "UnifyError"],Constraint "InferOther" [TCon "String"]] ["Show","Eq"]],[TokNewline])

=== Running: src/TypeInference/Infer/Core - „Ç≥„Éî„Éº.hs ===
-- Raw Source --
module TypeInference.Infer
  ( InferError (..),
    inferExpr,
    inferDecl,
    inferProgram,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    applyEnv,
    emptyEnv,
    extendEnv,
    freeTypeVars,
    freeTypeVarsEnv,
    generalize,
    instantiate,
    lookupEnv,
  )
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr ÇÃï‘ÇËílÅFå^Ç∆ë„ì¸
type InferResult = (Subst, Type)

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

inferBindings :: TypeEnv -> [(Pattern, Expr)] -> Either InferError (Subst, TypeEnv)
inferBindings env [] = Right (emptySubst, emptyEnv)
inferBindings env ((pat, expr) : rest) = do
  -- ÉpÉ^Å[ÉìêÑò_
  (sPat, envPat, tPat) <- inferPattern pat

  -- âEï”ÇÃêÑò_
  (sExpr, tExpr) <- inferExpr (applyEnv sPat env) expr

  -- ÉpÉ^Å[Éìå^Ç∆âEï”å^Ç unifyÅiÉGÉâÅ[å^Çïœä∑Åj
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su

  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat

  -- écÇËÇÃë©îõ
  (sRest, envRest) <- inferBindings (applyEnv s env) rest

  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest

  Right (sFinal, envFinal)

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s

    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

-- éÆÇÃå^êÑò_ÅiÇ‹ÇæíÜêgÇÕãÛÅj
-- inferExpr :: TypeEnv -> Expr -> Either InferError InferResult
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (ELetBlock binds body) = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

-- SQL
inferExpr env (ESQL _ params) = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, tParam) <- inferExpr envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)

-- 1. ïœêî
inferExpr env (EVar x) =
  case lookupEnv env x of
    Nothing -> Left (InferUnboundVariable x)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- 2. êÆêîÉäÉeÉâÉã
inferExpr env (EInt _) =
  Right (emptySubst, TCon "Int")
-- 3. ÉuÅ[ÉãÉäÉeÉâÉã
inferExpr env (EBool _) =
  Right (emptySubst, TCon "Bool")
-- 4. ï∂éöóÒÉäÉeÉâÉã
inferExpr env (EString _) =
  Right (emptySubst, TCon "String")
-- 5. ä÷êîìKópÅiHM å^êÑò_ÇÃäjÅj
inferExpr env (EApp e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ ->
      Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)
-- 6. ÉâÉÄÉ_éÆ
inferExpr env (ELam pat body) = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-- 7. let éÆ
inferExpr env (ELet pat e1 e2) = do
  -- ÉpÉ^Å[ÉìêÑò_
  (sPat, envPat, tPat) <- inferPattern pat
  -- e1 ÇÃêÑò_
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  -- ÉpÉ^Å[Éìå^Ç∆ e1 ÇÃå^Ç unify
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  -- Ç±Ç±Ç‹Ç≈ÇÃíuä∑ÇÇ‹Ç∆ÇﬂÇÈ
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  -- ÉpÉ^Å[ÉìÇ©ÇÁìæÇΩä¬ã´ÇìKóp
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  -- e2 ÇÃêÑò_
  (s3, t2) <- inferExpr env' e2
  -- ëSëÃÇÃíuä∑
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)
-- 8. if éÆ
inferExpr env (EIf cond eThen eElse) = do
  (s1, tCond) <- inferExpr env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExpr env1 eThen
  (s3, tElse) <- inferExpr (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-- 9. case éÆ
inferExpr env (ECase scrut branches) = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results
-- 10. É^ÉvÉã
inferExpr env (ETuple es) = do
  inferred <- mapM (inferExpr env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))
-- 11. ÉäÉXÉg
inferExpr env (EList es) = do
  inferred <- mapM (inferExpr env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))
-- Where
inferExpr env (EWhere e binds) = do
  -- ñ{ëÃÇêÑò_
  (s1, t1) <- inferExpr env e
  -- ñ{ëÃÇÃÉXÉRÅ[ÉvÇégÇ¡Çƒ where ÇÃíËã`ÇêÑò_
  env' <- foldM inferBinding (applyEnv s1 env) binds
  -- where ÇÃíËã`ÇÕÉXÉRÅ[ÉvÇ…âeãøÇµÇ»Ç¢ÇÃÇ≈ÅAå^ÇÕ t1 ÇÃÇ‹Ç‹ï‘Ç∑
  return (s1, t1)
-- do
inferExpr env (EDo stmts) = inferDo env stmts
inferExpr env (EBinOp op e1 e2) = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)

inferDo :: TypeEnv -> [Stmt] -> Either InferError (Subst, Type)
inferDo env [] =
  Left (InferOther "Empty do block")
inferDo env [ExprStmt e] =
  inferExpr env e -- ç≈å„ÇÃéÆÇÃå^Ç™ do ÇÃå^
inferDo env (stmt : rest) = do
  (s1, env1) <- inferStmt env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt :: TypeEnv -> Stmt -> Either InferError (Subst, TypeEnv)
inferStmt env (ExprStmt e) = do
  (s, _) <- inferExpr env e
  return (s, env)
inferStmt env (LetStmt binds) =
  inferBindings env binds
inferStmt env (Bind pat e) = do
  -- éÆÇÃå^ÇêÑò_
  (s1, t1) <- inferExpr env e

  -- ÉpÉ^Å[ÉìÇÃå^ÇêÑò_
  (s2, env2, tPat) <- inferPattern pat

  -- unify ÇÃÉGÉâÅ[Ç InferError Ç…ïœä∑
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- íuä∑Ççáê¨
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- ä¬ã´Ç…ìKóp
  let env' = applyEnv s env2

  return (s, env')

inferBinding :: TypeEnv -> (Pattern, Expr) -> Either InferError TypeEnv
inferBinding env (pat, expr) = do
  -- éÆÇÃå^ÇêÑò_
  (s1, t1) <- inferExpr env expr

  -- ÉpÉ^Å[ÉìÇÃå^ÇêÑò_
  (s2, env2, tPat) <- inferPattern pat

  -- unify ÇÃÉGÉâÅ[Ç InferError Ç…ïœä∑
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s

  -- íuä∑Ççáê¨
  let s = s3 `composeSubst` s2 `composeSubst` s1

  -- ä¬ã´Ç…íuä∑ÇìKóp
  let env' = applyEnv s env2

  return env'

-- êÈåæÇÃå^êÑò_ÅiÇ‹ÇæçúäiÇæÇØÅj
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats body -> do
    -- ÉpÉ^Å[ÉìÇ≤Ç∆Ç…å^êÑò_
    (sPats, envPats, argTypes) <- inferPatterns pats

    -- ÉpÉ^Å[ÉìÇ≈ägí£ÇµÇΩä¬ã´Ç≈ body ÇêÑò_
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body

    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)

    Right (extendEnv env name scheme, s)
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)

inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- âºÇÃå^Çä¬ã´Ç…ì¸ÇÍÇÈÅiçƒãAëŒâûÅj
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)

  -- äe clause ÇÃå^ÇêÑò_
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]

  -- unify ÇµÇƒ 1 Ç¬ÇÃå^Ç…Ç‹Ç∆ÇﬂÇÈ
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)

  -- generalize
  let scheme = generalizeInfer env finalType

  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats

  -- Åö ä÷êîå^ÇÇ±Ç±Ç≈çÏÇÈ
  let funType = foldr TArrow tBody argTypes

  Right (s, funType)

freshVar :: Int -> Type
freshVar n = TVar ("t" ++ show n)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- ïœêîÉpÉ^Å[Éì
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- íPàÍïœêîÇÃ PApp ÉpÉ^Å[ÉìÅiÇ†Ç»ÇΩÇÃÉpÅ[ÉTÅ[Ç™ê∂ê¨Ç∑ÇÈå`Åj
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- Åö í«â¡ÅFPApp ÇÃàÍî å`Åià¯êîÇ»ÇµÅj
  PApp p [] -> inferPattern p
  {-}
  -- ïœêîÉpÉ^Å[Éì
  PVar v ->
    let t = TVar ("t_" ++ v)
        env = extendEnv emptyEnv v (Forall [] t)
     in Right (emptySubst, env, t)
     -}
  -- êÆêîÉäÉeÉâÉã
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ÉèÉCÉãÉhÉJÅ[Éh
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- ÉäÉXÉgÉpÉ^Å[Éì [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- ëSóvëfÇÃå^Ç t0 Ç∆ unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- É^ÉvÉãÉpÉ^Å[Éì (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- ÉRÉìÉXÉgÉâÉNÉ^ÉpÉ^Å[Éì Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons ÉpÉ^Å[Éì (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As ÉpÉ^Å[Éì x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokVLBrace,TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sExpr",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "CaseAlt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "x",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EInt",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBool",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EString",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSymbol "<-",TokIdent "foldM",TokIdent "inferBinding",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "=",TokIdent "inferDo",TokIdent "env",TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "opType",TokSymbol "=",TokTypeIdent "TArrow",TokIdent "t1",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinEnv",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tOp",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokIdent "opType",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferDo",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Stmt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokIdent "body",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshVar",TokSymbol "::",TokTypeIdent "Int",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokIdent "n",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "InferError"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferDecl"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer" (Just [ExportType "InferError" True,ExportVar "inferExpr",ExportVar "inferDecl",ExportVar "inferProgram"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer" (Just [ExportType "InferError" True,ExportVar "inferExpr",ExportVar "inferDecl",ExportVar "inferProgram"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sExpr",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "CaseAlt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "trace",TokSymbol "(",TokString "inferPattern: ",TokOperator "++",TokIdent "show",TokIdent "pat",TokOperator "++",TokString " => ",TokOperator "++",TokIdent "show",TokIdent "envPat",TokSymbol ")",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExpr",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokIdent "tParam",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "x",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "x",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "x",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EInt",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBool",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EString",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s3",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELam",TokIdent "pat",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "env1",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "tPat",TokSymbol ")",TokIdent "tBody",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EIf",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "branches",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "ETuple",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EList",TokIdent "es",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExpr",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokIdent "env'",TokSymbol "<-",TokIdent "foldM",TokIdent "inferBinding",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EDo",TokIdent "stmts",TokSymbol ")",TokSymbol "=",TokIdent "inferDo",TokIdent "env",TokIdent "stmts",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "opType",TokSymbol "=",TokTypeIdent "TArrow",TokIdent "t1",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinEnv",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "op",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tOp",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "tOp",TokSymbol ")",TokIdent "opType",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferDo",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Stmt",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferBinding",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokIdent "body",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokIdent "body",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshVar",TokSymbol "::",TokTypeIdent "Int",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshVar",TokIdent "n",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokIdent "n",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Core.hs ===
-- Raw Source --
module TypeInference.Infer.Core
  ( counter,
    builtinPatternEnv,
    builtinOps,
    builtinEnv,
    generalizeInfer,
    groupDecls,
    unifyMany,
    mergeEnvs,
    freshTypeVar,
    InferResult,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

-- inferExpr ÇÃï‘ÇËílÅFå^Ç∆ë„ì¸
type InferResult = (Subst, Type)

freshTypeVar :: Either InferError Type
freshTypeVar =
  Right
    ( TVar
        ( "t"
            ++ show
              ( unsafePerformIO
                  ( do
                      n <- readIORef counter
                      writeIORef counter (n + 1)
                      return n
                  )
              )
        )
    )

counter :: IORef Int
counter = unsafePerformIO (newIORef 0)
{-# NOINLINE counter #-}

mergeEnvs :: TypeEnv -> TypeEnv -> TypeEnv
mergeEnvs (TypeEnv e1) (TypeEnv e2) =
  TypeEnv (M.union e1 e2)

builtinPatternEnv :: TypeEnv
builtinPatternEnv =
  TypeEnv
    ( M.fromList
        [ ("Just", Forall ["a"] (TArrow (TVar "a") (TApp (TCon "Maybe") (TVar "a")))),
          ("Nothing", Forall ["a"] (TApp (TCon "Maybe") (TVar "a"))),
          (":", Forall ["a"] (TArrow (TVar "a") (TArrow (TList (TVar "a")) (TList (TVar "a"))))),
          ("[]", Forall ["a"] (TList (TVar "a")))
        ]
    )

builtinOps :: [(String, Scheme)]
builtinOps =
  [ ("++", Forall [] (TArrow (TCon "String") (TArrow (TCon "String") (TCon "String")))),
    ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
    ("/", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int"))))
  ]

builtinEnv :: TypeEnv
builtinEnv = TypeEnv (M.fromList builtinOps)

generalizeInfer :: TypeEnv -> Type -> Scheme
generalizeInfer env t =
  let vars = nub (freeTypeVars t \\ freeTypeVarsEnv env)
   in Forall vars t

groupDecls :: [Decl] -> M.Map Name [Decl]
groupDecls decls =
  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _ _ _) <- decls]

--  M.fromListWith (++) [(name, [d]) | d@(DeclFun name _ _) <- decls]

unifyMany :: [Type] -> Either InferError Subst
unifyMany [] = Right emptySubst
unifyMany (t : ts) =
  foldM
    ( \sacc t' ->
        case unify (apply sacc t) (apply sacc t') of
          Left _ -> Left (InferMismatch (apply sacc t) (apply sacc t'))
          Right s -> Right (composeSubst s sacc)
    )
    emptySubst
    ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokVLBrace,TokSymbol "(",TokIdent "counter",TokSymbol ",",TokIdent "builtinPatternEnv",TokSymbol ",",TokIdent "builtinOps",TokSymbol ",",TokIdent "builtinEnv",TokSymbol ",",TokIdent "generalizeInfer",TokSymbol ",",TokIdent "groupDecls",TokSymbol ",",TokIdent "unifyMany",TokSymbol ",",TokIdent "mergeEnvs",TokSymbol ",",TokIdent "freshTypeVar",TokSymbol ",",TokTypeIdent "InferResult",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "counter"
<< exportItem: next token=TokIdent "builtinPatternEnv"
<< exportItem: next token=TokIdent "builtinOps"
<< exportItem: next token=TokIdent "builtinEnv"
<< exportItem: next token=TokIdent "generalizeInfer"
<< exportItem: next token=TokIdent "groupDecls"
<< exportItem: next token=TokIdent "unifyMany"
<< exportItem: next token=TokIdent "mergeEnvs"
<< exportItem: next token=TokIdent "freshTypeVar"
<< exportItem: next token=TokTypeIdent "InferResult"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Core" (Just [ExportVar "counter",ExportVar "builtinPatternEnv",ExportVar "builtinOps",ExportVar "builtinEnv",ExportVar "generalizeInfer",ExportVar "groupDecls",ExportVar "unifyMany",ExportVar "mergeEnvs",ExportVar "freshTypeVar",ExportType "InferResult" False])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Core" (Just [ExportVar "counter",ExportVar "builtinPatternEnv",ExportVar "builtinOps",ExportVar "builtinEnv",ExportVar "generalizeInfer",ExportVar "groupDecls",ExportVar "unifyMany",ExportVar "mergeEnvs",ExportVar "freshTypeVar",ExportType "InferResult" False]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokKeyword "type",TokTypeIdent "InferResult",TokSymbol "=",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "freshTypeVar",TokSymbol "::",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "freshTypeVar",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokVLBrace,TokSymbol "(",TokTypeIdent "TVar",TokSymbol "(",TokString "t",TokOperator "++",TokIdent "show",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol "(",TokKeyword "do",TokIdent "n",TokSymbol "<-",TokIdent "readIORef",TokIdent "counter",TokIdent "writeIORef",TokIdent "counter",TokSymbol "(",TokIdent "n",TokOperator "+",TokNumber 1,TokSymbol ")",TokKeyword "return",TokIdent "n",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "counter",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Int",TokNewline,TokIdent "counter",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokNumber 0,TokSymbol ")",TokNewline,TokIdent "mergeEnvs",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "mergeEnvs",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "e2",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "union",TokIdent "e1",TokIdent "e2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "builtinPatternEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinPatternEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "Just",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "Nothing",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TApp",TokSymbol "(",TokTypeIdent "TCon",TokString "Maybe",TokSymbol ")",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString ":",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "[]",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "builtinOps",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokTypeIdent "Scheme",TokSymbol ")",TokSymbol "]",TokNewline,TokIdent "builtinOps",TokSymbol "=",TokVLBrace,TokSymbol "[",TokSymbol "(",TokString "++",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokVLBrace,TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol ";",TokSymbol "(",TokString "/",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "]",TokVRBrace,TokNewline,TokIdent "builtinEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "builtinEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokIdent "builtinOps",TokSymbol ")",TokNewline,TokIdent "generalizeInfer",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalizeInfer",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "vars",TokSymbol "=",TokIdent "nub",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "freeTypeVarsEnv",TokIdent "env",TokSymbol ")",TokVLBrace,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "groupDecls",TokSymbol "::",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "Name",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokNewline,TokIdent "groupDecls",TokIdent "decls",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "fromListWith",TokSymbol "(",TokOperator "++",TokSymbol ")",TokSymbol "[",TokSymbol "(",TokIdent "name",TokSymbol ",",TokSymbol "[",TokIdent "d",TokSymbol "]",TokSymbol ")",TokSymbol "|",TokIdent "d",TokSymbol "@",TokSymbol "(",TokTypeIdent "DeclFun",TokIdent "name",TokSymbol "_",TokSymbol "_",TokSymbol "_",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "decls",TokSymbol "]",TokVRBrace,TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t",TokOperator ":",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t'",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t'",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "composeSubst",TokIdent "s",TokIdent "sacc",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokIdent "emptySubst",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprApp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprApp (inferApp) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferApp inferExprFn env e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  tv <- freshTypeVar
  s3 <- case unify (apply s2 t1) (TFun t2 tv) of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s tv)

{-}
-- TypeInference/Infer/Expr/ExprApp.hs
module TypeInference.Infer.Expr.ExprApp
  ( inferApp,
    inferLam,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferApp :: TypeEnv -> Expr -> Expr -> Either InferError (Subst, Type)
inferApp env e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  case unify (apply s2 t1) (TArrow t2 tv) of
    Left _ -> Left (InferMismatch (apply s2 t1) (TArrow t2 tv))
    Right s3 ->
      let s = s3 `composeSubst` s2 `composeSubst` s1
       in Right (s, apply s3 tv)

inferLam :: TypeEnv -> Pattern -> Expr -> Either InferError (Subst, Type)
inferLam env pat body = do
  (s1, env1, tPat) <- inferPattern pat
  (s2, tBody) <- inferExpr (applyEnv s1 (mergeEnvs env env1)) body
  let s = s2 `composeSubst` s1
  Right (s, TArrow (apply s tPat) tBody)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferApp",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferApp",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferApp"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprApp" (Just [ExportVar "inferApp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferApp"
<< decl parser called
<< decl dispatch: TokIdent "inferApp"
<< funDecl: next token=TokIdent "inferApp"
<< funClause: next token=TokIdent "inferApp"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferApp"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parsed type signature: inferApp :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< returning DeclTypeSig: DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< declBody: return DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< decl next token: TokIdent "inferApp"
<< decl parser called
<< decl dispatch: TokIdent "inferApp"
<< funDecl: next token=TokIdent "inferApp"
<< funClause: next token=TokIdent "inferApp"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "e1",PVar "e2"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "e1",PVar "e2"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "tv"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "s3"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s3") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokTypeIdent "TFun"
<< atomBaseCore next token: TokIdent "t2"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Left" []) [PVar "uerr"]
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PVar "su"]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferApp" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprApp" (Just [ExportVar "inferApp"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferApp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))),DeclFunGroup "inferApp" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TFun",TokIdent "t2",TokIdent "tv",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprBinOp.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprBinOp (inferBinOp) where

import AST.Expr (BinOp (..), Expr (..))
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  BinOp ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferBinOp inferExprFn env op e1 e2 = do
  (s1, t1) <- inferExprFn env e1
  (s2, t2) <- inferExprFn (applyEnv s1 env) e2
  let s12 = s2 `composeSubst` s1
  (arg1, arg2, result) <- case op of
    Add -> pure (TCon "Int", TCon "Int", TCon "Int")
    Sub -> pure (TCon "Int", TCon "Int", TCon "Int")
    Mul -> pure (TCon "Int", TCon "Int", TCon "Int")
    Div -> pure (TCon "Int", TCon "Int", TCon "Int")
    And -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Or -> pure (TCon "Bool", TCon "Bool", TCon "Bool")
    Eq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Neq -> do
      tv <- freshTypeVar
      pure (tv, tv, TCon "Bool")
    Lt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Gt -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Le -> pure (TCon "Int", TCon "Int", TCon "Bool")
    Ge -> pure (TCon "Int", TCon "Int", TCon "Bool")
  s3 <- case unify (apply s12 t1) arg1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right sA -> case unify (apply sA (apply s12 t2)) (apply sA arg2) of
      Left uerr -> Left (InferUnifyError uerr)
      Right sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)

{-}
  s3 <-
    unify (apply s12 t1) arg1
      >>= \sA ->
        unify (apply sA (apply s12 t2)) (apply sA arg2)
          >>= \sB -> Right (sB `composeSubst` sA)
  let s = s3 `composeSubst` s12
  Right (s, apply s result)
-}
{-}
-- TypeInference/Infer/Expr/ExprBinOp.hs
module TypeInference.Infer.Expr.ExprBinOp
  ( inferBinOp,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferBinOp :: TypeEnv -> String -> Expr -> Expr -> Either InferError (Subst, Type)
inferBinOp inferExpr env op e1 e2 = do
  (s1, t1) <- inferExpr env e1
  (s2, t2) <- inferExpr (applyEnv s1 env) e2
  tv <- freshTypeVar
  let opType = TArrow t1 (TArrow t2 tv)
  case lookupEnv builtinEnv op of
    Nothing -> Left (InferUnboundVariable op)
    Just sigma -> do
      tOp <- instantiate sigma
      s3 <- case unify (apply s2 tOp) opType of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let s = s3 `composeSubst` s2 `composeSubst` s1
      Right (s, apply s tv)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "BinOp",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferBinOp",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "BinOp",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinOp",TokIdent "inferExprFn",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "s12",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSymbol "<-",TokKeyword "case",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Add",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Neq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Lt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokIdent "arg1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sA",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sB",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "sB",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sA",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferBinOp"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprBinOp" (Just [ExportVar "inferBinOp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferBinOp"
<< decl parser called
<< decl dispatch: TokIdent "inferBinOp"
<< funDecl: next token=TokIdent "inferBinOp"
<< funClause: next token=TokIdent "inferBinOp"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferBinOp"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferBinOp :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferBinOp"
<< decl parser called
<< decl dispatch: TokIdent "inferBinOp"
<< funDecl: next token=TokIdent "inferBinOp"
<< funClause: next token=TokIdent "inferBinOp"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "op",PVar "e1",PVar "e2"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "op",PVar "e1",PVar "e2"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s12") []
<< expr dispatch: TokIdent "s2"
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokUnknown '`'
<< letStmt:binding next token: TokUnknown '`'
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferBinOp" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "op",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprBinOp" (Just [ExportVar "inferBinOp"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "BinOp",ImportTypeAll "Expr"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferBinOp" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "BinOp") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))),DeclFunGroup "inferBinOp" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "op",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "s12",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokSymbol "(",TokIdent "arg1",TokSymbol ",",TokIdent "arg2",TokSymbol ",",TokIdent "result",TokSymbol ")",TokSymbol "<-",TokKeyword "case",TokIdent "op",TokKeyword "of",TokVLBrace,TokTypeIdent "Add",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Sub",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Mul",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "Div",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ";",TokTypeIdent "And",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Or",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Eq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Neq",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokIdent "pure",TokSymbol "(",TokIdent "tv",TokSymbol ",",TokIdent "tv",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "Lt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Gt",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Le",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ";",TokTypeIdent "Ge",TokArrow,TokIdent "pure",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t1",TokSymbol ")",TokIdent "arg1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sA",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokSymbol "(",TokIdent "apply",TokIdent "s12",TokIdent "t2",TokSymbol ")",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sA",TokIdent "arg2",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "sB",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "sB",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sA",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s12",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "result",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprCase.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprCase (inferCase) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [CaseAlt] ->
  Either InferError (Subst, Type)
inferCase inferExprFn env scrut branches = do
  (sScrut, tScrut) <- inferExprFn env scrut
  results <- mapM (inferBranch inferExprFn env tScrut sScrut) branches
  unifyManyExpr results

inferBranch ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Type ->
  Subst ->
  CaseAlt ->
  Either InferError (Subst, Type)
inferBranch inferExprFn env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = sUnify `composeSubst` sPat `composeSubst` sScrut
  inferExprFn (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right su -> Right su
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)

{-}
-- TypeInference/Infer/Expr/ExprCase.hs
module TypeInference.Infer.Expr.ExprCase
  ( inferCase,
    inferBranch,
    unifyManyExpr,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferCase :: TypeEnv -> Expr -> [CaseAlt] -> Either InferError (Subst, Type)
inferCase inferExpr env scrut branches = do
  (sScrut, tScrut) <- inferExpr env scrut
  results <- mapM (inferBranch env tScrut sScrut) branches
  unifyManyExpr results

inferBranch :: TypeEnv -> Type -> Subst -> CaseAlt -> Either InferError (Subst, Type)
inferBranch env tScrut sScrut (CaseAlt pat expr) = do
  (sPat, envPat, tPat) <- inferPattern pat
  trace ("inferPattern: " ++ show pat ++ " => " ++ show envPat) $ do
    sUnify <- case unify (apply sPat tPat) (apply sPat tScrut) of
      Left uerr -> Left (InferUnifyError uerr)
      Right s -> Right s
    let s = sUnify `composeSubst` sPat `composeSubst` sScrut
    inferExpr (applyEnv s (mergeEnvs env envPat)) expr

unifyManyExpr :: [(Subst, Type)] -> Either InferError (Subst, Type)
unifyManyExpr [] = Left (InferOther "empty case")
unifyManyExpr ((s, t) : xs) = foldM step (s, t) xs
  where
    step (sAcc, tAcc) (sNext, tNext) = do
      sU <- case unify (apply sAcc tAcc) (apply sAcc tNext) of
        Left uerr -> Left (InferUnifyError uerr)
        Right s -> Right s
      let sFinal = sU `composeSubst` sNext `composeSubst` sAcc
      Right (sFinal, apply sFinal tAcc)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferCase",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "CaseAlt",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferCase",TokIdent "inferExprFn",TokIdent "env",TokIdent "scrut",TokIdent "branches",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sScrut",TokSymbol ",",TokIdent "tScrut",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "scrut",TokSymbol ";",TokIdent "results",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol ")",TokIdent "branches",TokSymbol ";",TokIdent "unifyManyExpr",TokIdent "results",TokVRBrace,TokNewline,TokIdent "inferBranch",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Type",TokArrow,TokSymbol ";",TokTypeIdent "Subst",TokArrow,TokSymbol ";",TokTypeIdent "CaseAlt",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBranch",TokIdent "inferExprFn",TokIdent "env",TokIdent "tScrut",TokIdent "sScrut",TokSymbol "(",TokTypeIdent "CaseAlt",TokIdent "pat",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokNewline,TokIdent "unifyManyExpr",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokIdent "xs",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sU",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sNext",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferCase"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprCase" (Just [ExportVar "inferCase"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferCase"
<< decl parser called
<< decl dispatch: TokIdent "inferCase"
<< funDecl: next token=TokIdent "inferCase"
<< funClause: next token=TokIdent "inferCase"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferCase"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "CaseAlt"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parsed type signature: inferCase :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< returning DeclTypeSig: DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< declBody: return DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< decl next token: TokIdent "inferCase"
<< decl parser called
<< decl dispatch: TokIdent "inferCase"
<< funDecl: next token=TokIdent "inferCase"
<< funClause: next token=TokIdent "inferCase"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "scrut",PVar "branches"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "scrut",PVar "branches"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "sScrut") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "tScrut") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "results"
<< pattern1: (pAs <|> makeCons)PApp (PVar "results") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferBranch"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokIdent "sScrut"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "branches"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "unifyManyExpr"
<< pattern1: (pAs <|> makeCons)PApp (PVar "unifyManyExpr") [PVar "results"]
<< expr dispatch: TokIdent "unifyManyExpr"
<< exprCore next token: TokIdent "unifyManyExpr"
<< atomBaseCore next token: TokIdent "unifyManyExpr"
<< atomBaseCore next token: TokIdent "results"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "inferBranch"
<< funClauseWithName: next token=TokIdent "inferBranch"
<< declBody: return DeclFunGroup "inferCase" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "scrut",PVar "branches"]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "scrut")),Bind (PApp (PVar "results") []) (EApp (EApp (EVar "mapM") (EApp (EApp (EApp (EApp (EVar "inferBranch") (EVar "inferExprFn")) (EVar "env")) (EVar "tScrut")) (EVar "sScrut"))) (EVar "branches")),ExprStmt (EApp (EVar "unifyManyExpr") (EVar "results"))])) Nothing]
<< decl next token: TokIdent "inferBranch"
<< decl parser called
<< decl dispatch: TokIdent "inferBranch"
<< funDecl: next token=TokIdent "inferBranch"
<< funClause: next token=TokIdent "inferBranch"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferBranch"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferBranch :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferBranch"
<< decl parser called
<< decl dispatch: TokIdent "inferBranch"
<< funDecl: next token=TokIdent "inferBranch"
<< funClause: next token=TokIdent "inferBranch"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "CaseAlt" []) [PVar "pat",PVar "expr"]
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "tScrut",PVar "sScrut",PApp (PConstr "CaseAlt" []) [PVar "pat",PVar "expr"]]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "tScrut",PVar "sScrut",PApp (PConstr "CaseAlt" []) [PVar "pat",PVar "expr"]]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "sUnify"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sUnify") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "tScrut"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Left" []) [PVar "uerr"]
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PVar "s"]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokVRBrace
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferBranch" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "tScrut",PVar "sScrut",PApp (PConstr "CaseAlt" []) [PVar "pat",PVar "expr"]]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprCase" (Just [ExportVar "inferCase"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferCase" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TList (TCon "CaseAlt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))),DeclFunGroup "inferCase" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "scrut",PVar "branches"]] Nothing (Just (EDo [Bind (PApp (PTuple [PApp (PVar "sScrut") [],PApp (PVar "tScrut") []]) []) (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "scrut")),Bind (PApp (PVar "results") []) (EApp (EApp (EVar "mapM") (EApp (EApp (EApp (EApp (EVar "inferBranch") (EVar "inferExprFn")) (EVar "env")) (EVar "tScrut")) (EVar "sScrut"))) (EVar "branches")),ExprStmt (EApp (EVar "unifyManyExpr") (EVar "results"))])) Nothing],DeclTypeSig "inferBranch" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Type") (TFun (TCon "Subst") (TFun (TCon "CaseAlt") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))),DeclFunGroup "inferBranch" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "tScrut",PVar "sScrut",PApp (PConstr "CaseAlt" []) [PVar "pat",PVar "expr"]]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tPat",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sPat",TokIdent "tScrut",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sScrut",TokSymbol ";",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPat",TokSymbol ")",TokSymbol ")",TokIdent "expr",TokVRBrace,TokNewline,TokIdent "unifyManyExpr",TokSymbol "::",TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "empty case",TokSymbol ")",TokNewline,TokIdent "unifyManyExpr",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokIdent "xs",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "sNext",TokSymbol ",",TokIdent "tNext",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tAcc",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sAcc",TokIdent "tNext",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sU",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sNext",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "apply",TokIdent "sFinal",TokIdent "tAcc",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDispatch.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDispatch (inferExpr) where

import AST.Expr
import AST.Type
import AST.Type (Type (..)) -- Ç±ÇÍÇ≈ TFun Ç»Ç«ÇÃÉRÉìÉXÉgÉâÉNÉ^Ç™égÇ¶ÇÈÇÊÇ§Ç…Ç»ÇÈ
import TypeInference.Error
import TypeInference.Infer.Expr.ExprApp (inferApp)
import TypeInference.Infer.Expr.ExprBinOp (inferBinOp)
import TypeInference.Infer.Expr.ExprCase (inferCase)
import TypeInference.Infer.Expr.ExprDo (inferDo)
import TypeInference.Infer.Expr.ExprIf (inferIf)
import TypeInference.Infer.Expr.ExprLet (inferLet, inferLetBlock, inferWhere)
import TypeInference.Infer.Expr.ExprLiteral (inferBool, inferInt, inferList, inferString, inferTuple)
import TypeInference.Infer.Expr.ExprSQL (inferSQL)
import TypeInference.Subst
import TypeInference.TypeEnv

-- ëºÇÃç\ï∂ÉÇÉWÉÖÅ[ÉãÇ‡Ç±Ç±Ç… import
inferExpr :: TypeEnv -> Expr -> Either InferError (Subst, Type)
inferExpr env (EVar name) =
  case lookupEnv env name of
    Nothing -> Left (InferUnboundVariable name)
    Just sigma -> do
      t <- instantiate sigma
      Right (emptySubst, t)
-- AST Ç≈íËã`Ç≥ÇÍÇΩå^Ç≈ï™äÚ Ç±Ç±Ç™åáëπÇ∑ÇÈÇ∆å^êÑò_Ç™Ç≈Ç´Ç»Ç≠Ç»ÇÈ
inferExpr env expr = case expr of
  ELet pat e1 e2 -> inferLet inferExpr env pat e1 e2
  ELetBlock binds body -> inferLetBlock inferExpr env binds body
  EWhere e binds -> inferWhere inferExpr env e binds
  EIf c t f -> inferIf inferExpr env c t f
  EDo stmts -> inferDo inferExpr env stmts
  ECase scrut alts -> inferCase inferExpr env scrut alts
  EApp e1 e2 -> inferApp inferExpr env e1 e2
  EBinOp op e1 e2 -> inferBinOp inferExpr env op e1 e2
  -- ÉäÉeÉâÉã
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple inferExpr env es
  EList es -> inferList inferExpr env es
  -- ägí£É^ÉCÉv SQL
  ESQL _ params -> inferSQL inferExpr env params

{-}
  ELetBlock binds body -> inferLetBlock env binds body
  ELet pat e1 e2 -> inferLet env pat e1 e2
  EWhere e binds -> inferWhere env e binds
  ECase scrut alts -> inferCase env scrut alts
  EApp e1 e2 -> inferApp env e1 e2
  ELam pat body -> inferLam env pat body
  EDo stmts -> inferDo env stmts
  EBinOp op e1 e2 -> inferBinOp env op e1 e2
  EInt _ -> inferInt
  EBool _ -> inferBool
  EString _ -> inferString
  ETuple es -> inferTuple env es
  EList es -> inferList env es
  ESQL _ params -> inferSQL env params
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprApp",TokSymbol "(",TokIdent "inferApp",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprBinOp",TokSymbol "(",TokIdent "inferBinOp",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprCase",TokSymbol "(",TokIdent "inferCase",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSymbol "(",TokIdent "inferDo",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokSymbol "(",TokIdent "inferIf",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokSymbol "(",TokIdent "inferBool",TokSymbol ",",TokIdent "inferInt",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferExpr",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferExpr",TokIdent "env",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "env",TokIdent "name",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnboundVariable",TokIdent "name",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "sigma",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "t",TokSymbol "<-",TokIdent "instantiate",TokIdent "sigma",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol "=",TokKeyword "case",TokIdent "expr",TokKeyword "of",TokVLBrace,TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferLet",TokIdent "inferExpr",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokArrow,TokIdent "inferLetBlock",TokIdent "inferExpr",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokArrow,TokIdent "inferWhere",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokIdent "c",TokIdent "t",TokIdent "f",TokArrow,TokIdent "inferIf",TokIdent "inferExpr",TokIdent "env",TokIdent "c",TokIdent "t",TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokIdent "stmts",TokArrow,TokIdent "inferDo",TokIdent "inferExpr",TokIdent "env",TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokArrow,TokIdent "inferCase",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferApp",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferBinOp",TokIdent "inferExpr",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokSymbol "_",TokArrow,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokSymbol "_",TokArrow,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokSymbol "_",TokArrow,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokIdent "es",TokArrow,TokIdent "inferTuple",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokIdent "es",TokArrow,TokIdent "inferList",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokArrow,TokIdent "inferSQL",TokIdent "inferExpr",TokIdent "env",TokIdent "params",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprDispatch" (Just [ExportVar "inferExpr"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprApp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferApp"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprBinOp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBinOp"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprCase", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferCase"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprDo", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferDo"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprIf", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferIf"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferLet",ImportVar "inferLetBlock",ImportVar "inferWhere"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLiteral", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBool",ImportVar "inferInt",ImportVar "inferList",ImportVar "inferString",ImportVar "inferTuple"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprSQL", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferSQL"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferExpr"
<< parseType dispatch: TokTypeIdent "TypeEnv"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parsed type signature: inferExpr :: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< returning DeclTypeSig: DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< declBody: return DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EVar" []) [PVar "name"]
<< patternParser: (pAs <|> makeCons)PApp (PVar "env") [PApp (PConstr "EVar" []) [PVar "name"]]
<< funClause: args=[PApp (PVar "env") [PApp (PConstr "EVar" []) [PVar "name"]]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "lookupEnv"
<< exprCore next token: TokIdent "lookupEnv"
<< atomBaseCore next token: TokIdent "lookupEnv"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Nothing" []) []
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokTypeIdent "InferUnboundVariable"
<< atomBaseCore next token: TokIdent "name"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Just" []) [PVar "sigma"]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "t"
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< expr dispatch: TokIdent "instantiate"
<< exprCore next token: TokIdent "instantiate"
<< atomBaseCore next token: TokIdent "instantiate"
<< atomBaseCore next token: TokIdent "sigma"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pattern1: (pAs <|> makeCons)PApp (PVar "emptySubst") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t") []
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PTuple [PApp (PVar "emptySubst") [],PApp (PVar "t") []]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferExpr"
<< patternParser: (pAs <|> makeCons)PApp (PVar "env") [PVar "expr"]
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELet" []) [PVar "pat",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELetBlock" []) [PVar "binds",PVar "body"]
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EWhere" []) [PVar "e",PVar "binds"]
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EIf" []) [PVar "c",PVar "t",PVar "f"]
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EDo" []) [PVar "stmts"]
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ECase" []) [PVar "scrut",PVar "alts"]
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EApp" []) [PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EBinOp" []) [PVar "op",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< declBody: return DeclFunGroup "inferExpr" [FunClause [PApp (PVar "env") [PApp (PConstr "EVar" []) [PVar "name"]]] Nothing (Just (ECase (EApp (EApp (EVar "lookupEnv") (EVar "env")) (EVar "name")) [CaseAlt (PApp (PConstr "Nothing" []) []) (EApp (EVarType "Left") (EApp (EVarType "InferUnboundVariable") (EVar "name"))),CaseAlt (PApp (PConstr "Just" []) [PVar "sigma"]) (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "instantiate") (EVar "sigma")),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EVar "t"]))])])) Nothing]
<< decl next token: TokIdent "inferExpr"
<< decl parser called
<< decl dispatch: TokIdent "inferExpr"
<< funDecl: next token=TokIdent "inferExpr"
<< funClause: next token=TokIdent "inferExpr"
<< patternParser: (pAs <|> makeCons)PApp (PVar "env") [PVar "expr"]
<< funClause: args=[PApp (PVar "env") [PVar "expr"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELet" []) [PVar "pat",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELetBlock" []) [PVar "binds",PVar "body"]
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EWhere" []) [PVar "e",PVar "binds"]
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EIf" []) [PVar "c",PVar "t",PVar "f"]
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EDo" []) [PVar "stmts"]
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ECase" []) [PVar "scrut",PVar "alts"]
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EApp" []) [PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EBinOp" []) [PVar "op",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< typeSigDecl: TokIdent "inferExpr"
<< valueDecl: TokIdent "inferExpr"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExpr") [PVar "env",PVar "expr"]
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "expr"
<< exprCore next token: TokIdent "expr"
<< atomBaseCore next token: TokIdent "expr"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELet" []) [PVar "pat",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferLet"
<< exprCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferLet"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ELetBlock" []) [PVar "binds",PVar "body"]
<< expr dispatch: TokIdent "inferLetBlock"
<< exprCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferLetBlock"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokIdent "body"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EWhere" []) [PVar "e",PVar "binds"]
<< expr dispatch: TokIdent "inferWhere"
<< exprCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferWhere"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokIdent "binds"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EIf" []) [PVar "c",PVar "t",PVar "f"]
<< expr dispatch: TokIdent "inferIf"
<< exprCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferIf"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "c"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EDo" []) [PVar "stmts"]
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ECase" []) [PVar "scrut",PVar "alts"]
<< expr dispatch: TokIdent "inferCase"
<< exprCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferCase"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "scrut"
<< atomBaseCore next token: TokIdent "alts"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EApp" []) [PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferApp"
<< exprCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferApp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "EBinOp" []) [PVar "op",PVar "e1",PVar "e2"]
<< expr dispatch: TokIdent "inferBinOp"
<< exprCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferBinOp"
<< atomBaseCore next token: TokIdent "inferExpr"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "op"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e2"
<< atomBaseCore next token: TokSymbol ";"
Just ([DeclModule "TypeInference.Infer.Expr.ExprDispatch" (Just [ExportVar "inferExpr"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprApp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferApp"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprBinOp", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBinOp"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprCase", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferCase"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprDo", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferDo"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprIf", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferIf"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferLet",ImportVar "inferLetBlock",ImportVar "inferWhere"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLiteral", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBool",ImportVar "inferInt",ImportVar "inferList",ImportVar "inferString",ImportVar "inferTuple"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprSQL", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferSQL"]},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "inferExpr" (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))),DeclFunGroup "inferExpr" [FunClause [PApp (PVar "env") [PApp (PConstr "EVar" []) [PVar "name"]]] Nothing (Just (ECase (EApp (EApp (EVar "lookupEnv") (EVar "env")) (EVar "name")) [CaseAlt (PApp (PConstr "Nothing" []) []) (EApp (EVarType "Left") (EApp (EVarType "InferUnboundVariable") (EVar "name"))),CaseAlt (PApp (PConstr "Just" []) [PVar "sigma"]) (EDo [Bind (PApp (PVar "t") []) (EApp (EVar "instantiate") (EVar "sigma")),ExprStmt (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EVar "t"]))])])) Nothing]],[TokNewline,TokIdent "inferExpr",TokIdent "env",TokIdent "expr",TokSymbol "=",TokKeyword "case",TokIdent "expr",TokKeyword "of",TokVLBrace,TokTypeIdent "ELet",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferLet",TokIdent "inferExpr",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "ELetBlock",TokIdent "binds",TokIdent "body",TokArrow,TokIdent "inferLetBlock",TokIdent "inferExpr",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol ";",TokTypeIdent "EWhere",TokIdent "e",TokIdent "binds",TokArrow,TokIdent "inferWhere",TokIdent "inferExpr",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol ";",TokTypeIdent "EIf",TokIdent "c",TokIdent "t",TokIdent "f",TokArrow,TokIdent "inferIf",TokIdent "inferExpr",TokIdent "env",TokIdent "c",TokIdent "t",TokIdent "f",TokSymbol ";",TokTypeIdent "EDo",TokIdent "stmts",TokArrow,TokIdent "inferDo",TokIdent "inferExpr",TokIdent "env",TokIdent "stmts",TokSymbol ";",TokTypeIdent "ECase",TokIdent "scrut",TokIdent "alts",TokArrow,TokIdent "inferCase",TokIdent "inferExpr",TokIdent "env",TokIdent "scrut",TokIdent "alts",TokSymbol ";",TokTypeIdent "EApp",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferApp",TokIdent "inferExpr",TokIdent "env",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokTypeIdent "EBinOp",TokIdent "op",TokIdent "e1",TokIdent "e2",TokArrow,TokIdent "inferBinOp",TokIdent "inferExpr",TokIdent "env",TokIdent "op",TokIdent "e1",TokIdent "e2",TokSymbol ";",TokSymbol ";",TokTypeIdent "EInt",TokSymbol "_",TokArrow,TokIdent "inferInt",TokSymbol ";",TokTypeIdent "EBool",TokSymbol "_",TokArrow,TokIdent "inferBool",TokSymbol ";",TokTypeIdent "EString",TokSymbol "_",TokArrow,TokIdent "inferString",TokSymbol ";",TokTypeIdent "ETuple",TokIdent "es",TokArrow,TokIdent "inferTuple",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokTypeIdent "EList",TokIdent "es",TokArrow,TokIdent "inferList",TokIdent "inferExpr",TokIdent "env",TokIdent "es",TokSymbol ";",TokSymbol ";",TokTypeIdent "ESQL",TokSymbol "_",TokIdent "params",TokArrow,TokIdent "inferSQL",TokIdent "inferExpr",TokIdent "env",TokIdent "params",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprDo.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprDo (inferDo, inferStmt) where

import AST.Expr
import AST.Type
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprLet (inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferDo ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Stmt] ->
  Either InferError (Subst, Type)
inferDo inferExprFn env [] =
  Left (InferOther "Empty do block")
inferDo inferExprFn env [ExprStmt e] =
  inferExprFn env e
inferDo inferExprFn env (stmt : rest) = do
  (s1, env1) <- inferStmt inferExprFn env stmt
  let env' = applyEnv s1 env1
  (s2, t2) <- inferDo inferExprFn env' rest
  return (s2 `composeSubst` s1, t2)

inferStmt ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Stmt ->
  Either InferError (Subst, TypeEnv)
inferStmt inferExprFn env (ExprStmt e) = do
  (s, _) <- inferExprFn env e
  return (s, env)
inferStmt inferExprFn env (LetStmt binds) =
  inferBindings inferExprFn env binds
inferStmt inferExprFn env (Bind pat e) = do
  (s1, t1) <- inferExprFn env e
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return (s, env')


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDo",TokSymbol "(",TokIdent "inferDo",TokSymbol ",",TokIdent "inferStmt",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokSymbol "(",TokIdent "inferBindings",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferDo",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Stmt",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Empty do block",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol "]",TokSymbol "=",TokVLBrace,TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokVRBrace,TokNewline,TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "stmt",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Stmt",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferDo"
<< exportItem: next token=TokIdent "inferStmt"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprDo" (Just [ExportVar "inferDo",ExportVar "inferStmt"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBindings"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferDo"
<< decl parser called
<< decl dispatch: TokIdent "inferDo"
<< funDecl: next token=TokIdent "inferDo"
<< funClause: next token=TokIdent "inferDo"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferDo"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Stmt"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferDo :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferDo"
<< decl parser called
<< decl dispatch: TokIdent "inferDo"
<< funDecl: next token=TokIdent "inferDo"
<< funClause: next token=TokIdent "inferDo"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PList []]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PList []]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokTypeIdent "InferOther"
<< atomBaseCore next token: TokString "Empty do block"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferDo"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "ExprStmt" []) [PVar "e"]
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PConstr "ExprStmt" []) [PVar "e"]]]
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "e"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "inferDo"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "env1") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "env1") []]) []
<< expr dispatch: TokIdent "inferStmt"
<< exprCore next token: TokIdent "inferStmt"
<< atomBaseCore next token: TokIdent "inferStmt"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "stmt"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "env'") []
<< expr dispatch: TokIdent "applyEnv"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "env1"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t2") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s2") [],PApp (PVar "t2") []]) []
<< expr dispatch: TokIdent "inferDo"
<< exprCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferDo"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env'"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokUnknown '`'
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokUnknown '`'
<< exprCore next token: TokIdent "s2"
<< atomBaseCore next token: TokIdent "s2"
<< atomBaseCore next token: TokUnknown '`'
<< atomBaseCore next token: TokSymbol "("
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferDo" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PList []]] Nothing (Just (EApp (EVarType "Left") (EApp (EVarType "InferOther") (EString "Empty do block")))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PConstr "ExprStmt" []) [PVar "e"]]]] Nothing (Just (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e"))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprDo" (Just [ExportVar "inferDo",ExportVar "inferStmt"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr.ExprLet", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferBindings"]},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferDo" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Stmt")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferDo" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PList []]] Nothing (Just (EApp (EVarType "Left") (EApp (EVarType "InferOther") (EString "Empty do block")))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PList [PApp (PConstr "ExprStmt" []) [PVar "e"]]]] Nothing (Just (EApp (EApp (EVar "inferExprFn") (EVar "env")) (EVar "e"))) Nothing,FunClause [PApp (PVar "inferExprFn") [PVar "env",PCons (PApp (PVar "stmt") []) (PApp (PVar "rest") [])]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ")",TokSymbol "<-",TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokIdent "stmt",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s1",TokIdent "env1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferDo",TokIdent "inferExprFn",TokIdent "env'",TokIdent "rest",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Stmt",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "ExprStmt",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "LetStmt",TokIdent "binds",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokVRBrace,TokNewline,TokIdent "inferStmt",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokTypeIdent "Bind",TokIdent "pat",TokIdent "e",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env'",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprIf.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprIf
  ( inferIf,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
-- import TypeInference.Infer.Expr.CoreExpr (inferExpr)
-- import TypeInference.Infer.Expr.ExprLet (inferBinding, inferBindings)
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferIf ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)

{-}
inferIf inferExprFn env cond eThen eElse = do
  (s1, tCond) <- inferExprFn env cond
  sBool <- case unify tCond (TCon "Bool") of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let env1 = applyEnv (sBool `composeSubst` s1) env
  (s2, tThen) <- inferExprFn env1 eThen
  (s3, tElse) <- inferExprFn (applyEnv s2 env1) eElse
  s4 <- case unify (apply s3 tThen) tElse of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s4 `composeSubst` s3 `composeSubst` s2 `composeSubst` s1
  Right (s, apply s4 tElse)
-}

-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprIf",TokVLBrace,TokSymbol "(",TokIdent "inferIf",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferIf",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferIf",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokIdent "eThen",TokIdent "eElse",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferIf"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprIf" (Just [ExportVar "inferIf"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferIf"
<< decl parser called
<< decl dispatch: TokIdent "inferIf"
<< funDecl: next token=TokIdent "inferIf"
<< funClause: next token=TokIdent "inferIf"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferIf"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferIf :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferIf"
<< decl parser called
<< decl dispatch: TokIdent "inferIf"
<< funDecl: next token=TokIdent "inferIf"
<< funClause: next token=TokIdent "inferIf"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "cond",PVar "eThen",PVar "eElse"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "cond",PVar "eThen",PVar "eElse"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "tCond") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "tCond") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "cond"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "sBool"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sBool") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "tCond"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Left" []) [PVar "uerr"]
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PVar "su"]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferIf" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "cond",PVar "eThen",PVar "eElse"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprIf" (Just [ExportVar "inferIf"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferIf" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))),DeclFunGroup "inferIf" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "cond",PVar "eThen",PVar "eElse"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "tCond",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "cond",TokSymbol ";",TokIdent "sBool",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "tCond",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "env1",TokSymbol "=",TokIdent "applyEnv",TokSymbol "(",TokIdent "sBool",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokIdent "env",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "tThen",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env1",TokIdent "eThen",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "tElse",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s2",TokIdent "env1",TokSymbol ")",TokIdent "eElse",TokSymbol ";",TokIdent "s4",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s3",TokIdent "tThen",TokSymbol ")",TokIdent "tElse",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s4",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "apply",TokIdent "s4",TokIdent "tElse",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLet.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLet
  ( inferLet,
    inferLetBlock,
    inferWhere,
    inferBindings,
    inferBinding,
  )
where

import AST.Expr
import AST.Pattern
import AST.Type
import Control.Monad (foldM)
import qualified Data.Map as M
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferLet ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Pattern ->
  Expr ->
  Expr ->
  Either InferError (Subst, Type)
inferLet inferExprFn env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExprFn (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExprFn env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferBindings ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, TypeEnv)
inferBindings inferExprFn env [] = Right (emptySubst, emptyEnv)
inferBindings inferExprFn env ((pat, expr) : rest) = do
  (sPat, envPat, tPat) <- inferPattern pat
  (sExpr, tExpr) <- inferExprFn (applyEnv sPat env) expr
  sUnify <- case unify (apply sExpr tPat) tExpr of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = sUnify `composeSubst` sExpr `composeSubst` sPat
  let env' = applyEnv s envPat
  (sRest, envRest) <- inferBindings inferExprFn (applyEnv s env) rest
  let sFinal = sRest `composeSubst` s
  let envFinal = mergeEnvs env' envRest
  Right (sFinal, envFinal)

inferLetBlock ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [(Pattern, Expr)] ->
  Expr ->
  Either InferError (Subst, Type)
inferLetBlock inferExprFn env binds body = do
  (sBinds, envBinds) <- inferBindings inferExprFn env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExprFn env'' body

inferWhere ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  Expr ->
  [(Pattern, Expr)] ->
  Either InferError (Subst, Type)
inferWhere inferExprFn env e binds = do
  (s1, t1) <- inferExprFn env e
  _ <- foldM (inferBinding inferExprFn) (applyEnv s1 env) binds
  return (s1, t1)

inferBinding ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  (Pattern, Expr) ->
  Either InferError TypeEnv
inferBinding inferExprFn env (pat, expr) = do
  (s1, t1) <- inferExprFn env expr
  (s2, env2, tPat) <- inferPattern pat
  s3 <- case unify t1 tPat of
    Left uerr -> Left (InferUnifyError uerr)
    Right s -> Right s
  let s = s3 `composeSubst` s2 `composeSubst` s1
  let env' = applyEnv s env2
  return env'

-- ìØólÇ… inferLetBlock, inferWhere, inferBindings, inferBinding Ç‡ inferExprFn Çà¯êîÇ…éÊÇÈÇÊÇ§Ç…ïœçX
{-}
inferLet :: TypeEnv -> Pattern -> Expr -> Expr -> Either InferError (Subst, Type)
inferLet inferExpr env pat e1 e2 = do
  (sPat, envPat, tPat) <- inferPattern pat
  (s1, t1) <- inferExpr (applyEnv sPat env) e1
  s2 <- case unify (apply s1 tPat) t1 of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s = s2 `composeSubst` s1 `composeSubst` sPat
  let env' = mergeEnvs (applyEnv s env) (applyEnv s envPat)
  (s3, t2) <- inferExpr env' e2
  let sFinal = s3 `composeSubst` s
  Right (sFinal, t2)

inferLetBlock :: TypeEnv -> [(Pattern, Expr)] -> Expr -> Either InferError (Subst, Type)
inferLetBlock inferBindings env binds body = do
  (sBinds, envBinds) <- inferBindings env binds
  let env' = mergeEnvs envBinds env
  let env'' = applyEnv sBinds env'
  inferExpr env'' body

inferWhere :: TypeEnv -> Expr -> [(Pattern, Expr)] -> Either InferError (Subst, Type)
inferWhere inferExpr inferBinding env e binds = do
  (s1, t1) <- inferExpr env e
  _ <- foldM inferBinding (applyEnv s1 env) binds
  return (s1, t1)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLet",TokVLBrace,TokSymbol "(",TokIdent "inferLet",TokSymbol ",",TokIdent "inferLetBlock",TokSymbol ",",TokIdent "inferWhere",TokSymbol ",",TokIdent "inferBindings",TokSymbol ",",TokIdent "inferBinding",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferLet",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Pattern",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLet",TokIdent "inferExprFn",TokIdent "env",TokIdent "pat",TokIdent "e1",TokIdent "e2",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sExpr",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferWhere",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferWhere",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "_",TokSymbol "<-",TokIdent "foldM",TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokVRBrace,TokNewline,TokIdent "inferBinding",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferLet"
<< exportItem: next token=TokIdent "inferLetBlock"
<< exportItem: next token=TokIdent "inferWhere"
<< exportItem: next token=TokIdent "inferBindings"
<< exportItem: next token=TokIdent "inferBinding"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprLet" (Just [ExportVar "inferLet",ExportVar "inferLetBlock",ExportVar "inferWhere",ExportVar "inferBindings",ExportVar "inferBinding"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferLet"
<< decl parser called
<< decl dispatch: TokIdent "inferLet"
<< funDecl: next token=TokIdent "inferLet"
<< funClause: next token=TokIdent "inferLet"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferLet"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< parsed type signature: inferLet :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))
<< returning DeclTypeSig: DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< declBody: return DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))))
<< decl next token: TokIdent "inferLet"
<< decl parser called
<< decl dispatch: TokIdent "inferLet"
<< funDecl: next token=TokIdent "inferLet"
<< funClause: next token=TokIdent "inferLet"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "pat",PVar "e1",PVar "e2"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "pat",PVar "e1",PVar "e2"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "sPat") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "envPat") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "tPat") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "sPat") [],PApp (PVar "envPat") [],PApp (PVar "tPat") []]) []
<< expr dispatch: TokIdent "inferPattern"
<< exprCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "inferPattern"
<< atomBaseCore next token: TokIdent "pat"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []
<< expr dispatch: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "applyEnv"
<< atomBaseCore next token: TokIdent "sPat"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokIdent "s2"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s2") []
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "unify"
<< exprCore next token: TokIdent "unify"
<< atomBaseCore next token: TokIdent "unify"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s1"
<< atomBaseCore next token: TokIdent "tPat"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Left" []) [PVar "uerr"]
<< expr dispatch: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "Left"
<< atomBaseCore next token: TokTypeIdent "Left"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokTypeIdent "InferUnifyError"
<< atomBaseCore next token: TokIdent "uerr"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PVar "su"]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "su"
<< atomBaseCore next token: TokVRBrace
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferLet" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "pat",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprLet" (Just [ExportVar "inferLet",ExportVar "inferLetBlock",ExportVar "inferWhere",ExportVar "inferBindings",ExportVar "inferBinding"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Pattern", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclTypeSig "inferLet" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TCon "Pattern") (TFun (TCon "Expr") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))))),DeclFunGroup "inferLet" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "pat",PVar "e1",PVar "e2"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "e1",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tPat",TokSymbol ")",TokIdent "t1",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env'",TokIdent "e2",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ")",TokNewline,TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sPat",TokSymbol ",",TokIdent "envPat",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokSymbol "(",TokIdent "sExpr",TokSymbol ",",TokIdent "tExpr",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPat",TokIdent "env",TokSymbol ")",TokIdent "expr",TokSymbol ";",TokIdent "sUnify",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sExpr",TokIdent "tPat",TokSymbol ")",TokIdent "tExpr",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sUnify",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sExpr",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sPat",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "envPat",TokSymbol ";",TokSymbol "(",TokIdent "sRest",TokSymbol ",",TokIdent "envRest",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokSymbol "(",TokIdent "applyEnv",TokIdent "s",TokIdent "env",TokSymbol ")",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "sFinal",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokKeyword "let",TokIdent "envFinal",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env'",TokIdent "envRest",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "sFinal",TokSymbol ",",TokIdent "envFinal",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferLetBlock",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokIdent "body",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sBinds",TokSymbol ",",TokIdent "envBinds",TokSymbol ")",TokSymbol "<-",TokIdent "inferBindings",TokIdent "inferExprFn",TokIdent "env",TokIdent "binds",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "envBinds",TokIdent "env",TokSymbol ";",TokKeyword "let",TokIdent "env''",TokSymbol "=",TokIdent "applyEnv",TokIdent "sBinds",TokIdent "env'",TokSymbol ";",TokIdent "inferExprFn",TokIdent "env''",TokIdent "body",TokVRBrace,TokNewline,TokIdent "inferWhere",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokTypeIdent "Expr",TokArrow,TokSymbol ";",TokSymbol "[",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferWhere",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokIdent "binds",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "e",TokSymbol ";",TokSymbol "_",TokSymbol "<-",TokIdent "foldM",TokSymbol "(",TokIdent "inferBinding",TokIdent "inferExprFn",TokSymbol ")",TokSymbol "(",TokIdent "applyEnv",TokIdent "s1",TokIdent "env",TokSymbol ")",TokIdent "binds",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferBinding",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol ",",TokTypeIdent "Expr",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokVRBrace,TokNewline,TokIdent "inferBinding",TokIdent "inferExprFn",TokIdent "env",TokSymbol "(",TokIdent "pat",TokSymbol ",",TokIdent "expr",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "env",TokIdent "expr",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tPat",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "pat",TokSymbol ";",TokIdent "s3",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokIdent "t1",TokIdent "tPat",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "s3",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "applyEnv",TokIdent "s",TokIdent "env2",TokSymbol ";",TokKeyword "return",TokIdent "env'",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprLiteral.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprLiteral
  ( inferInt,
    inferBool,
    inferString,
    inferTuple,
    inferList,
  )
where

import AST.Expr
import AST.Type
import Control.Monad (mapM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

inferInt = Right (emptySubst, TCon "Int")

inferBool = Right (emptySubst, TCon "Bool")

inferString = Right (emptySubst, TCon "String")

inferTuple ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferTuple inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  let substs = map fst inferred
  let types = map snd inferred
  let s = foldl composeSubst emptySubst substs
  Right (s, TTuple (map (apply s) types))

inferList ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferList inferExprFn env es = do
  inferred <- mapM (inferExprFn env) es
  case inferred of
    [] -> do
      tv <- freshTypeVar
      Right (emptySubst, TList tv)
    ((s1, t1) : rest) -> do
      sRest <- unifyList t1 rest
      let s = sRest `composeSubst` s1
      Right (s, TList (apply s t1))

unifyList :: Type -> [(Subst, Type)] -> Either InferError Subst
unifyList t [] = Right emptySubst
unifyList t ((s, tElem) : rest) = do
  sU <- case unify (apply s t) tElem of
    Left uerr -> Left (InferUnifyError uerr)
    Right su -> Right su
  let s' = sU `composeSubst` s
  unifyList (apply s' t) rest


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprLiteral",TokVLBrace,TokSymbol "(",TokIdent "inferInt",TokSymbol ",",TokIdent "inferBool",TokSymbol ",",TokIdent "inferString",TokSymbol ",",TokIdent "inferTuple",TokSymbol ",",TokIdent "inferList",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "mapM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferInt",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokNewline,TokIdent "inferBool",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokNewline,TokIdent "inferString",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TCon",TokString "String",TokSymbol ")",TokNewline,TokIdent "inferTuple",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferTuple",TokIdent "inferExprFn",TokIdent "env",TokIdent "es",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "let",TokIdent "substs",TokSymbol "=",TokIdent "map",TokIdent "fst",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "types",TokSymbol "=",TokIdent "map",TokIdent "snd",TokIdent "inferred",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "foldl",TokIdent "composeSubst",TokIdent "emptySubst",TokIdent "substs",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "types",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferList",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferList",TokIdent "inferExprFn",TokIdent "env",TokIdent "es",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "unifyList",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokIdent "tElem",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "sU",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferInt"
<< exportItem: next token=TokIdent "inferBool"
<< exportItem: next token=TokIdent "inferString"
<< exportItem: next token=TokIdent "inferTuple"
<< exportItem: next token=TokIdent "inferList"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprLiteral" (Just [ExportVar "inferInt",ExportVar "inferBool",ExportVar "inferString",ExportVar "inferTuple",ExportVar "inferList"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "mapM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]}
<< decl next token: TokIdent "inferInt"
<< decl parser called
<< decl dispatch: TokIdent "inferInt"
<< funDecl: next token=TokIdent "inferInt"
<< funClause: next token=TokIdent "inferInt"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Int"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "inferBool"
<< funClauseWithName: next token=TokIdent "inferBool"
<< declBody: return DeclFunGroup "inferInt" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Int")]))) Nothing]
<< decl next token: TokIdent "inferBool"
<< decl parser called
<< decl dispatch: TokIdent "inferBool"
<< funDecl: next token=TokIdent "inferBool"
<< funClause: next token=TokIdent "inferBool"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "Bool"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "inferString"
<< funClauseWithName: next token=TokIdent "inferString"
<< declBody: return DeclFunGroup "inferBool" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Bool")]))) Nothing]
<< decl next token: TokIdent "inferString"
<< decl parser called
<< decl dispatch: TokIdent "inferString"
<< funDecl: next token=TokIdent "inferString"
<< funClause: next token=TokIdent "inferString"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Right"
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokTypeIdent "TCon"
<< atomBaseCore next token: TokString "String"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "inferTuple"
<< funClauseWithName: next token=TokIdent "inferTuple"
<< declBody: return DeclFunGroup "inferString" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "String")]))) Nothing]
<< decl next token: TokIdent "inferTuple"
<< decl parser called
<< decl dispatch: TokIdent "inferTuple"
<< funDecl: next token=TokIdent "inferTuple"
<< funClause: next token=TokIdent "inferTuple"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferTuple"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferTuple :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferTuple"
<< decl parser called
<< decl dispatch: TokIdent "inferTuple"
<< funDecl: next token=TokIdent "inferTuple"
<< funClause: next token=TokIdent "inferTuple"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "es"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "inferred"
<< pattern1: (pAs <|> makeCons)PApp (PVar "inferred") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "es"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "substs") []
<< expr dispatch: TokIdent "map"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "fst"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "types") []
<< expr dispatch: TokIdent "map"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "snd"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokSymbol ";"
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< expr dispatch: TokIdent "foldl"
<< exprCore next token: TokIdent "foldl"
<< atomBaseCore next token: TokIdent "foldl"
<< atomBaseCore next token: TokIdent "composeSubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "substs"
<< atomBaseCore next token: TokSymbol ";"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s"]
<< pattern1: (pAs <|> makeCons)PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TTuple" []) [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PTuple [PApp (PVar "s") [],PApp (PConstr "TTuple" []) [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]]]
<< letStmt:binding next token: TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "apply") [PVar "s"]
<< pattern1: (pAs <|> makeCons)PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TTuple" []) [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PTuple [PApp (PVar "s") [],PApp (PConstr "TTuple" []) [PApp (PVar "map") [PApp (PVar "apply") [PVar "s"],PVar "types"]]]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TTuple"
<< atomBaseCore next token: TokTypeIdent "TTuple"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "map"
<< atomBaseCore next token: TokIdent "map"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "apply"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "types"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokIdent "inferList"
<< funClauseWithName: next token=TokIdent "inferList"
<< declBody: return DeclFunGroup "inferTuple" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),LetStmt [(PApp (PVar "substs") [],EApp (EApp (EVar "map") (EVar "fst")) (EVar "inferred"))],LetStmt [(PApp (PVar "types") [],EApp (EApp (EVar "map") (EVar "snd")) (EVar "inferred"))],LetStmt [(PApp (PVar "s") [],EApp (EApp (EApp (EVar "foldl") (EVar "composeSubst")) (EVar "emptySubst")) (EVar "substs"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TTuple") (EApp (EApp (EVar "map") (EApp (EVar "apply") (EVar "s"))) (EVar "types"))]))])) Nothing]
<< decl next token: TokIdent "inferList"
<< decl parser called
<< decl dispatch: TokIdent "inferList"
<< funDecl: next token=TokIdent "inferList"
<< funClause: next token=TokIdent "inferList"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferList"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferList :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferList"
<< decl parser called
<< decl dispatch: TokIdent "inferList"
<< funDecl: next token=TokIdent "inferList"
<< funClause: next token=TokIdent "inferList"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "es"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "inferred"
<< pattern1: (pAs <|> makeCons)PApp (PVar "inferred") []
<< expr dispatch: TokIdent "mapM"
<< exprCore next token: TokIdent "mapM"
<< atomBaseCore next token: TokIdent "mapM"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "inferExprFn"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "es"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "case"
<< expr dispatch: TokKeyword "case"
<< expr dispatch: TokIdent "inferred"
<< exprCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokIdent "inferred"
<< atomBaseCore next token: TokKeyword "of"
<< pattern1: (pAs <|> makeCons)PApp (PList []) []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "tv"
<< pattern1: (pAs <|> makeCons)PApp (PVar "tv") []
<< expr dispatch: TokIdent "freshTypeVar"
<< exprCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokIdent "freshTypeVar"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokTypeIdent "Right"
<< pattern1: (pAs <|> makeCons)PApp (PVar "emptySubst") []
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TList" []) [PVar "tv"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "Right" []) [PTuple [PApp (PVar "emptySubst") [],PApp (PConstr "TList" []) [PVar "tv"]]]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TList"
<< atomBaseCore next token: TokTypeIdent "TList"
<< atomBaseCore next token: TokIdent "tv"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< pattern1: (pAs <|> makeCons)PApp (PVar "s1") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "t1") []
<< pattern1: (pAs <|> makeCons)PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])
<< pattern1: (pAs <|> makeCons)PApp (PCons (PApp (PTuple [PApp (PVar "s1") [],PApp (PVar "t1") []]) []) (PApp (PVar "rest") [])) []
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokIdent "sRest"
<< pattern1: (pAs <|> makeCons)PApp (PVar "sRest") []
<< expr dispatch: TokIdent "unifyList"
<< exprCore next token: TokIdent "unifyList"
<< atomBaseCore next token: TokIdent "unifyList"
<< atomBaseCore next token: TokIdent "t1"
<< atomBaseCore next token: TokIdent "rest"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "let"
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< expr dispatch: TokIdent "sRest"
<< exprCore next token: TokIdent "sRest"
<< atomBaseCore next token: TokIdent "sRest"
<< atomBaseCore next token: TokUnknown '`'
<< letStmt:binding next token: TokUnknown '`'
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokIdent "inferred"
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferList" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprLiteral" (Just [ExportVar "inferInt",ExportVar "inferBool",ExportVar "inferString",ExportVar "inferTuple",ExportVar "inferList"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "mapM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Unify", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unify"]},DeclFunGroup "inferInt" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Int")]))) Nothing],DeclFunGroup "inferBool" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "Bool")]))) Nothing],DeclFunGroup "inferString" [FunClause [] Nothing (Just (EApp (EVarType "Right") (ETuple [EVar "emptySubst",EApp (EVarType "TCon") (EString "String")]))) Nothing],DeclTypeSig "inferTuple" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferTuple" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] Nothing (Just (EDo [Bind (PApp (PVar "inferred") []) (EApp (EApp (EVar "mapM") (EApp (EVar "inferExprFn") (EVar "env"))) (EVar "es")),LetStmt [(PApp (PVar "substs") [],EApp (EApp (EVar "map") (EVar "fst")) (EVar "inferred"))],LetStmt [(PApp (PVar "types") [],EApp (EApp (EVar "map") (EVar "snd")) (EVar "inferred"))],LetStmt [(PApp (PVar "s") [],EApp (EApp (EApp (EVar "foldl") (EVar "composeSubst")) (EVar "emptySubst")) (EVar "substs"))],ExprStmt (EApp (EVarType "Right") (ETuple [EVar "s",EApp (EVarType "TTuple") (EApp (EApp (EVar "map") (EApp (EVar "apply") (EVar "s"))) (EVar "types"))]))])) Nothing],DeclTypeSig "inferList" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferList" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "es"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferExprFn",TokIdent "env",TokSymbol ")",TokIdent "es",TokSymbol ";",TokKeyword "case",TokIdent "inferred",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokTypeIdent "TList",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "(",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "sRest",TokSymbol "<-",TokIdent "unifyList",TokIdent "t1",TokIdent "rest",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "sRest",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "unifyList",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyList",TokIdent "t",TokSymbol "(",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "tElem",TokSymbol ")",TokOperator ":",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "sU",TokSymbol "<-",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokIdent "tElem",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokIdent "uerr",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferUnifyError",TokIdent "uerr",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "su",TokArrow,TokTypeIdent "Right",TokIdent "su",TokVRBrace,TokNewline,TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "sU",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s",TokSymbol ";",TokIdent "unifyList",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t",TokSymbol ")",TokIdent "rest",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr/ExprSQL.hs ===
-- Raw Source --
module TypeInference.Infer.Expr.ExprSQL (inferSQL) where

import AST.Expr
import AST.Type
import Control.Monad (foldM)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Subst
import TypeInference.TypeEnv

inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env params = do
  (s, _) <- foldM step (emptySubst, env) params
  return (s, TUnit)
  where
    step (sAcc, envAcc) param = do
      (sParam, _) <- inferExprFn envAcc param
      let sNew = sParam `composeSubst` sAcc
      let envNew = applyEnv sNew envAcc
      return (sNew, envNew)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokSymbol "(",TokIdent "inferSQL",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferSQL",TokSymbol "::",TokVLBrace,TokSymbol "(",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Expr",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokSymbol ")",TokArrow,TokSymbol ";",TokTypeIdent "TypeEnv",TokArrow,TokSymbol ";",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokSymbol ";",TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferSQL",TokIdent "inferExprFn",TokIdent "env",TokIdent "params",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferSQL"
<< declBody: return DeclModule "TypeInference.Infer.Expr.ExprSQL" (Just [ExportVar "inferSQL"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "inferSQL"
<< parseType dispatch: TokVLBrace
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TCon "Expr"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Subst"
<< parseTypeCore: TCon "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])
<< parseTypeCore: TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))
<< parseTypeCore: TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))
<< parseTypeCore: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< parsed type signature: inferSQL :: TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))
<< returning DeclTypeSig: DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< declBody: return DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))))
<< decl next token: TokIdent "inferSQL"
<< decl parser called
<< decl dispatch: TokIdent "inferSQL"
<< funDecl: next token=TokIdent "inferSQL"
<< funClause: next token=TokIdent "inferSQL"
<< patternParser: (pAs <|> makeCons)PApp (PVar "inferExprFn") [PVar "env",PVar "params"]
<< funClause: args=[PApp (PVar "inferExprFn") [PVar "env",PVar "params"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokKeyword "do"
<< expr dispatch: TokKeyword "do"
<< doStmt next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "s") []
<< pattern1: (pAs <|> makeCons)PApp PWildcard []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "s") [],PApp PWildcard []]) []
<< expr dispatch: TokIdent "foldM"
<< exprCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "foldM"
<< atomBaseCore next token: TokIdent "step"
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "env"
<< atomBaseCore next token: TokIdent "env"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "params"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "return"
<< expr dispatch: TokKeyword "return"
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "s"
<< atomBaseCore next token: TokIdent "s"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokTypeIdent "TUnit"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ";"
<< doStmt next token: TokKeyword "where"
<< expr dispatch: TokKeyword "where"
<< exprCore next token: TokKeyword "where"
<< atomBaseCore next token: TokKeyword "where"
<< doStmt next token: TokVLBrace
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokSymbol "("
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "inferSQL" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "params"]] Nothing (Just (EDo [])) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Infer.Expr.ExprSQL" (Just [ExportVar "inferSQL"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Infer.Core", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclTypeSig "inferSQL" (TFun (TFun (TCon "TypeEnv") (TFun (TCon "Expr") (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"])))) (TFun (TCon "TypeEnv") (TFun (TList (TCon "Expr")) (TApp (TApp (TCon "Either") (TCon "InferError")) (TTuple [TCon "Subst",TCon "Type"]))))),DeclFunGroup "inferSQL" [FunClause [PApp (PVar "inferExprFn") [PVar "env",PVar "params"]] Nothing (Just (EDo [])) Nothing]],[TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "foldM",TokIdent "step",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ")",TokIdent "params",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "s",TokSymbol ",",TokTypeIdent "TUnit",TokSymbol ")",TokSymbol ";",TokKeyword "where",TokVLBrace,TokIdent "step",TokSymbol "(",TokIdent "sAcc",TokSymbol ",",TokIdent "envAcc",TokSymbol ")",TokIdent "param",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "sParam",TokSymbol ",",TokSymbol "_",TokSymbol ")",TokSymbol "<-",TokIdent "inferExprFn",TokIdent "envAcc",TokIdent "param",TokSymbol ";",TokKeyword "let",TokIdent "sNew",TokSymbol "=",TokIdent "sParam",TokUnknown '`',TokIdent "composeSubst`",TokIdent "sAcc",TokSymbol ";",TokKeyword "let",TokIdent "envNew",TokSymbol "=",TokIdent "applyEnv",TokIdent "sNew",TokIdent "envAcc",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "sNew",TokSymbol ",",TokIdent "envNew",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Expr.hs ===
-- Raw Source --
module TypeInference.Infer.Expr
  ( inferExpr,
    inferProgram,
    inferDecl,
  )
where

import AST.Decl (Decl (..))
import AST.Expr
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import TypeInference.Error
import TypeInference.Infer.Core
import TypeInference.Infer.Expr.ExprDispatch (inferExpr)
import TypeInference.Infer.Expr.ExprSQL
import TypeInference.Infer.Pattern
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (unify)

-- declsÇÕAST
inferProgram :: TypeEnv -> [Decl] -> Either InferError TypeEnv
inferProgram env decls = do
  let groups = groupDecls decls
  foldM inferGroup env (M.toList groups)

inferGroup :: TypeEnv -> (Name, [Decl]) -> Either InferError TypeEnv
inferGroup env (name, clauses) = do
  -- âºÇÃå^Çä¬ã´Ç…ì¸ÇÍÇÈÅiçƒãAëŒâûÅj
  let tempType = TVar ("t_fun_" ++ name)
  let envTemp = extendEnv env name (Forall [] tempType)
  -- äe clause ÇÃå^ÇêÑò_
  inferred <- mapM (inferClause envTemp) clauses
  let funTypes = [apply s t | (s, t) <- inferred]
  -- unify ÇµÇƒ 1 Ç¬ÇÃå^Ç…Ç‹Ç∆ÇﬂÇÈ
  s <- unifyMany funTypes
  let finalType = apply s (head funTypes)
  -- generalize
  let scheme = generalizeInfer env finalType
  Right (extendEnv env name scheme)

inferClause :: TypeEnv -> Decl -> Either InferError (Subst, Type)
inferClause env (DeclFun _ pats Nothing (Just body) _) = do
  -- inferClause env (DeclFun _ pats body) = do
  (sPats, envPats, argTypes) <- inferPatterns pats
  let env' = mergeEnvs env envPats
  (sBody, tBody) <- inferExpr (applyEnv sPats env') body
  let s = composeSubst sBody sPats
  -- Åö ä÷êîå^ÇÇ±Ç±Ç≈çÏÇÈ
  let funType = foldr TArrow tBody argTypes
  Right (s, funType)

-- êÈåæÇÃå^êÑò_ÅiÇ‹ÇæçúäiÇæÇØÅj
inferDecl :: TypeEnv -> Decl -> Either InferError (TypeEnv, Subst)
inferDecl env decl = case decl of
  DeclTypeSig name ty ->
    let scheme = Forall [] ty
     in Right (extendEnv env name scheme, emptySubst)
  DeclFun name pats Nothing (Just body) _ -> do
    -- ÉKÅ[ÉhÇ»ÇµÅAéÆÇ†ÇË
    (sPats, envPats, argTypes) <- inferPatterns pats
    (sBody, tBody) <- inferExpr (applyEnv sPats (mergeEnvs env envPats)) body
    let funType = foldr TArrow tBody argTypes
    let s = composeSubst sBody sPats
    let scheme = generalizeInfer env (apply s funType)
    Right (extendEnv env name scheme, s)
  DeclFun _ _ (Just _) _ _ ->
    Left (InferOther "Guarded function inference not implemented yet")
  DeclValue pat expr ->
    Left (InferOther "DeclValue not implemented yet")
  _ ->
    Right (env, emptySubst)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokVLBrace,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokIdent "inferDecl",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokSymbol "_",TokSymbol "_",TokSymbol "(",TokTypeIdent "Just",TokSymbol "_",TokSymbol ")",TokSymbol "_",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Guarded function inference not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokIdent "inferDecl"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Expr" (Just [ExportVar "inferExpr",ExportVar "inferProgram",ExportVar "inferDecl"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Expr" (Just [ExportVar "inferExpr",ExportVar "inferProgram",ExportVar "inferDecl"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprDispatch",TokSymbol "(",TokIdent "inferExpr",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokDot,TokTypeIdent "ExprSQL",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferProgram",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferProgram",TokIdent "env",TokIdent "decls",TokSymbol "=",TokKeyword "do",TokVLBrace,TokKeyword "let",TokIdent "groups",TokSymbol "=",TokIdent "groupDecls",TokIdent "decls",TokSymbol ";",TokIdent "foldM",TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "toList",TokIdent "groups",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferGroup",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "(",TokTypeIdent "Name",TokSymbol ",",TokSymbol "[",TokTypeIdent "Decl",TokSymbol "]",TokSymbol ")",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "TypeEnv",TokNewline,TokIdent "inferGroup",TokIdent "env",TokSymbol "(",TokIdent "name",TokSymbol ",",TokIdent "clauses",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "tempType",TokSymbol "=",TokTypeIdent "TVar",TokSymbol "(",TokString "t_fun_",TokOperator "++",TokIdent "name",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "envTemp",TokSymbol "=",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tempType",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokIdent "inferred",TokSymbol "<-",TokIdent "mapM",TokSymbol "(",TokIdent "inferClause",TokIdent "envTemp",TokSymbol ")",TokIdent "clauses",TokSymbol ";",TokKeyword "let",TokIdent "funTypes",TokSymbol "=",TokSymbol "[",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "|",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "t",TokSymbol ")",TokSymbol "<-",TokIdent "inferred",TokSymbol "]",TokSymbol ";",TokSymbol ";",TokIdent "s",TokSymbol "<-",TokIdent "unifyMany",TokIdent "funTypes",TokSymbol ";",TokKeyword "let",TokIdent "finalType",TokSymbol "=",TokIdent "apply",TokIdent "s",TokSymbol "(",TokIdent "head",TokIdent "funTypes",TokSymbol ")",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokIdent "finalType",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferClause",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferClause",TokIdent "env",TokSymbol "(",TokTypeIdent "DeclFun",TokSymbol "_",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokKeyword "let",TokIdent "env'",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokIdent "env'",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "funType",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferDecl",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Decl",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Subst",TokSymbol ")",TokNewline,TokIdent "inferDecl",TokIdent "env",TokIdent "decl",TokSymbol "=",TokKeyword "case",TokIdent "decl",TokKeyword "of",TokVLBrace,TokTypeIdent "DeclTypeSig",TokIdent "name",TokIdent "ty",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "ty",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokIdent "name",TokIdent "pats",TokTypeIdent "Nothing",TokSymbol "(",TokTypeIdent "Just",TokIdent "body",TokSymbol ")",TokSymbol "_",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol "(",TokIdent "sPats",TokSymbol ",",TokIdent "envPats",TokSymbol ",",TokIdent "argTypes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "pats",TokSymbol ";",TokSymbol "(",TokIdent "sBody",TokSymbol ",",TokIdent "tBody",TokSymbol ")",TokSymbol "<-",TokIdent "inferExpr",TokSymbol "(",TokIdent "applyEnv",TokIdent "sPats",TokSymbol "(",TokIdent "mergeEnvs",TokIdent "env",TokIdent "envPats",TokSymbol ")",TokSymbol ")",TokIdent "body",TokSymbol ";",TokKeyword "let",TokIdent "funType",TokSymbol "=",TokIdent "foldr",TokTypeIdent "TArrow",TokIdent "tBody",TokIdent "argTypes",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "sBody",TokIdent "sPats",TokSymbol ";",TokKeyword "let",TokIdent "scheme",TokSymbol "=",TokIdent "generalizeInfer",TokIdent "env",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "funType",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "extendEnv",TokIdent "env",TokIdent "name",TokIdent "scheme",TokSymbol ",",TokIdent "s",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclFun",TokSymbol "_",TokSymbol "_",TokSymbol "(",TokTypeIdent "Just",TokSymbol "_",TokSymbol ")",TokSymbol "_",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "Guarded function inference not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "DeclValue",TokIdent "pat",TokIdent "expr",TokArrow,TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokString "DeclValue not implemented yet",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "env",TokSymbol ",",TokIdent "emptySubst",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer/Pattern.hs ===
-- Raw Source --
module TypeInference.Infer.Pattern
  ( inferPattern,
    inferPatterns,
    inferPatternApp,
  )
where

import AST.Decl (Decl (..))
-- import TypeInference.TypeEnv
import AST.Expr (CaseAlt (..), Expr (..), Name, Stmt (..))
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import qualified Control.Exception as TypeInference
import Control.Monad (foldM)
import Data.IORef
import Data.List (nub, (\\))
import qualified Data.Map as M
import Debug.Trace (trace, traceIO, traceShowId)
import System.IO.Unsafe (unsafePerformIO)
import TypeInference.Error (InferError (..))
import TypeInference.Infer.Core
-- import TypeInference.SQLInfer
import TypeInference.Subst
import TypeInference.TypeEnv
import TypeInference.Unify (UnifyError (..), unify)

inferPattern :: Pattern -> Either InferError (Subst, TypeEnv, Type)
inferPattern pat = case pat of
  -- ïœêîÉpÉ^Å[Éì
  PVar x -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- íPàÍïœêîÇÃ PApp ÉpÉ^Å[ÉìÅiÇ†Ç»ÇΩÇÃÉpÅ[ÉTÅ[Ç™ê∂ê¨Ç∑ÇÈå`Åj
  PApp (PVar x) [] -> do
    tv <- freshTypeVar
    let env = extendEnv emptyEnv x (Forall [] tv)
    Right (emptySubst, env, tv)
  -- Åö í«â¡ÅFPApp ÇÃàÍî å`Åià¯êîÇ»ÇµÅj
  PApp p [] -> inferPattern p
  -- êÆêîÉäÉeÉâÉã
  PInt _ ->
    Right (emptySubst, emptyEnv, TCon "Int")
  -- ÉèÉCÉãÉhÉJÅ[Éh
  PWildcard ->
    let t = TVar "t_wild"
     in Right (emptySubst, emptyEnv, t)
  -- ÉäÉXÉgÉpÉ^Å[Éì [a, b, c]
  PList ps -> do
    (s, env, ts) <- inferPatterns ps
    case ts of
      [] -> Right (s, env, TList (TVar "t_empty"))
      (t0 : _) -> do
        -- ëSóvëfÇÃå^Ç t0 Ç∆ unify
        -- s' <- foldM (\sacc t -> unify (apply sacc t) (apply sacc t0)) s ts
        s' <-
          foldM
            ( \sacc t ->
                case unify (apply sacc t) (apply sacc t0) of
                  Left _ ->
                    Left (InferMismatch (apply sacc t) (apply sacc t0))
                  Right s ->
                    Right s
            )
            s
            ts
        let tElem = apply s' t0
        Right (s', env, TList tElem)

  -- É^ÉvÉãÉpÉ^Å[Éì (a, b, c)
  PTuple ps -> do
    (s, env, ts) <- inferPatterns ps
    Right (s, env, TTuple ts)

  -- ÉRÉìÉXÉgÉâÉNÉ^ÉpÉ^Å[Éì Just x, Pair a b
  PConstr con args -> do
    case lookupEnv builtinPatternEnv con of
      Nothing -> Left (InferOther ("Unknown constructor: " ++ con))
      Just scheme -> do
        tCon <- instantiate scheme
        inferPatternApp tCon args

  -- Cons ÉpÉ^Å[Éì (x:xs)
  PCons p1 p2 -> do
    (s1, env1, t1) <- inferPattern p1
    (s2, env2, t2) <- inferPattern p2
    case unify (apply s2 t2) (TList t1) of
      Left _ -> Left (InferMismatch t2 (TList t1))
      Right s3 ->
        let s = composeSubst s3 (composeSubst s2 s1)
            env = mergeEnvs env1 env2
         in Right (s, env, apply s (TList t1))

  -- As ÉpÉ^Å[Éì x@p
  PAs name p -> do
    (s1, env1, t1) <- inferPattern p
    let env2 = extendEnv env1 name (Forall [] t1)
    Right (s1, env2, t1)

inferPatternApp :: Type -> [Pattern] -> Either InferError (Subst, TypeEnv, Type)
inferPatternApp tCon [] =
  Right (emptySubst, emptyEnv, tCon)
inferPatternApp tCon (p : ps) = do
  (s1, env1, tArg) <- inferPattern p
  let alpha = TVar "t_app"
  case unify (apply s1 tCon) (TArrow tArg alpha) of
    Left _ -> Left (InferMismatch (apply s1 tCon) (TArrow tArg alpha))
    Right s2 -> do
      (s3, env2, tRes) <- inferPatternApp (apply s2 alpha) ps
      let s = composeSubst s3 (composeSubst s2 s1)
      let env = mergeEnvs env1 env2
      Right (s, env, apply s tRes)

inferPatterns :: [Pattern] -> Either InferError (Subst, TypeEnv, [Type])
inferPatterns [] = Right (emptySubst, emptyEnv, [])
inferPatterns (p : ps) = do
  (s1, env1, t1) <- inferPattern p
  (s2, env2, ts) <- inferPatterns ps
  let s = composeSubst s2 s1
  let env = mergeEnvs env1 env2
  Right (s, env, t1 : ts)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Pattern",TokVLBrace,TokSymbol "(",TokIdent "inferPattern",TokSymbol ",",TokIdent "inferPatterns",TokSymbol ",",TokIdent "inferPatternApp",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ",",TokTypeIdent "Stmt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Control",TokDot,TokTypeIdent "Exception",TokKeyword "as",TokTypeIdent "TypeInference",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "foldM",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferPattern"
<< exportItem: next token=TokIdent "inferPatterns"
<< exportItem: next token=TokIdent "inferPatternApp"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer.Pattern" (Just [ExportVar "inferPattern",ExportVar "inferPatterns",ExportVar "inferPatternApp"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.Infer.Pattern" (Just [ExportVar "inferPattern",ExportVar "inferPatterns",ExportVar "inferPatternApp"]),DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name",ImportTypeAll "Stmt"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "Control.Exception", importAlias = Just "TypeInference", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "foldM"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Core",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "UnifyError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "unify",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokSymbol "::",TokTypeIdent "Pattern",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPattern",TokIdent "pat",TokSymbol "=",TokKeyword "case",TokIdent "pat",TokKeyword "of",TokVLBrace,TokSymbol ";",TokTypeIdent "PVar",TokIdent "x",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokSymbol "(",TokTypeIdent "PVar",TokIdent "x",TokSymbol ")",TokSymbol "[",TokSymbol "]",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tv",TokSymbol "<-",TokIdent "freshTypeVar",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "extendEnv",TokIdent "emptyEnv",TokIdent "x",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "tv",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "tv",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PApp",TokIdent "p",TokSymbol "[",TokSymbol "]",TokArrow,TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol ";",TokTypeIdent "PInt",TokSymbol "_",TokArrow,TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PWildcard",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "t",TokSymbol "=",TokTypeIdent "TVar",TokString "t_wild",TokVLBrace,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "t",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PList",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "case",TokIdent "ts",TokKeyword "of",TokVLBrace,TokSymbol "[",TokSymbol "]",TokArrow,TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokSymbol "(",TokTypeIdent "TVar",TokString "t_empty",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokSymbol "(",TokIdent "t0",TokOperator ":",TokSymbol "_",TokSymbol ")",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol ";",TokSymbol ";",TokIdent "s'",TokSymbol "<-",TokVLBrace,TokIdent "foldM",TokVLBrace,TokSymbol "(",TokSymbol "\\",TokIdent "sacc",TokIdent "t",TokArrow,TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokKeyword "of",TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "sacc",TokIdent "t0",TokSymbol ")",TokSymbol ")",TokTypeIdent "Right",TokIdent "s",TokArrow,TokTypeIdent "Right",TokIdent "s",TokSymbol ")",TokSymbol ";",TokIdent "s",TokSymbol ";",TokIdent "ts",TokVRBrace,TokVRBrace,TokNewline,TokKeyword "let",TokIdent "tElem",TokSymbol "=",TokIdent "apply",TokIdent "s'",TokIdent "t0",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s'",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TList",TokIdent "tElem",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PTuple",TokIdent "ps",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PConstr",TokIdent "con",TokIdent "args",TokArrow,TokKeyword "do",TokVLBrace,TokKeyword "case",TokIdent "lookupEnv",TokIdent "builtinPatternEnv",TokIdent "con",TokKeyword "of",TokVLBrace,TokTypeIdent "Nothing",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferOther",TokSymbol "(",TokString "Unknown constructor: ",TokOperator "++",TokIdent "con",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Just",TokIdent "scheme",TokArrow,TokKeyword "do",TokVLBrace,TokIdent "tCon",TokSymbol "<-",TokIdent "instantiate",TokIdent "scheme",TokSymbol ";",TokIdent "inferPatternApp",TokIdent "tCon",TokIdent "args",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PCons",TokIdent "p1",TokIdent "p2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p1",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t2",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p2",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "t2",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokIdent "t2",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s3",TokArrow,TokVLBrace,TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokVLBrace,TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokSymbol "(",TokTypeIdent "TList",TokIdent "t1",TokSymbol ")",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokSymbol ";",TokTypeIdent "PAs",TokIdent "name",TokIdent "p",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "env2",TokSymbol "=",TokIdent "extendEnv",TokIdent "env1",TokIdent "name",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokIdent "t1",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokTypeIdent "Type",TokSymbol ")",TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "tCon",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "inferPatternApp",TokIdent "tCon",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "tArg",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokKeyword "let",TokIdent "alpha",TokSymbol "=",TokTypeIdent "TVar",TokString "t_app",TokSymbol ";",TokKeyword "case",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokKeyword "of",TokVLBrace,TokTypeIdent "Left",TokSymbol "_",TokArrow,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "InferMismatch",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "tCon",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "tArg",TokIdent "alpha",TokSymbol ")",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokIdent "s2",TokArrow,TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s3",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "tRes",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatternApp",TokSymbol "(",TokIdent "apply",TokIdent "s2",TokIdent "alpha",TokSymbol ")",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s3",TokSymbol "(",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ")",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "apply",TokIdent "s",TokIdent "tRes",TokSymbol ")",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline,TokIdent "inferPatterns",TokSymbol "::",TokSymbol "[",TokTypeIdent "Pattern",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol ",",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokIdent "emptySubst",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokSymbol "[",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "inferPatterns",TokSymbol "(",TokIdent "p",TokOperator ":",TokIdent "ps",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokSymbol "(",TokIdent "s1",TokSymbol ",",TokIdent "env1",TokSymbol ",",TokIdent "t1",TokSymbol ")",TokSymbol "<-",TokIdent "inferPattern",TokIdent "p",TokSymbol ";",TokSymbol "(",TokIdent "s2",TokSymbol ",",TokIdent "env2",TokSymbol ",",TokIdent "ts",TokSymbol ")",TokSymbol "<-",TokIdent "inferPatterns",TokIdent "ps",TokSymbol ";",TokKeyword "let",TokIdent "s",TokSymbol "=",TokIdent "composeSubst",TokIdent "s2",TokIdent "s1",TokSymbol ";",TokKeyword "let",TokIdent "env",TokSymbol "=",TokIdent "mergeEnvs",TokIdent "env1",TokIdent "env2",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s",TokSymbol ",",TokIdent "env",TokSymbol ",",TokIdent "t1",TokOperator ":",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Infer.hs ===
-- Raw Source --
module TypeInference.Infer
  ( inferExpr,
    inferProgram,
    -- inferProgramPattern
  )
where

import TypeInference.Infer.Expr (inferExpr, inferProgram)

-- import TypeInference.Infer.Pattern
-- import TypeInference.Infer.Core


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokVLBrace,TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Infer",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokIdent "inferExpr",TokSymbol ",",TokIdent "inferProgram",TokSymbol ")",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "inferExpr"
<< exportItem: next token=TokIdent "inferProgram"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Infer" (Just [ExportVar "inferExpr",ExportVar "inferProgram"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferExpr",ImportVar "inferProgram"]}
Just ([DeclModule "TypeInference.Infer" (Just [ExportVar "inferExpr",ExportVar "inferProgram"]),DeclImport {importQualified = False, importModule = "TypeInference.Infer.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "inferExpr",ImportVar "inferProgram"]}],[TokNewline])

=== Running: src/TypeInference/Pretty.hs ===
-- Raw Source --
module TypeInference.Pretty (prettyType) where

-- import TypeInference.Subst
-- import TypeInference.Type (Type(..))
-- import qualified TypeInference.Type as TI

import AST.Type (Type(..))
import qualified AST.Type as TI

prettyType :: TI.Type -> String
prettyType ty = case ty of
  TVar v        -> v
  TCon c        -> c
  TUnit         -> "Unit"
  TArrow a b    -> "(" ++ prettyType a ++ " -> " ++ prettyType b ++ ")"
  TList t       -> "[" ++ prettyType t ++ "]"
  TApp a b      -> prettyType a ++ " " ++ prettyType b
  TForall vs t  -> "forall " ++ unwords vs ++ ". " ++ prettyType t
  TTuple ts     -> "(" ++ commaList (map prettyType ts) ++ ")"
  TConstraint cs t ->
      "(" ++ commaList (map show cs) ++ ") => " ++ prettyType t
  where
    commaList = foldr1 (\a b -> a ++ ", " ++ b)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Pretty",TokSymbol "(",TokIdent "prettyType",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokKeyword "as",TokTypeIdent "TI",TokNewline,TokIdent "prettyType",TokSymbol "::",TokTypeIdent "TI",TokDot,TokTypeIdent "Type",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokIdent "ty",TokSymbol "=",TokKeyword "case",TokIdent "ty",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "c",TokArrow,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokArrow,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "a",TokIdent "b",TokArrow,TokString "(",TokOperator "++",TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " -> ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TList",TokIdent "t",TokArrow,TokString "[",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokOperator "++",TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokIdent "a",TokIdent "b",TokArrow,TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t",TokArrow,TokString "forall ",TokOperator "++",TokIdent "unwords",TokIdent "vs",TokOperator "++",TokString ". ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t",TokArrow,TokVLBrace,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokOperator "++",TokString ") => ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "commaList",TokSymbol "=",TokIdent "foldr1",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "prettyType"
<< declBody: return DeclModule "TypeInference.Pretty" (Just [ExportVar "prettyType"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = True, importModule = "AST.Type", importAlias = Just "TI", importHiding = False, importItems = Nothing}
<< decl next token: TokIdent "prettyType"
<< decl parser called
<< decl dispatch: TokIdent "prettyType"
<< funDecl: next token=TokIdent "prettyType"
<< funClause: next token=TokIdent "prettyType"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "prettyType"
<< parseType dispatch: TokTypeIdent "TI"
<< parseTypeCore: TCon "TI"
<< parsed type signature: prettyType :: TCon "TI"
<< returning DeclTypeSig: DeclTypeSig "prettyType" (TCon "TI")
<< declBody: return DeclTypeSig "prettyType" (TCon "TI")
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "TypeInference.Pretty" (Just [ExportVar "prettyType"]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = True, importModule = "AST.Type", importAlias = Just "TI", importHiding = False, importItems = Nothing},DeclTypeSig "prettyType" (TCon "TI")],[TokDot,TokTypeIdent "Type",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "prettyType",TokIdent "ty",TokSymbol "=",TokKeyword "case",TokIdent "ty",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokIdent "c",TokArrow,TokIdent "c",TokSymbol ";",TokTypeIdent "TUnit",TokArrow,TokString "Unit",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "a",TokIdent "b",TokArrow,TokString "(",TokOperator "++",TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " -> ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TList",TokIdent "t",TokArrow,TokString "[",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokOperator "++",TokString "]",TokSymbol ";",TokTypeIdent "TApp",TokIdent "a",TokIdent "b",TokArrow,TokIdent "prettyType",TokIdent "a",TokOperator "++",TokString " ",TokOperator "++",TokIdent "prettyType",TokIdent "b",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t",TokArrow,TokString "forall ",TokOperator "++",TokIdent "unwords",TokIdent "vs",TokOperator "++",TokString ". ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokSymbol ";",TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "prettyType",TokIdent "ts",TokSymbol ")",TokOperator "++",TokString ")",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t",TokArrow,TokVLBrace,TokString "(",TokOperator "++",TokIdent "commaList",TokSymbol "(",TokIdent "map",TokIdent "show",TokIdent "cs",TokSymbol ")",TokOperator "++",TokString ") => ",TokOperator "++",TokIdent "prettyType",TokIdent "t",TokVRBrace,TokNewline,TokKeyword "where",TokVLBrace,TokIdent "commaList",TokSymbol "=",TokIdent "foldr1",TokSymbol "(",TokSymbol "\\",TokIdent "a",TokIdent "b",TokArrow,TokIdent "a",TokOperator "++",TokString ", ",TokOperator "++",TokIdent "b",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/SQLInfer.hs ===
-- Raw Source --
module TypeInference.SQLInfer where

import AST.Decl (Decl (..))
import AST.Expr (CaseAlt (..), Expr (..), Name)
import AST.Pattern (Pattern (..))
import AST.Type (Type (..))
import TypeInference.Error (InferError (..))
import TypeInference.Subst
import TypeInference.TypeEnv

data SQLInfo = SQLInfo
  { sqlText  :: String
  , sqlVars  :: [String]
  , sqlExprs :: [Expr]
  }

inferSQL :: String -> [Expr] -> SQLInfo
inferSQL sql args =
  SQLInfo
    { sqlText  = sql
    , sqlVars  = map getVarName args
    , sqlExprs = args
    }

getVarName :: Expr -> String
getVarName (EVar name) = name
getVarName _ = error "SQL arguments must be variables"

{-}
inferSQL ::
  (TypeEnv -> Expr -> Either InferError (Subst, Type)) ->
  TypeEnv ->
  String ->
  [Expr] ->
  Either InferError (Subst, Type)
inferSQL inferExprFn env sql args = do
  inferred <- mapM (inferExprFn env) args
  return (emptySubst, TUnit)
-}

{-}
inferSQL :: TypeEnv -> String -> [Expr] -> Either InferError (Subst, Type)
inferSQL env sql args = do
  -- args ÇÃå^ÇêÑò_
  argTypes <- mapM (inferExpr env) args

  -- SQLParam å^ÉNÉâÉXÇ…ëÆÇ∑ÇÈÇ©É`ÉFÉbÉNÅiîCà”Åj
  mapM_ ensureSQLParam (map snd argTypes)

  -- SQL ï∂é©ëÃÇÃå^ÇÕ Unit Ç≈ÇÊÇ¢
  return (emptySubst, TUnit)
-}


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "SQLInfer",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Decl",TokSymbol "(",TokTypeIdent "Decl",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "CaseAlt",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Expr",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Pattern",TokSymbol "(",TokTypeIdent "Pattern",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokNewline,TokKeyword "data",TokTypeIdent "SQLInfo",TokSymbol "=",TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "::",TokTypeIdent "String",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "::",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline,TokIdent "inferSQL",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokTypeIdent "SQLInfo",TokNewline,TokIdent "inferSQL",TokKeyword "sql",TokIdent "args",TokSymbol "=",TokVLBrace,TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "=",TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "=",TokIdent "map",TokIdent "getVarName",TokIdent "args",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "=",TokIdent "args",TokSymbol ";",TokSymbol "}",TokVRBrace,TokVRBrace,TokNewline,TokIdent "getVarName",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokIdent "name",TokNewline,TokIdent "getVarName",TokSymbol "_",TokSymbol "=",TokIdent "error",TokString "SQL arguments must be variables",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.SQLInfer" Nothing
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "InferError"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "SQLInfo"
<< constrS: next token TokTypeIdent "SQLInfo"
<< dataConstr: next token TokTypeIdent "SQLInfo"
<< dataConstr:2 []
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "SQLInfo" []
<< constrS:2 next token TokSymbol "{"
<< dataConstrRc: next token TokSymbol "{"
<< dataConstrNx: next token TokSymbol "{"
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "SQLInfo"
Just ([DeclModule "TypeInference.SQLInfer" Nothing,DeclImport {importQualified = False, importModule = "AST.Decl", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Decl"]},DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "CaseAlt",ImportTypeAll "Expr",ImportVar "Name"]},DeclImport {importQualified = False, importModule = "AST.Pattern", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Pattern"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "TypeInference.Error", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "InferError"]},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.TypeEnv", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokNewline,TokKeyword "data",TokTypeIdent "SQLInfo",TokSymbol "=",TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "::",TokTypeIdent "String",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "::",TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokSymbol ";",TokSymbol "}",TokVRBrace,TokNewline,TokIdent "inferSQL",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "[",TokTypeIdent "Expr",TokSymbol "]",TokArrow,TokTypeIdent "SQLInfo",TokNewline,TokIdent "inferSQL",TokKeyword "sql",TokIdent "args",TokSymbol "=",TokVLBrace,TokTypeIdent "SQLInfo",TokVLBrace,TokSymbol "{",TokIdent "sqlText",TokSymbol "=",TokKeyword "sql",TokSymbol ";",TokSymbol ",",TokIdent "sqlVars",TokSymbol "=",TokIdent "map",TokIdent "getVarName",TokIdent "args",TokSymbol ";",TokSymbol ",",TokIdent "sqlExprs",TokSymbol "=",TokIdent "args",TokSymbol ";",TokSymbol "}",TokVRBrace,TokVRBrace,TokNewline,TokIdent "getVarName",TokSymbol "::",TokTypeIdent "Expr",TokArrow,TokTypeIdent "String",TokNewline,TokIdent "getVarName",TokSymbol "(",TokTypeIdent "EVar",TokIdent "name",TokSymbol ")",TokSymbol "=",TokIdent "name",TokNewline,TokIdent "getVarName",TokSymbol "_",TokSymbol "=",TokIdent "error",TokString "SQL arguments must be variables",TokNewline])

=== Running: src/TypeInference/Subst.hs ===
-- Raw Source --
module TypeInference.Subst
  ( Subst,
    emptySubst,
    singletonSubst,
    composeSubst,
    apply,
  )
where

import AST.Type
import qualified Data.Map as M

-- å^ë„ì¸ÅFå^ïœêîñº Å® å^
type Subst = M.Map String Type

-- ãÛÇÃë„ì¸
emptySubst :: Subst
emptySubst = M.empty

-- íPàÍë„ì¸
singletonSubst :: String -> Type -> Subst
singletonSubst = M.singleton

-- ë„ì¸ÇÃçáê¨
-- s1 ÇêÊÇ…ìKópÇµÅAÇªÇÃåãâ Ç… s2 ÇìKópÇ∑ÇÈ
composeSubst :: Subst -> Subst -> Subst
composeSubst s1 s2 =
  M.map (apply s1) s2 `M.union` s1

-- å^Ç÷ÇÃë„ì¸ìKóp
apply :: Subst -> Type -> Type
apply s t = case t of
  TUnit ->
    TUnit
  TVar v ->
    case M.lookup v s of
      Just t' -> t'
      Nothing -> TVar v
  TCon c ->
    TCon c
  TArrow t1 t2 ->
    TArrow (apply s t1) (apply s t2)
  TList t1 ->
    TList (apply s t1)
  TApp t1 t2 ->
    TApp (apply s t1) (apply s t2)
  TConstraint cs t1 ->
    TConstraint (map (applyConstraint s) cs) (apply s t1)
  TForall vars t1 ->
    -- Forall ÇÃë©îõïœêîÇ…ÇÕë„ì¸ÇìKópÇµÇ»Ç¢
    let s' = foldr M.delete s vars
     in TForall vars (apply s' t1)
  TTuple ts ->
    TTuple (map (apply s) ts)

-- êßñÒÇ÷ÇÃë„ì¸ìKóp
applyConstraint :: Subst -> Constraint -> Constraint
applyConstraint s (Constraint cls ts) =
  Constraint cls (map (apply s) ts)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokVLBrace,TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "emptySubst",TokSymbol ",",TokIdent "singletonSubst",TokSymbol ",",TokIdent "composeSubst",TokSymbol ",",TokIdent "apply",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "type",TokTypeIdent "Subst",TokSymbol "=",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Type",TokNewline,TokIdent "emptySubst",TokSymbol "::",TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "singletonSubst",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokIdent "composeSubst",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokIdent "s1",TokIdent "s2",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "s2",TokUnknown '`',TokTypeIdent "M",TokDot,TokIdent "union`",TokIdent "s1",TokVRBrace,TokNewline,TokIdent "apply",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TUnit",TokArrow,TokVLBrace,TokTypeIdent "TUnit",TokVRBrace,TokNewline,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokVLBrace,TokKeyword "case",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "v",TokIdent "s",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "t'",TokArrow,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "TVar",TokIdent "v",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TCon",TokIdent "c",TokArrow,TokVLBrace,TokTypeIdent "TCon",TokIdent "c",TokVRBrace,TokNewline,TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TList",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TApp",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vars",TokIdent "t1",TokArrow,TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "foldr",TokTypeIdent "M",TokDot,TokIdent "delete",TokIdent "s",TokIdent "vars",TokVLBrace,TokKeyword "in",TokTypeIdent "TForall",TokIdent "vars",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokVLBrace,TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyConstraint",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokIdent "s",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Subst"
<< exportItem: next token=TokIdent "emptySubst"
<< exportItem: next token=TokIdent "singletonSubst"
<< exportItem: next token=TokIdent "composeSubst"
<< exportItem: next token=TokIdent "apply"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.Subst" (Just [ExportType "Subst" False,ExportVar "emptySubst",ExportVar "singletonSubst",ExportVar "composeSubst",ExportVar "apply"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "type"
<< decl parser called
<< decl dispatch: TokKeyword "type"
<< typeAliasDecl parser called
<< parseType dispatch: TokTypeIdent "M"
<< parseTypeCore: TCon "M"
<< declBody: return DeclTypeAlias "Subst" [] (TCon "M")
<< decl next token: TokDot
<< decl parser called
<< decl dispatch: TokDot
<< unknown token in decl: TokDot
Just ([DeclModule "TypeInference.Subst" (Just [ExportType "Subst" False,ExportVar "emptySubst",ExportVar "singletonSubst",ExportVar "composeSubst",ExportVar "apply"]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclTypeAlias "Subst" [] (TCon "M")],[TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Type",TokNewline,TokIdent "emptySubst",TokSymbol "::",TokTypeIdent "Subst",TokNewline,TokIdent "emptySubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "singletonSubst",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "singletonSubst",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "singleton",TokNewline,TokIdent "composeSubst",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "composeSubst",TokIdent "s1",TokIdent "s2",TokSymbol "=",TokVLBrace,TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "s2",TokUnknown '`',TokTypeIdent "M",TokDot,TokIdent "union`",TokIdent "s1",TokVRBrace,TokNewline,TokIdent "apply",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TUnit",TokArrow,TokVLBrace,TokTypeIdent "TUnit",TokVRBrace,TokNewline,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokVLBrace,TokKeyword "case",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "v",TokIdent "s",TokKeyword "of",TokVLBrace,TokTypeIdent "Just",TokIdent "t'",TokArrow,TokIdent "t'",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokTypeIdent "TVar",TokIdent "v",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TCon",TokIdent "c",TokArrow,TokVLBrace,TokTypeIdent "TCon",TokIdent "c",TokVRBrace,TokNewline,TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TArrow",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TList",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TList",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokVLBrace,TokTypeIdent "TApp",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t2",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokTypeIdent "TConstraint",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "applyConstraint",TokIdent "s",TokSymbol ")",TokIdent "cs",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t1",TokSymbol ")",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vars",TokIdent "t1",TokArrow,TokVLBrace,TokSymbol ";",TokKeyword "let",TokIdent "s'",TokSymbol "=",TokIdent "foldr",TokTypeIdent "M",TokDot,TokIdent "delete",TokIdent "s",TokIdent "vars",TokVLBrace,TokKeyword "in",TokTypeIdent "TForall",TokIdent "vars",TokSymbol "(",TokIdent "apply",TokIdent "s'",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokTypeIdent "TTuple",TokIdent "ts",TokArrow,TokVLBrace,TokTypeIdent "TTuple",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyConstraint",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Constraint",TokNewline,TokIdent "applyConstraint",TokIdent "s",TokSymbol "(",TokTypeIdent "Constraint",TokIdent "cls",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Constraint",TokIdent "cls",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s",TokSymbol ")",TokIdent "ts",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/Type.hs ===
-- Raw Source --
module TypeInference.Type where

data Type
  = TVar String
  | TCon String
  | TArrow Type Type
  | TList Type
  | TApp Type Type
  | TConstraint [Constraint] Type
  | TForall [String] Type
  | TTuple [Type]
  | TUnit
  deriving (Eq, Show)

-- Constraint ÇÃíËã`Ç™Ç‹Çæñ≥Ç¢èÍçáÇÕâºÇ≈íuÇ≠
data Constraint = Constraint String
  deriving (Eq, Show)


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Type",TokKeyword "where",TokNewline,TokKeyword "data",TokTypeIdent "Type",TokVLBrace,TokSymbol "=",TokTypeIdent "TVar",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TCon",TokTypeIdent "String",TokSymbol ";",TokSymbol "|",TokTypeIdent "TArrow",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TList",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TApp",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TConstraint",TokSymbol "[",TokTypeIdent "Constraint",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TForall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "TTuple",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokSymbol ";",TokSymbol "|",TokTypeIdent "TUnit",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "data",TokTypeIdent "Constraint",TokSymbol "=",TokTypeIdent "Constraint",TokTypeIdent "String",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< declBody: return DeclModule "TypeInference.Type" Nothing
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "TVar"
<< constrS: next token TokTypeIdent "TVar"
<< dataConstr: next token TokTypeIdent "TVar"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "TVar" [TCon "String"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "Type"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Constraint"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "String"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol "["
<< dataConstrNx: next token TokSymbol "|"
<< parseTypeCore: TCon "Type"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokSymbol ";"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" []]
<< dataDecl:4 next token ["Eq","Show"]
<< declBody: return DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" []] ["Eq","Show"]
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "Constraint"
<< constrS: next token TokTypeIdent "Constraint"
<< dataConstr: next token TokTypeIdent "Constraint"
<< dataConstr:2 [TCon "String"]
<< dataConstr:3 next token TokVLBrace
<< constrS:1 next token TokVLBrace Constraint "Constraint" [TCon "String"]
<< constrS:2 next token TokKeyword "deriving"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< constrS:2 next token TokVLBrace
<< dataConstrOne: next token TokTypeIdent "Constraint"
<< dataConstrOne:2 [TCon "String"]
<< dataConstrOne:3 next token TokVLBrace
<< constrOne: next token TokVLBrace Constraint "Constraint" [TCon "String"]
<< dataDecl:2 next token TokVLBrace[Constraint "Constraint" [TCon "String"]]
<< dataDecl:4 next token []
<< declBody: return DeclData "Constraint" [] [Constraint "Constraint" [TCon "String"]] []
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "TypeInference.Type" Nothing,DeclData "Type" [] [Constraint "TVar" [TCon "String"],Constraint "TCon" [TCon "String"],Constraint "TArrow" [TCon "Type",TCon "Type"],Constraint "TList" [TCon "Type"],Constraint "TApp" [TCon "Type",TCon "Type"],Constraint "TConstraint" [TList (TCon "Constraint"),TCon "Type"],Constraint "TForall" [TList (TCon "String"),TCon "Type"],Constraint "TTuple" [TList (TCon "Type")],Constraint "TUnit" []] ["Eq","Show"],DeclData "Constraint" [] [Constraint "Constraint" [TCon "String"]] []],[TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Eq",TokSymbol ",",TokTypeIdent "Show",TokSymbol ")",TokVRBrace,TokNewline])

=== Running: src/TypeInference/TypeEnv.hs ===
-- Raw Source --
module TypeInference.TypeEnv
  ( Scheme (..),
    TypeEnv (..),
    emptyEnv,
    extendEnv,
    lookupEnv,
    generalize,
    instantiate,
    applyEnv,
    freeTypeVarsScheme,
    freeTypeVarsEnv,
    freeTypeVars,
  )
where

import AST.Expr (Name)
import AST.Type
import AST.Type (Type (..))
import Data.List (nub, (\\))
import qualified Data.Map as M
import TypeInference.Error (InferError (..))
import TypeInference.Subst

-- å^ÉXÉLÅ[ÉÄÅFforall a b. t
data Scheme = Forall [String] Type
  deriving (Show, Eq)

-- å^ä¬ã´ÅFïœêîñº Å® å^ÉXÉLÅ[ÉÄ
newtype TypeEnv = TypeEnv (M.Map String Scheme)
  deriving (Show, Eq)

{-}
emptyEnv :: TypeEnv
emptyEnv = TypeEnv M.empty
-}

ftv :: Type -> Subst
ftv TUnit = M.empty

emptyEnv :: TypeEnv
emptyEnv = primitiveEnv

extendEnv :: TypeEnv -> String -> Scheme -> TypeEnv
extendEnv (TypeEnv env) x s = TypeEnv (M.insert x s env)

lookupEnv :: TypeEnv -> String -> Maybe Scheme
lookupEnv (TypeEnv env) x = M.lookup x env

freeTypeVarsEnv :: TypeEnv -> [Name]
freeTypeVarsEnv (TypeEnv env) =
  nub (concatMap freeTypeVarsScheme (M.elems env))

freeTypeVarsScheme :: Scheme -> [Name]
freeTypeVarsScheme (Forall vars t) =
  freeTypeVars t \\ vars

-- å^ÇÃé©óRïœêîÇèWÇﬂÇÈ
freeTypeVars :: Type -> [String]
freeTypeVars t = case t of
  TVar v -> [v]
  TCon _ -> []
  TArrow t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TList t1 -> freeTypeVars t1
  TApp t1 t2 -> freeTypeVars t1 ++ freeTypeVars t2
  TConstraint cs t1 ->
    concatMap freeConstraintVars cs ++ freeTypeVars t1
  TForall vs t1 ->
    filter (`notElem` vs) (freeTypeVars t1)

freeConstraintVars :: Constraint -> [String]
freeConstraintVars (Constraint _ ts) =
  concatMap freeTypeVars ts

-- ä¬ã´ÇÃé©óRå^ïœêî
freeEnvVars :: TypeEnv -> [String]
freeEnvVars (TypeEnv env) =
  concatMap (\(Forall _ t) -> freeTypeVars t) (M.elems env)

-- àÍî âªÅFenv ÇÃé©óRïœêîÇèúÇ¢ÇΩå^ïœêîÇ forall Ç≈ë©îõÇ∑ÇÈ
generalize :: TypeEnv -> Type -> Scheme
generalize env t =
  let envVars = freeEnvVars env
      typeVars = freeTypeVars t
      vars = filter (`notElem` envVars) typeVars
   in Forall vars t

-- ì¡éÍâªÅFforall ÇäOÇµÅAêVÇµÇ¢å^ïœêîÇ…íuÇ´ä∑Ç¶ÇÈ
{-}
instantiate :: Scheme -> Type
instantiate (Forall vars t) =
  let fresh v = TVar (v ++ "'") -- ä»à’ìIÇ»êVÇµÇ¢å^ïœêî
      s = M.fromList [(v, fresh v) | v <- vars]
   in apply s t
-}
instantiate :: Scheme -> Either InferError Type
instantiate (Forall vars t) =
  Right (freshen vars t)

freshen :: [String] -> Type -> Type
freshen vars t =
  let newVars = M.fromList [(v, TVar ("t_" ++ v)) | v <- vars]
   in apply newVars t

applyEnv :: Subst -> TypeEnv -> TypeEnv
applyEnv s (TypeEnv env) =
  TypeEnv (M.map (\(Forall vs t) -> Forall vs (apply s t)) env)

primitiveEnv :: TypeEnv
primitiveEnv =
  TypeEnv
    ( M.fromList
        [ ("+", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("-", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("*", Forall [] (TArrow (TCon "Int") (TArrow (TCon "Int") (TCon "Int")))),
          ("==", Forall ["a"] (TArrow (TVar "a") (TArrow (TVar "a") (TCon "Bool"))))
        ]
    )


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "Scheme",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokTypeIdent "TypeEnv",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ",",TokIdent "emptyEnv",TokSymbol ",",TokIdent "extendEnv",TokSymbol ",",TokIdent "lookupEnv",TokSymbol ",",TokIdent "generalize",TokSymbol ",",TokIdent "instantiate",TokSymbol ",",TokIdent "applyEnv",TokSymbol ",",TokIdent "freeTypeVarsScheme",TokSymbol ",",TokIdent "freeTypeVarsEnv",TokSymbol ",",TokIdent "freeTypeVars",TokSymbol ",",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Expr",TokSymbol "(",TokTypeIdent "Name",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokSymbol "(",TokTypeIdent "Type",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "List",TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "Scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "newtype",TokTypeIdent "TypeEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ftv",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "emptyEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSymbol "=",TokIdent "primitiveEnv",TokNewline,TokIdent "extendEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Scheme",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokIdent "s",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokIdent "lookupEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "x",TokIdent "env",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "nub",TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "vars",TokVRBrace,TokNewline,TokIdent "freeTypeVars",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokSymbol "_",TokArrow,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "concatMap",TokIdent "freeConstraintVars",TokIdent "cs",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t1",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "filter",TokSymbol "(",TokUnknown '`',TokIdent "notElem`",TokIdent "vs",TokSymbol ")",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "freeConstraintVars",TokSymbol "::",TokTypeIdent "Constraint",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokIdent "freeTypeVars",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "freeEnvVars",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalize",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "envVars",TokSymbol "=",TokIdent "freeEnvVars",TokIdent "env",TokVLBrace,TokIdent "typeVars",TokSymbol "=",TokIdent "freeTypeVars",TokIdent "t",TokSymbol ";",TokIdent "vars",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokUnknown '`',TokIdent "notElem`",TokIdent "envVars",TokSymbol ")",TokIdent "typeVars",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokNewline,TokIdent "instantiate",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshen",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "newVars",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSymbol "|",TokIdent "v",TokSymbol "<-",TokIdent "vars",TokSymbol "]",TokVLBrace,TokKeyword "in",TokIdent "apply",TokIdent "newVars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyEnv",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "primitiveEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Scheme"
<< exportItem: next token=TokTypeIdent "TypeEnv"
<< exportItem: next token=TokIdent "emptyEnv"
<< exportItem: next token=TokIdent "extendEnv"
<< exportItem: next token=TokIdent "lookupEnv"
<< exportItem: next token=TokIdent "generalize"
<< exportItem: next token=TokIdent "instantiate"
<< exportItem: next token=TokIdent "applyEnv"
<< exportItem: next token=TokIdent "freeTypeVarsScheme"
<< exportItem: next token=TokIdent "freeTypeVarsEnv"
<< exportItem: next token=TokIdent "freeTypeVars"
<< exportItem: next token=TokSymbol ")"
<< declBody: return DeclModule "TypeInference.TypeEnv" (Just [ExportType "Scheme" True,ExportType "TypeEnv" True,ExportVar "emptyEnv",ExportVar "extendEnv",ExportVar "lookupEnv",ExportVar "generalize",ExportVar "instantiate",ExportVar "applyEnv",ExportVar "freeTypeVarsScheme",ExportVar "freeTypeVarsEnv",ExportVar "freeTypeVars"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Name"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokSymbol "("
<< decl parser called
<< decl dispatch: TokSymbol "("
<< typeSigDecl: TokSymbol "("
Just ([DeclModule "TypeInference.TypeEnv" (Just [ExportType "Scheme" True,ExportType "TypeEnv" True,ExportVar "emptyEnv",ExportVar "extendEnv",ExportVar "lookupEnv",ExportVar "generalize",ExportVar "instantiate",ExportVar "applyEnv",ExportVar "freeTypeVarsScheme",ExportVar "freeTypeVarsEnv",ExportVar "freeTypeVars"]),DeclImport {importQualified = False, importModule = "AST.Expr", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "Name"]},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Type"]},DeclImport {importQualified = False, importModule = "Data.List", importAlias = Nothing, importHiding = False, importItems = Nothing}],[TokSymbol "(",TokIdent "nub",TokSymbol ",",TokSymbol "(",TokSymbol "\\",TokSymbol "\\",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Error",TokSymbol "(",TokTypeIdent "InferError",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "Scheme",TokSymbol "=",TokTypeIdent "Forall",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokTypeIdent "Type",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokKeyword "newtype",TokTypeIdent "TypeEnv",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokTypeIdent "Map",TokTypeIdent "String",TokTypeIdent "Scheme",TokSymbol ")",TokVLBrace,TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "ftv",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Subst",TokNewline,TokIdent "ftv",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "empty",TokNewline,TokIdent "emptyEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "emptyEnv",TokSymbol "=",TokIdent "primitiveEnv",TokNewline,TokIdent "extendEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Scheme",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "extendEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokIdent "s",TokSymbol "=",TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "insert",TokIdent "x",TokIdent "s",TokIdent "env",TokSymbol ")",TokNewline,TokIdent "lookupEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "String",TokArrow,TokTypeIdent "Maybe",TokTypeIdent "Scheme",TokNewline,TokIdent "lookupEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokIdent "x",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "lookup",TokIdent "x",TokIdent "env",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsEnv",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "nub",TokSymbol "(",TokIdent "concatMap",TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokSymbol "[",TokTypeIdent "Name",TokSymbol "]",TokNewline,TokIdent "freeTypeVarsScheme",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "\\",TokSymbol "\\",TokIdent "vars",TokVRBrace,TokNewline,TokIdent "freeTypeVars",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeTypeVars",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "v",TokArrow,TokSymbol "[",TokIdent "v",TokSymbol "]",TokSymbol ";",TokTypeIdent "TCon",TokSymbol "_",TokArrow,TokSymbol "[",TokSymbol "]",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "freeTypeVars",TokIdent "t1",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "concatMap",TokIdent "freeConstraintVars",TokIdent "cs",TokOperator "++",TokIdent "freeTypeVars",TokIdent "t1",TokVRBrace,TokNewline,TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokVLBrace,TokIdent "filter",TokSymbol "(",TokUnknown '`',TokIdent "notElem`",TokIdent "vs",TokSymbol ")",TokSymbol "(",TokIdent "freeTypeVars",TokIdent "t1",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline,TokIdent "freeConstraintVars",TokSymbol "::",TokTypeIdent "Constraint",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeConstraintVars",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokIdent "freeTypeVars",TokIdent "ts",TokVRBrace,TokNewline,TokIdent "freeEnvVars",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokNewline,TokIdent "freeEnvVars",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "concatMap",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokSymbol "_",TokIdent "t",TokSymbol ")",TokArrow,TokIdent "freeTypeVars",TokIdent "t",TokSymbol ")",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "elems",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "generalize",TokSymbol "::",TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Scheme",TokNewline,TokIdent "generalize",TokIdent "env",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "envVars",TokSymbol "=",TokIdent "freeEnvVars",TokIdent "env",TokVLBrace,TokIdent "typeVars",TokSymbol "=",TokIdent "freeTypeVars",TokIdent "t",TokSymbol ";",TokIdent "vars",TokSymbol "=",TokIdent "filter",TokSymbol "(",TokUnknown '`',TokIdent "notElem`",TokIdent "envVars",TokSymbol ")",TokIdent "typeVars",TokVRBrace,TokNewline,TokKeyword "in",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokVRBrace,TokNewline,TokIdent "instantiate",TokSymbol "::",TokTypeIdent "Scheme",TokArrow,TokTypeIdent "Either",TokTypeIdent "InferError",TokTypeIdent "Type",TokNewline,TokIdent "instantiate",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vars",TokIdent "t",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "Right",TokSymbol "(",TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "freshen",TokSymbol "::",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokNewline,TokIdent "freshen",TokIdent "vars",TokIdent "t",TokSymbol "=",TokVLBrace,TokKeyword "let",TokIdent "newVars",TokSymbol "=",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokIdent "v",TokSymbol ",",TokTypeIdent "TVar",TokSymbol "(",TokString "t_",TokOperator "++",TokIdent "v",TokSymbol ")",TokSymbol ")",TokSymbol "|",TokIdent "v",TokSymbol "<-",TokIdent "vars",TokSymbol "]",TokVLBrace,TokKeyword "in",TokIdent "apply",TokIdent "newVars",TokIdent "t",TokVRBrace,TokVRBrace,TokNewline,TokIdent "applyEnv",TokSymbol "::",TokTypeIdent "Subst",TokArrow,TokTypeIdent "TypeEnv",TokArrow,TokTypeIdent "TypeEnv",TokNewline,TokIdent "applyEnv",TokIdent "s",TokSymbol "(",TokTypeIdent "TypeEnv",TokIdent "env",TokSymbol ")",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "map",TokSymbol "(",TokSymbol "\\",TokSymbol "(",TokTypeIdent "Forall",TokIdent "vs",TokIdent "t",TokSymbol ")",TokArrow,TokTypeIdent "Forall",TokIdent "vs",TokSymbol "(",TokIdent "apply",TokIdent "s",TokIdent "t",TokSymbol ")",TokSymbol ")",TokIdent "env",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "primitiveEnv",TokSymbol "::",TokTypeIdent "TypeEnv",TokNewline,TokIdent "primitiveEnv",TokSymbol "=",TokVLBrace,TokTypeIdent "TypeEnv",TokVLBrace,TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "fromList",TokSymbol "[",TokSymbol "(",TokString "+",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "-",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "*",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Int",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ",",TokSymbol "(",TokString "==",TokSymbol ",",TokTypeIdent "Forall",TokSymbol "[",TokString "a",TokSymbol "]",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokSymbol "(",TokTypeIdent "TVar",TokString "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokString "Bool",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol ")",TokSymbol "]",TokSymbol ")",TokVRBrace,TokVRBrace,TokNewline])

=== Running: src/TypeInference/Unify.hs ===
-- Raw Source --
module TypeInference.Unify (Subst, unify, UnifyError) where

import AST.Type
import Control.Monad (unless)
import qualified Data.Map as M
import TypeInference.Subst

-- å^ÇÃàÍívÇ…é∏îsÇµÇΩÇ∆Ç´ÇÃÉGÉâÅ[
data UnifyError
  = UnifyMismatch Type Type
  | UnifyOccursCheckFailed String Type
  deriving (Show, Eq)

-- å^ÇÃàÍívÇééÇ›ÅAê¨å˜Ç∑ÇÍÇŒë„ì¸Çï‘Ç∑
{-}
unify :: Type -> Type -> Either UnifyError Subst
unify TUnit TUnit = Right emptySubst
unify (TArrow l1 r1) (TArrow l2 r2) = do
  s1 <- unify l1 l2
  s2 <- unify (apply s1 r1) (apply s1 r2)
  return (composeSubst s2 s1)
unify (TApp f1 a1) (TApp f2 a2) = do
  s1 <- unify f1 f2
  s2 <- unify (apply s1 a1) (apply s1 a2)
  return (composeSubst s2 s1)
unify (TList t1) (TList t2) =
  unify t1 t2
unify (TCon c1) (TCon c2)
  | c1 == c2 = return emptySubst
  | otherwise = Left (UnifyMismatch (TCon c1) (TCon c2))
unify (TVar v) t = bindVar v t
unify t (TVar v) = bindVar v t
-- ÇªÇÃëºÇÃå^ç\ê¨éqÇÕñ¢ëŒâûÅiTConstraint, TForall Ç»Ç«Åj
unify t1 t2 = Left (UnifyMismatch t1 t2)
-}
unify :: Type -> Type -> Either UnifyError Subst

-- å^ïœêî
unify (TVar a) t = varBind a t
unify t (TVar a) = varBind a t

-- Unit
unify TUnit TUnit = Right emptySubst

-- å^ÉRÉìÉXÉgÉâÉNÉ^
unify (TCon a) (TCon b)
  | a == b    = Right emptySubst
  | otherwise = Left (UnifyMismatch (TCon a) (TCon b))

-- ä÷êîå^
unify (TArrow a1 b1) (TArrow a2 b2) = do
  s1 <- unify a1 a2
  s2 <- unify (apply s1 b1) (apply s1 b2)
  Right (s2 `composeSubst` s1)

-- É^ÉvÉã
unify (TTuple xs) (TTuple ys)
  | length xs == length ys = unifyMany xs ys
  | otherwise = Left (UnifyMismatch (TTuple xs) (TTuple ys))

-- ÉäÉXÉg
unify (TList a) (TList b) = unify a b

-- ÉfÉtÉHÉãÉg
unify t1 t2 = Left (UnifyMismatch t1 t2)

varBind :: String -> Type -> Either UnifyError Subst
varBind a t
  | t == TVar a = Right emptySubst
  | occursCheck a t = Left (UnifyOccursCheckFailed a t)
  | otherwise = Right (M.singleton a t)


occursCheck :: String -> Type -> Bool
occursCheck a (TVar b)       = a == b
occursCheck a (TCon _)       = False
occursCheck a TUnit          = False
occursCheck a (TList t)      = occursCheck a t
occursCheck a (TTuple ts)    = any (occursCheck a) ts
occursCheck a (TArrow t1 t2) = occursCheck a t1 || occursCheck a t2

unifyMany :: [Type] -> [Type] -> Either UnifyError Subst
unifyMany [] [] = Right emptySubst
unifyMany (t1:ts1) (t2:ts2) = do
  s1 <- unify t1 t2
  s2 <- unifyMany (map (apply s1) ts1) (map (apply s1) ts2)
  Right (s2 `composeSubst` s1)
unifyMany ts1 ts2 =
  Left (UnifyMismatch (TTuple ts1) (TTuple ts2))

-- å^ïœêîÇ∆å^ÇåãÇ—Ç¬ÇØÇÈÅioccurs check Ç†ÇËÅj
bindVar :: String -> Type -> Either UnifyError Subst
bindVar v t
  | t == TVar v = return emptySubst
  | v `occursIn` t = Left (UnifyOccursCheckFailed v t)
  | otherwise = return (singletonSubst v t)

-- å^ïœêî v Ç™å^ t ÇÃíÜÇ…åªÇÍÇÈÇ©Åiñ≥å¿å^ÇñhÇÆÅj
occursIn :: String -> Type -> Bool
occursIn v t = case t of
  TVar x -> x == v
  TCon _ -> False
  TArrow t1 t2 -> occursIn v t1 || occursIn v t2
  TList t1 -> occursIn v t1
  TApp t1 t2 -> occursIn v t1 || occursIn v t2
  TConstraint cs t1 -> any (occursInConstraint v) cs || occursIn v t1
  TForall vs t1 -> if v `elem` vs then False else occursIn v t1

occursInConstraint :: String -> Constraint -> Bool
occursInConstraint v (Constraint _ ts) =
  any (occursIn v) ts


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Unify",TokSymbol "(",TokTypeIdent "Subst",TokSymbol ",",TokIdent "unify",TokSymbol ",",TokTypeIdent "UnifyError",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "AST",TokDot,TokTypeIdent "Type",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "unless",TokSymbol ")",TokNewline,TokKeyword "import",TokKeyword "qualified",TokTypeIdent "Data",TokDot,TokTypeIdent "Map",TokKeyword "as",TokTypeIdent "M",TokNewline,TokKeyword "import",TokTypeIdent "TypeInference",TokDot,TokTypeIdent "Subst",TokNewline,TokKeyword "data",TokTypeIdent "UnifyError",TokVLBrace,TokSymbol "=",TokTypeIdent "UnifyMismatch",TokTypeIdent "Type",TokTypeIdent "Type",TokSymbol ";",TokSymbol "|",TokTypeIdent "UnifyOccursCheckFailed",TokTypeIdent "String",TokTypeIdent "Type",TokSymbol ";",TokKeyword "deriving",TokSymbol "(",TokTypeIdent "Show",TokSymbol ",",TokTypeIdent "Eq",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "::",TokTypeIdent "Type",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokIdent "t",TokSymbol "=",TokIdent "varBind",TokIdent "a",TokIdent "t",TokNewline,TokIdent "unify",TokIdent "t",TokSymbol "(",TokTypeIdent "TVar",TokIdent "a",TokSymbol ")",TokSymbol "=",TokIdent "varBind",TokIdent "a",TokIdent "t",TokNewline,TokIdent "unify",TokTypeIdent "TUnit",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "a",TokSymbol "==",TokIdent "b",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a2",TokIdent "b2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "a1",TokIdent "a2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "length",TokIdent "xs",TokSymbol "==",TokIdent "length",TokIdent "ys",TokSymbol "=",TokIdent "unifyMany",TokIdent "xs",TokIdent "ys",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TList",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "unify",TokIdent "a",TokIdent "b",TokNewline,TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokNewline,TokIdent "varBind",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "varBind",TokIdent "a",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokTypeIdent "TVar",TokIdent "a",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursCheck",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "a",TokSymbol "==",TokIdent "b",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TCon",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokIdent "any",TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokIdent "ts",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t2",TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t1",TokOperator ":",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "t2",TokOperator ":",TokIdent "ts2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unifyMany",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unifyMany",TokIdent "ts1",TokIdent "ts2",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "bindVar",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokIdent "v",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokTypeIdent "TVar",TokIdent "v",TokSymbol "=",TokKeyword "return",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "v",TokUnknown '`',TokIdent "occursIn`",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursIn",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokIdent "v",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "x",TokArrow,TokIdent "x",TokSymbol "==",TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSymbol "_",TokArrow,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokIdent "any",TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokIdent "cs",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokKeyword "if",TokIdent "v",TokUnknown '`',TokIdent "elem`",TokIdent "vs",TokKeyword "then",TokTypeIdent "False",TokKeyword "else",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokVRBrace,TokNewline,TokIdent "occursInConstraint",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokIdent "v",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "any",TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokIdent "ts",TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokTypeIdent "Subst"
<< exportItem: next token=TokIdent "unify"
<< exportItem: next token=TokTypeIdent "UnifyError"
<< declBody: return DeclModule "TypeInference.Unify" (Just [ExportType "Subst" False,ExportVar "unify",ExportType "UnifyError" False])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "AST"
<< declBody: return DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unless"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "TypeInference"
<< declBody: return DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "data"
<< decl parser called
<< decl dispatch: TokKeyword "data"
<< dataDecl: next token TokSymbol "="
<< dataDecl:2 next token TokTypeIdent "UnifyMismatch"
<< constrS: next token TokTypeIdent "UnifyMismatch"
<< dataConstr: next token TokTypeIdent "UnifyMismatch"
<< dataConstr:2 [TCon "Type",TCon "Type"]
<< dataConstr:3 next token TokSymbol "|"
<< constrS:1 next token TokSymbol "|" Constraint "UnifyMismatch" [TCon "Type",TCon "Type"]
<< constrS:2 next token TokSymbol "|"
<< dataConstrRc: next token TokSymbol "|"
<< dataConstrRc:2 next token TokTypeIdent "String"
<< dataConstrNx: next token TokSymbol "|"
<< dataConstrRc: next token TokKeyword "deriving"
<< dataConstrNx: next token TokKeyword "deriving"
<< dataDecl:2 next token TokKeyword "deriving"[Constraint "UnifyMismatch" [TCon "Type",TCon "Type"],Constraint "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]]
<< dataDecl:4 next token ["Show","Eq"]
<< declBody: return DeclData "UnifyError" [] [Constraint "UnifyMismatch" [TCon "Type",TCon "Type"],Constraint "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]] ["Show","Eq"]
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "unify"
<< parseType dispatch: TokTypeIdent "Type"
<< parseTypeCore: TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")
<< parseTypeCore: TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))
<< parseTypeCore: TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< parsed type signature: unify :: TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))
<< returning DeclTypeSig: DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< declBody: return DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst"))))
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TVar" []) [PVar "a"]
<< patternParser: (pAs <|> makeCons)PApp (PApp (PConstr "TVar" []) [PVar "a"]) [PVar "t"]
<< funClause: args=[PApp (PApp (PConstr "TVar" []) [PVar "a"]) [PVar "t"]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "varBind"
<< expr dispatch: TokIdent "varBind"
<< exprCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TVar" []) [PVar "a"]
<< patternParser: (pAs <|> makeCons)PApp (PVar "t") [PApp (PConstr "TVar" []) [PVar "a"]]
<< expr dispatch: TokIdent "varBind"
<< exprCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "varBind"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "t"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< patternParser: (pAs <|> makeCons)PApp (PConstr "TUnit" []) [PConstr "TUnit" []]
<< expr dispatch: TokTypeIdent "Right"
<< exprCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokTypeIdent "Right"
<< atomBaseCore next token: TokIdent "emptySubst"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "unify"
<< funClauseWithName: next token=TokIdent "unify"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "a"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "b"]
<< patternParser: (pAs <|> makeCons)PApp (PApp (PConstr "TCon" []) [PVar "a"]) [PApp (PConstr "TCon" []) [PVar "b"]]
<< expr dispatch: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< declBody: return DeclFunGroup "unify" [FunClause [PApp (PApp (PConstr "TVar" []) [PVar "a"]) [PVar "t"]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "t") [PApp (PConstr "TVar" []) [PVar "a"]]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PConstr "TUnit" []) [PConstr "TUnit" []]] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing]
<< decl next token: TokIdent "unify"
<< decl parser called
<< decl dispatch: TokIdent "unify"
<< funDecl: next token=TokIdent "unify"
<< funClause: next token=TokIdent "unify"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "a"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "b"]
<< patternParser: (pAs <|> makeCons)PApp (PApp (PConstr "TCon" []) [PVar "a"]) [PApp (PConstr "TCon" []) [PVar "b"]]
<< funClause: args=[PApp (PApp (PConstr "TCon" []) [PVar "a"]) [PApp (PConstr "TCon" []) [PVar "b"]]] t = TokVLBrace
<< parseGuardedClause: next token=TokVLBrace
<< guardedRhs: next token = TokSymbol "|"
<< parseGuardLine: next token=TokSymbol "|"
<< expr dispatch: TokIdent "a"
<< exprCore next token: TokIdent "a"
<< atomBaseCore next token: TokIdent "a"
<< atomBaseCore next token: TokSymbol "=="
<< guardedRhs: next token = TokVLBrace
<< parseGuardLine: next token=TokVLBrace
<< typeSigDecl: TokIdent "unify"
<< valueDecl: TokIdent "unify"
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "a"]
<< pattern1: (pAs <|> makeCons)PApp (PConstr "TCon" []) [PVar "b"]
<< patternParser: (pAs <|> makeCons)PApp (PVar "unify") [PApp (PConstr "TCon" []) [PVar "a"],PApp (PConstr "TCon" []) [PVar "b"]]
Just ([DeclModule "TypeInference.Unify" (Just [ExportType "Subst" False,ExportVar "unify",ExportType "UnifyError" False]),DeclImport {importQualified = False, importModule = "AST.Type", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unless"]},DeclImport {importQualified = True, importModule = "Data.Map", importAlias = Just "M", importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "TypeInference.Subst", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclData "UnifyError" [] [Constraint "UnifyMismatch" [TCon "Type",TCon "Type"],Constraint "UnifyOccursCheckFailed" [TCon "String",TCon "Type"]] ["Show","Eq"],DeclTypeSig "unify" (TFun (TCon "Type") (TFun (TCon "Type") (TApp (TApp (TCon "Either") (TCon "UnifyError")) (TCon "Subst")))),DeclFunGroup "unify" [FunClause [PApp (PApp (PConstr "TVar" []) [PVar "a"]) [PVar "t"]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PVar "t") [PApp (PConstr "TVar" []) [PVar "a"]]] Nothing (Just (EApp (EApp (EVar "varBind") (EVar "a")) (EVar "t"))) Nothing,FunClause [PApp (PConstr "TUnit" []) [PConstr "TUnit" []]] Nothing (Just (EApp (EVarType "Right") (EVar "emptySubst"))) Nothing]],[TokIdent "unify",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "a",TokSymbol "==",TokIdent "b",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TCon",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TCon",TokIdent "b",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "a2",TokIdent "b2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "a1",TokIdent "a2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unify",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b1",TokSymbol ")",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokIdent "b2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokVLBrace,TokSymbol "|",TokIdent "length",TokIdent "xs",TokSymbol "==",TokIdent "length",TokIdent "ys",TokSymbol "=",TokIdent "unifyMany",TokIdent "xs",TokIdent "ys",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "xs",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ys",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unify",TokSymbol "(",TokTypeIdent "TList",TokIdent "a",TokSymbol ")",TokSymbol "(",TokTypeIdent "TList",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "unify",TokIdent "a",TokIdent "b",TokNewline,TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokNewline,TokIdent "varBind",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "varBind",TokIdent "a",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokTypeIdent "TVar",TokIdent "a",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "a",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokTypeIdent "Right",TokSymbol "(",TokTypeIdent "M",TokDot,TokIdent "singleton",TokIdent "a",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursCheck",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TVar",TokIdent "b",TokSymbol ")",TokSymbol "=",TokIdent "a",TokSymbol "==",TokIdent "b",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TCon",TokSymbol "_",TokSymbol ")",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokTypeIdent "TUnit",TokSymbol "=",TokTypeIdent "False",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TList",TokIdent "t",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokIdent "any",TokSymbol "(",TokIdent "occursCheck",TokIdent "a",TokSymbol ")",TokIdent "ts",TokNewline,TokIdent "occursCheck",TokIdent "a",TokSymbol "(",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokSymbol ")",TokSymbol "=",TokIdent "occursCheck",TokIdent "a",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursCheck",TokIdent "a",TokIdent "t2",TokNewline,TokIdent "unifyMany",TokSymbol "::",TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokSymbol "[",TokTypeIdent "Type",TokSymbol "]",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "unifyMany",TokSymbol "[",TokSymbol "]",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokTypeIdent "Right",TokIdent "emptySubst",TokNewline,TokIdent "unifyMany",TokSymbol "(",TokIdent "t1",TokOperator ":",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "t2",TokOperator ":",TokIdent "ts2",TokSymbol ")",TokSymbol "=",TokKeyword "do",TokVLBrace,TokIdent "s1",TokSymbol "<-",TokIdent "unify",TokIdent "t1",TokIdent "t2",TokSymbol ";",TokIdent "s2",TokSymbol "<-",TokIdent "unifyMany",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokIdent "map",TokSymbol "(",TokIdent "apply",TokIdent "s1",TokSymbol ")",TokIdent "ts2",TokSymbol ")",TokSymbol ";",TokTypeIdent "Right",TokSymbol "(",TokIdent "s2",TokUnknown '`',TokIdent "composeSubst`",TokIdent "s1",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "unifyMany",TokIdent "ts1",TokIdent "ts2",TokSymbol "=",TokVLBrace,TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyMismatch",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts1",TokSymbol ")",TokSymbol "(",TokTypeIdent "TTuple",TokIdent "ts2",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "bindVar",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Either",TokTypeIdent "UnifyError",TokTypeIdent "Subst",TokNewline,TokIdent "bindVar",TokIdent "v",TokIdent "t",TokVLBrace,TokSymbol "|",TokIdent "t",TokSymbol "==",TokTypeIdent "TVar",TokIdent "v",TokSymbol "=",TokKeyword "return",TokIdent "emptySubst",TokSymbol ";",TokSymbol "|",TokIdent "v",TokUnknown '`',TokIdent "occursIn`",TokIdent "t",TokSymbol "=",TokTypeIdent "Left",TokSymbol "(",TokTypeIdent "UnifyOccursCheckFailed",TokIdent "v",TokIdent "t",TokSymbol ")",TokSymbol ";",TokSymbol "|",TokIdent "otherwise",TokSymbol "=",TokKeyword "return",TokSymbol "(",TokIdent "singletonSubst",TokIdent "v",TokIdent "t",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "occursIn",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Type",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursIn",TokIdent "v",TokIdent "t",TokSymbol "=",TokKeyword "case",TokIdent "t",TokKeyword "of",TokVLBrace,TokTypeIdent "TVar",TokIdent "x",TokArrow,TokIdent "x",TokSymbol "==",TokIdent "v",TokSymbol ";",TokTypeIdent "TCon",TokSymbol "_",TokArrow,TokTypeIdent "False",TokSymbol ";",TokTypeIdent "TArrow",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TList",TokIdent "t1",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TApp",TokIdent "t1",TokIdent "t2",TokArrow,TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t2",TokSymbol ";",TokTypeIdent "TConstraint",TokIdent "cs",TokIdent "t1",TokArrow,TokIdent "any",TokSymbol "(",TokIdent "occursInConstraint",TokIdent "v",TokSymbol ")",TokIdent "cs",TokSymbol "|",TokSymbol "|",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokSymbol ";",TokTypeIdent "TForall",TokIdent "vs",TokIdent "t1",TokArrow,TokKeyword "if",TokIdent "v",TokUnknown '`',TokIdent "elem`",TokIdent "vs",TokKeyword "then",TokTypeIdent "False",TokKeyword "else",TokIdent "occursIn",TokIdent "v",TokIdent "t1",TokVRBrace,TokNewline,TokIdent "occursInConstraint",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Constraint",TokArrow,TokTypeIdent "Bool",TokNewline,TokIdent "occursInConstraint",TokIdent "v",TokSymbol "(",TokTypeIdent "Constraint",TokSymbol "_",TokIdent "ts",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "any",TokSymbol "(",TokIdent "occursIn",TokIdent "v",TokSymbol ")",TokIdent "ts",TokVRBrace,TokNewline])

=== Running: src/Utils/MyTrace.hs ===
-- Raw Source --
{- NOINLINE traceEnabled -}

module Utils.MyTrace (myTrace, myTraceIO, myTraceShowId, traceEnabled, setTrace) where

import Control.Monad (when)
import Data.IORef
import Debug.Trace (trace, traceIO, traceShowId)
import Parser.Core.Combinator (Parser (..))
import System.IO.Unsafe (unsafePerformIO)

traceEnabled :: IORef Bool
traceEnabled = unsafePerformIO (newIORef True)

setTrace :: Bool -> IO ()
setTrace b = writeIORef traceEnabled b

myTrace :: String -> Parser ()
myTrace msg = Parser $ \input -> unsafePerformIO $ do
  enabled <- readIORef traceEnabled
  when enabled (putStrLn msg)
  return (Just ((), input))

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: (Show a) => a -> a
myTraceShowId = traceShowId

{-}
#ifdef ENABLE_TRACE
myTrace :: String -> a -> a
myTrace = trace

myTraceIO :: String -> IO ()
myTraceIO = traceIO

myTraceShowId :: Show a => a -> a
myTraceShowId = traceShowId
#else
myTrace :: String -> a -> a
myTrace _ x = x

myTraceIO :: String -> IO ()
myTraceIO _ = pure ()

myTraceShowId :: Show a => a -> a
myTraceShowId = id
#endif
-}

-- Tokens from Lexer --
[TokNewline,TokKeyword "module",TokTypeIdent "Utils",TokDot,TokTypeIdent "MyTrace",TokSymbol "(",TokIdent "myTrace",TokSymbol ",",TokIdent "myTraceIO",TokSymbol ",",TokIdent "myTraceShowId",TokSymbol ",",TokIdent "traceEnabled",TokSymbol ",",TokIdent "setTrace",TokSymbol ")",TokKeyword "where",TokNewline,TokKeyword "import",TokTypeIdent "Control",TokDot,TokTypeIdent "Monad",TokSymbol "(",TokIdent "when",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Data",TokDot,TokTypeIdent "IORef",TokNewline,TokKeyword "import",TokTypeIdent "Debug",TokDot,TokTypeIdent "Trace",TokSymbol "(",TokIdent "trace",TokSymbol ",",TokIdent "traceIO",TokSymbol ",",TokIdent "traceShowId",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "Parser",TokDot,TokTypeIdent "Core",TokDot,TokTypeIdent "Combinator",TokSymbol "(",TokTypeIdent "Parser",TokSymbol "(",TokSymbol "..",TokSymbol ")",TokSymbol ")",TokNewline,TokKeyword "import",TokTypeIdent "System",TokDot,TokTypeIdent "IO",TokDot,TokTypeIdent "Unsafe",TokSymbol "(",TokIdent "unsafePerformIO",TokSymbol ")",TokNewline,TokIdent "traceEnabled",TokSymbol "::",TokTypeIdent "IORef",TokTypeIdent "Bool",TokNewline,TokIdent "traceEnabled",TokSymbol "=",TokIdent "unsafePerformIO",TokSymbol "(",TokIdent "newIORef",TokTypeIdent "True",TokSymbol ")",TokNewline,TokIdent "setTrace",TokSymbol "::",TokTypeIdent "Bool",TokArrow,TokTypeIdent "IO",TokSymbol "()",TokNewline,TokIdent "setTrace",TokIdent "b",TokSymbol "=",TokIdent "writeIORef",TokIdent "traceEnabled",TokIdent "b",TokNewline,TokIdent "myTrace",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "Parser",TokSymbol "()",TokNewline,TokIdent "myTrace",TokIdent "msg",TokSymbol "=",TokTypeIdent "Parser",TokOperator "$",TokSymbol "\\",TokIdent "input",TokArrow,TokIdent "unsafePerformIO",TokOperator "$",TokKeyword "do",TokVLBrace,TokIdent "enabled",TokSymbol "<-",TokIdent "readIORef",TokIdent "traceEnabled",TokSymbol ";",TokIdent "when",TokIdent "enabled",TokSymbol "(",TokIdent "putStrLn",TokIdent "msg",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "myTraceIO",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "IO",TokSymbol "()",TokNewline,TokIdent "myTraceIO",TokSymbol "=",TokIdent "traceIO",TokNewline,TokIdent "myTraceShowId",TokSymbol "::",TokSymbol "(",TokTypeIdent "Show",TokIdent "a",TokSymbol ")",TokKeyword "=>",TokIdent "a",TokArrow,TokIdent "a",TokNewline,TokIdent "myTraceShowId",TokSymbol "=",TokIdent "traceShowId",TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "myTrace"
<< exportItem: next token=TokIdent "myTraceIO"
<< exportItem: next token=TokIdent "myTraceShowId"
<< exportItem: next token=TokIdent "traceEnabled"
<< exportItem: next token=TokIdent "setTrace"
<< declBody: return DeclModule "Utils.MyTrace" (Just [ExportVar "myTrace",ExportVar "myTraceIO",ExportVar "myTraceShowId",ExportVar "traceEnabled",ExportVar "setTrace"])
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Control"
<< declBody: return DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "when"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Data"
<< declBody: return DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Debug"
<< declBody: return DeclImport {importQualified = False, importModule = "Debug.Trace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "trace",ImportVar "traceIO",ImportVar "traceShowId"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "Parser"
<< declBody: return DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser"]}
<< decl next token: TokKeyword "import"
<< decl parser called
<< decl dispatch: TokKeyword "import"
<< importDecl parser called
<< importDecl: TokTypeIdent "System"
<< declBody: return DeclImport {importQualified = False, importModule = "System.IO.Unsafe", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unsafePerformIO"]}
<< decl next token: TokIdent "traceEnabled"
<< decl parser called
<< decl dispatch: TokIdent "traceEnabled"
<< funDecl: next token=TokIdent "traceEnabled"
<< funClause: next token=TokIdent "traceEnabled"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "traceEnabled"
<< parseType dispatch: TokTypeIdent "IORef"
<< parseTypeCore: TApp (TCon "IORef") (TCon "Bool")
<< parsed type signature: traceEnabled :: TApp (TCon "IORef") (TCon "Bool")
<< returning DeclTypeSig: DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool"))
<< declBody: return DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool"))
<< decl next token: TokIdent "traceEnabled"
<< decl parser called
<< decl dispatch: TokIdent "traceEnabled"
<< funDecl: next token=TokIdent "traceEnabled"
<< funClause: next token=TokIdent "traceEnabled"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "unsafePerformIO"
<< expr dispatch: TokIdent "unsafePerformIO"
<< exprCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokIdent "unsafePerformIO"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokIdent "newIORef"
<< atomBaseCore next token: TokTypeIdent "True"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "setTrace"
<< funClauseWithName: next token=TokIdent "setTrace"
<< declBody: return DeclFunGroup "traceEnabled" [FunClause [] Nothing (Just (EApp (EVar "unsafePerformIO") (EApp (EVar "newIORef") (EVarType "True")))) Nothing]
<< decl next token: TokIdent "setTrace"
<< decl parser called
<< decl dispatch: TokIdent "setTrace"
<< funDecl: next token=TokIdent "setTrace"
<< funClause: next token=TokIdent "setTrace"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "setTrace"
<< parseType dispatch: TokTypeIdent "Bool"
<< parseTypeCore: TApp (TCon "IO") TUnit
<< parseTypeCore: TFun (TCon "Bool") (TApp (TCon "IO") TUnit)
<< parsed type signature: setTrace :: TFun (TCon "Bool") (TApp (TCon "IO") TUnit)
<< returning DeclTypeSig: DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit))
<< declBody: return DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit))
<< decl next token: TokIdent "setTrace"
<< decl parser called
<< decl dispatch: TokIdent "setTrace"
<< funDecl: next token=TokIdent "setTrace"
<< funClause: next token=TokIdent "setTrace"
<< patternParser: (pAs <|> makeCons)PApp (PVar "b") []
<< funClause: args=[PApp (PVar "b") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "writeIORef"
<< expr dispatch: TokIdent "writeIORef"
<< exprCore next token: TokIdent "writeIORef"
<< atomBaseCore next token: TokIdent "writeIORef"
<< atomBaseCore next token: TokIdent "traceEnabled"
<< atomBaseCore next token: TokIdent "b"
<< atomBaseCore next token: TokNewline
<< whereBlock: next tokenTokIdent "myTrace"
<< funClauseWithName: next token=TokIdent "myTrace"
<< declBody: return DeclFunGroup "setTrace" [FunClause [PApp (PVar "b") []] Nothing (Just (EApp (EApp (EVar "writeIORef") (EVar "traceEnabled")) (EVar "b"))) Nothing]
<< decl next token: TokIdent "myTrace"
<< decl parser called
<< decl dispatch: TokIdent "myTrace"
<< funDecl: next token=TokIdent "myTrace"
<< funClause: next token=TokIdent "myTrace"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "myTrace"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TApp (TCon "Parser") TUnit
<< parseTypeCore: TFun (TCon "String") (TApp (TCon "Parser") TUnit)
<< parsed type signature: myTrace :: TFun (TCon "String") (TApp (TCon "Parser") TUnit)
<< returning DeclTypeSig: DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit))
<< declBody: return DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit))
<< decl next token: TokIdent "myTrace"
<< decl parser called
<< decl dispatch: TokIdent "myTrace"
<< funDecl: next token=TokIdent "myTrace"
<< funClause: next token=TokIdent "myTrace"
<< patternParser: (pAs <|> makeCons)PApp (PVar "msg") []
<< funClause: args=[PApp (PVar "msg") []] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokTypeIdent "Parser"
<< expr dispatch: TokTypeIdent "Parser"
<< exprCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokTypeIdent "Parser"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokSymbol "\\"
<< pattern1: (pAs <|> makeCons)PApp (PVar "input") []
<< exprCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokIdent "unsafePerformIO"
<< atomBaseCore next token: TokOperator "$"
<< atomBaseCore next token: TokKeyword "do"
<< atomBaseCore next token: TokKeyword "do"
<< whereBlock: next tokenTokKeyword "do"
<< funClauseWithName: next token=TokKeyword "do"
<< declBody: return DeclFunGroup "myTrace" [FunClause [PApp (PVar "msg") []] Nothing (Just (EApp (EApp (EVarType "Parser") (EVar "$")) (ELam (PApp (PVar "input") []) (EApp (EVar "unsafePerformIO") (EVar "$"))))) Nothing]
<< decl next token: TokKeyword "do"
<< decl parser called
<< decl dispatch: TokKeyword "do"
<< unknown token in decl: TokKeyword "do"
Just ([DeclModule "Utils.MyTrace" (Just [ExportVar "myTrace",ExportVar "myTraceIO",ExportVar "myTraceShowId",ExportVar "traceEnabled",ExportVar "setTrace"]),DeclImport {importQualified = False, importModule = "Control.Monad", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "when"]},DeclImport {importQualified = False, importModule = "Data.IORef", importAlias = Nothing, importHiding = False, importItems = Nothing},DeclImport {importQualified = False, importModule = "Debug.Trace", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "trace",ImportVar "traceIO",ImportVar "traceShowId"]},DeclImport {importQualified = False, importModule = "Parser.Core.Combinator", importAlias = Nothing, importHiding = False, importItems = Just [ImportTypeAll "Parser"]},DeclImport {importQualified = False, importModule = "System.IO.Unsafe", importAlias = Nothing, importHiding = False, importItems = Just [ImportVar "unsafePerformIO"]},DeclTypeSig "traceEnabled" (TApp (TCon "IORef") (TCon "Bool")),DeclFunGroup "traceEnabled" [FunClause [] Nothing (Just (EApp (EVar "unsafePerformIO") (EApp (EVar "newIORef") (EVarType "True")))) Nothing],DeclTypeSig "setTrace" (TFun (TCon "Bool") (TApp (TCon "IO") TUnit)),DeclFunGroup "setTrace" [FunClause [PApp (PVar "b") []] Nothing (Just (EApp (EApp (EVar "writeIORef") (EVar "traceEnabled")) (EVar "b"))) Nothing],DeclTypeSig "myTrace" (TFun (TCon "String") (TApp (TCon "Parser") TUnit)),DeclFunGroup "myTrace" [FunClause [PApp (PVar "msg") []] Nothing (Just (EApp (EApp (EVarType "Parser") (EVar "$")) (ELam (PApp (PVar "input") []) (EApp (EVar "unsafePerformIO") (EVar "$"))))) Nothing]],[TokKeyword "do",TokVLBrace,TokIdent "enabled",TokSymbol "<-",TokIdent "readIORef",TokIdent "traceEnabled",TokSymbol ";",TokIdent "when",TokIdent "enabled",TokSymbol "(",TokIdent "putStrLn",TokIdent "msg",TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokTypeIdent "Just",TokSymbol "(",TokSymbol "()",TokSymbol ",",TokIdent "input",TokSymbol ")",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "myTraceIO",TokSymbol "::",TokTypeIdent "String",TokArrow,TokTypeIdent "IO",TokSymbol "()",TokNewline,TokIdent "myTraceIO",TokSymbol "=",TokIdent "traceIO",TokNewline,TokIdent "myTraceShowId",TokSymbol "::",TokSymbol "(",TokTypeIdent "Show",TokIdent "a",TokSymbol ")",TokKeyword "=>",TokIdent "a",TokArrow,TokIdent "a",TokNewline,TokIdent "myTraceShowId",TokSymbol "=",TokIdent "traceShowId",TokNewline])

=== Running: src/Utils/SQLUtils.hs ===
-- Raw Source --
module Utils.SQLUtils (extractSQLVars) where

extractSQLVars :: String -> (String, [String])
extractSQLVars = go "" [] ""
  where
    go acc vars current [] =
      (acc, reverse vars)

    go acc vars current ('{':xs) =
      let (var, rest) = span (/= '}') xs
      in go (acc ++ "?") (var : vars) "" (drop 1 rest)

    go acc vars current (x:xs) =
      go (acc ++ [x]) vars current xs


-- Tokens from Lexer --
[TokKeyword "module",TokTypeIdent "Utils",TokDot,TokTypeIdent "SQLUtils",TokSymbol "(",TokIdent "extractSQLVars",TokSymbol ")",TokKeyword "where",TokNewline,TokIdent "extractSQLVars",TokSymbol "::",TokTypeIdent "String",TokArrow,TokSymbol "(",TokTypeIdent "String",TokSymbol ",",TokSymbol "[",TokTypeIdent "String",TokSymbol "]",TokSymbol ")",TokNewline,TokIdent "extractSQLVars",TokSymbol "=",TokIdent "go",TokString "",TokSymbol "[",TokSymbol "]",TokString "",TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokChar '{',TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokSymbol "/=",TokChar '}',TokSymbol ")",TokIdent "xs",TokSymbol ";",TokKeyword "in",TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSymbol "(",TokIdent "var",TokOperator ":",TokIdent "vars",TokSymbol ")",TokString "",TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokIdent "vars",TokIdent "current",TokIdent "xs",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline]

-- Parsing --

-- Parsed AST --
<< decl next token: TokKeyword "module"
<< decl parser called
<< decl dispatch: TokKeyword "module"
<< exportItem: next token=TokIdent "extractSQLVars"
<< declBody: return DeclModule "Utils.SQLUtils" (Just [ExportVar "extractSQLVars"])
<< decl next token: TokIdent "extractSQLVars"
<< decl parser called
<< decl dispatch: TokIdent "extractSQLVars"
<< funDecl: next token=TokIdent "extractSQLVars"
<< funClause: next token=TokIdent "extractSQLVars"
<< funClause: args=[] t = TokSymbol "::"
<< parseGuardedClause: next token=TokSymbol "::"
<< guardedRhs: next token = TokSymbol "::"
<< parseGuardLine: next token=TokSymbol "::"
<< typeSigDecl: TokIdent "extractSQLVars"
<< parseType dispatch: TokTypeIdent "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TCon "String"
<< parseTypeCore: TList (TCon "String")
<< parseTypeCore: TTuple [TCon "String",TList (TCon "String")]
<< parseTypeCore: TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])
<< parsed type signature: extractSQLVars :: TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])
<< returning DeclTypeSig: DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")]))
<< declBody: return DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")]))
<< decl next token: TokIdent "extractSQLVars"
<< decl parser called
<< decl dispatch: TokIdent "extractSQLVars"
<< funDecl: next token=TokIdent "extractSQLVars"
<< funClause: next token=TokIdent "extractSQLVars"
<< funClause: args=[] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokIdent "go"
<< expr dispatch: TokIdent "go"
<< exprCore next token: TokIdent "go"
<< atomBaseCore next token: TokIdent "go"
<< atomBaseCore next token: TokString ""
<< atomBaseCore next token: TokSymbol "["
<< exprCore next token: TokSymbol "]"
<< atomBaseCore next token: TokSymbol "]"
<< atomBaseCore next token: TokString ""
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokKeyword "where"
<< whereBlock:2 next tokenTokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< patternParser: (pAs <|> makeCons)PApp (PVar "acc") [PVar "vars",PVar "current",PList []]
<< funClause: args=[PApp (PVar "acc") [PVar "vars",PVar "current",PList []]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "acc"
<< atomBaseCore next token: TokIdent "acc"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "acc"
<< atomBaseCore next token: TokIdent "acc"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "reverse"
<< atomBaseCore next token: TokIdent "reverse"
<< atomBaseCore next token: TokIdent "vars"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokVRBrace
<< whereBlock: next tokenTokVRBrace
<< funClauseWithName: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])
<< patternParser: (pAs <|> makeCons)PApp (PVar "acc") [PVar "vars",PVar "current",PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])]
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "var") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "var") [],PApp (PVar "rest") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar '}'
<< atomBaseCore next token: TokChar '}'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< valueBinding next token: TokKeyword "in"
<< funBinding next token: TokKeyword "in"
<< whereBlock: next tokenTokSymbol ";"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< funDecl: next token=TokIdent "go"
<< funClause: next token=TokIdent "go"
<< pattern1: (pAs <|> makeCons)PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])
<< patternParser: (pAs <|> makeCons)PApp (PVar "acc") [PVar "vars",PVar "current",PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])]
<< funClause: args=[PApp (PVar "acc") [PVar "vars",PVar "current",PCons (PApp (PChar '{') []) (PApp (PVar "xs") [])]] t = TokSymbol "="
<< parseSimpleClause:2 next token=TokVLBrace
<< expr dispatch: TokKeyword "let"
<< letBlock next token: TokKeyword "let"
<< letExpr next token: TokSymbol "("
<< valueBinding next token: TokSymbol "("
<< pattern1: (pAs <|> makeCons)PApp (PVar "var") []
<< pattern1: (pAs <|> makeCons)PApp (PVar "rest") []
<< pattern1: (pAs <|> makeCons)PApp (PTuple [PApp (PVar "var") [],PApp (PVar "rest") []]) []
<< expr dispatch: TokIdent "span"
<< exprCore next token: TokIdent "span"
<< atomBaseCore next token: TokIdent "span"
<< exprCore next token: TokChar '}'
<< atomBaseCore next token: TokChar '}'
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< valueBinding next token: TokKeyword "in"
<< funBinding next token: TokKeyword "in"
<< whereBlock: next tokenTokSymbol ";"
<< expr dispatch: TokVLBrace
<< exprCore next token: TokVLBrace
<< atomBaseCore next token: TokVLBrace
<< whereBlock: next tokenTokVLBrace
<< funClauseWithName: next token=TokVLBrace
<< declBody: return DeclFunGroup "extractSQLVars" [FunClause [] Nothing (Just (EApp (EApp (EApp (EVar "go") (EString "")) (EList [])) (EString ""))) Nothing]
<< decl next token: TokVLBrace
<< decl parser called
<< decl dispatch: TokVLBrace
<< unknown token in decl: TokVLBrace
Just ([DeclModule "Utils.SQLUtils" (Just [ExportVar "extractSQLVars"]),DeclTypeSig "extractSQLVars" (TFun (TCon "String") (TTuple [TCon "String",TList (TCon "String")])),DeclFunGroup "extractSQLVars" [FunClause [] Nothing (Just (EApp (EApp (EApp (EVar "go") (EString "")) (EList [])) (EString ""))) Nothing]],[TokVLBrace,TokKeyword "where",TokVLBrace,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "[",TokSymbol "]",TokSymbol "=",TokVLBrace,TokSymbol "(",TokIdent "acc",TokSymbol ",",TokIdent "reverse",TokIdent "vars",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokChar '{',TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokKeyword "let",TokSymbol "(",TokIdent "var",TokSymbol ",",TokIdent "rest",TokSymbol ")",TokSymbol "=",TokIdent "span",TokSymbol "(",TokSymbol "/=",TokChar '}',TokSymbol ")",TokIdent "xs",TokSymbol ";",TokKeyword "in",TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokString "?",TokSymbol ")",TokSymbol "(",TokIdent "var",TokOperator ":",TokIdent "vars",TokSymbol ")",TokString "",TokSymbol "(",TokIdent "drop",TokNumber 1,TokIdent "rest",TokSymbol ")",TokVRBrace,TokNewline,TokIdent "go",TokIdent "acc",TokIdent "vars",TokIdent "current",TokSymbol "(",TokIdent "x",TokOperator ":",TokIdent "xs",TokSymbol ")",TokSymbol "=",TokVLBrace,TokIdent "go",TokSymbol "(",TokIdent "acc",TokOperator "++",TokSymbol "[",TokIdent "x",TokSymbol "]",TokSymbol ")",TokIdent "vars",TokIdent "current",TokIdent "xs",TokVRBrace,TokVRBrace,TokVRBrace,TokNewline])

