Build profile: -w ghc-9.6.7 -O1
In order, the following will be built (use -v for more details):
 - dlist-parser-0.1.0.0 (exe:dlist-parser) (file src\Expr\ListParserCore.hs changed)
Preprocessing executable 'dlist-parser' for dlist-parser-0.1.0.0...
Building executable 'dlist-parser' for dlist-parser-0.1.0.0...
[ 9 of 15] Compiling Expr.ListParserCore ( src\Expr\ListParserCore.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\dlist-parser\build\dlist-parser\dlist-parser-tmp\Expr\ListParserCore.o ) [Source file changed]
[12 of 15] Compiling Expr.ExprExtensions ( src\Expr\ExprExtensions.hs, C:\Users\blue3\haskell\dlist-parser\dist-newstyle\build\x86_64-windows\ghc-9.6.7\dlist-parser-0.1.0.0\x\dlist-parser\build\dlist-parser\dlist-parser-tmp\Expr\ExprExtensions.o ) [Expr.ListParserCore changed]
[16 of 16] Linking C:\\Users\\blue3\\haskell\\dlist-parser\\dist-newstyle\\build\\x86_64-windows\\ghc-9.6.7\\dlist-parser-0.1.0.0\\x\\dlist-parser\\build\\dlist-parser\\dlist-parser.exe [Objects changed]
=== Running Parser Test Suite ===

-- Simple let-return --
-- Input: do { let x = 1; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EReturn (EVar "x"))])

-- Multiple lets --
-- Input: do { let x = 1; let y = 2; return (x + y) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "let",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "x",TokOperator "+",TokIdent "y",TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],LetStmt [(PVar "y",EInt 2)],ExprStmt (EReturn (EBinOp "+" (EVar "x") (EVar "y")))])

-- If in do --
-- Input: do { let x = 10; if x > 5 then return x else return 0 }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 10,TokSymbol ";",TokKeyword "if",TokIdent "x",TokOperator ">",TokNumber 5,TokKeyword "then",TokKeyword "return",TokIdent "x",TokKeyword "else",TokKeyword "return",TokNumber 0,TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 10)],ExprStmt (EIf (EBinOp ">" (EVar "x") (EInt 5)) (EReturn (EVar "x")) (EReturn (EInt 0)))])

-- Nested do --
-- Input: do { let x = 1; do { let y = x + 1; return y } }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EDo [LetStmt [(PVar "y",EBinOp "+" (EVar "x") (EInt 1))],ExprStmt (EReturn (EVar "y"))])])

-- Do in if --
-- Input: if cond then do { let x = 1; return x } else return 0
Tokens: [TokKeyword "if",TokIdent "cond",TokKeyword "then",TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}",TokKeyword "else",TokKeyword "return",TokNumber 0]
Just (EIf (EVar "cond") (EDo [LetStmt [(PVar "x",EInt 1)],ExprStmt (EReturn (EVar "x"))]) (EReturn (EInt 0)))

-- Let with lambda --
-- Input: do { let f = \x -> x + 1 * 2; return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "\\",TokIdent "x",TokArrow,TokIdent "x",TokOperator "+",TokNumber 1,TokOperator "*",TokNumber 2,TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "f",ELam "x" (EBinOp "+" (EVar "x") (EBinOp "*" (EInt 1) (EInt 2))))],ExprStmt (EReturn (EApp (EVar "f") (EInt 10)))])

-- Let without semicolon error case --
-- Input: do { let x = 1 return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokKeyword "return"
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokKeyword "return"
Nothing

-- Do in case --
-- Input: case v of Just x -> do { let y = x + 1; return y }; Nothing -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "x",TokArrow,TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokKeyword "return",TokIdent "y",TokSymbol "}",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokKeyword "return",TokNumber 0]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- Empty do --
-- Input: do { }
Tokens: [TokKeyword "do",TokSymbol "{",TokSymbol "}"]
Just (EDo [])

-- Case with as-pattern --
-- Input: case v of x@(Just y) -> return x _ -> return 0
Tokens: [TokKeyword "case",TokIdent "v",TokKeyword "of",TokIdent "x",TokSymbol "@",TokSymbol "(",TokTypeIdent "Just",TokIdent "y",TokSymbol ")",TokArrow,TokKeyword "return",TokIdent "x",TokSymbol "_",TokArrow,TokKeyword "return",TokNumber 0]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- x; y; z statements --
-- Input: x; y; z
Tokens: [TokIdent "x",TokSymbol ";",TokIdent "y",TokSymbol ";",TokIdent "z"]
Just (ESeq [EVar "x",EVar "y",EVar "z"])

-- Let with case --
-- Input: do { let x = case v of Just n -> n; Nothing -> 0; return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "x",TokSymbol "=",TokKeyword "case",TokIdent "v",TokKeyword "of",TokTypeIdent "Just",TokIdent "n",TokArrow,TokIdent "n",TokSymbol ";",TokTypeIdent "Nothing",TokArrow,TokNumber 0,TokSymbol ";",TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: case
<< exprCore next token: TokIdent "v"
<< atomBaseCore next token: TokIdent "v"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- simple --
-- Input: { x = 1 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}"]
Just (ERecord [("x",EInt 1)])

-- 2 --
-- Input: { x = 1, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

-- tag --
-- Input: r { x = 3 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3)]))

-- nest --
-- Input: { a = { b = 3 } }
Tokens: [TokSymbol "{",TokIdent "a",TokSymbol "=",TokSymbol "{",TokIdent "b",TokSymbol "=",TokNumber 3,TokSymbol "}",TokSymbol "}"]
Just (ERecord [("a",ERecord [("b",EInt 3)])])

-- 2 equation --
-- Input: { x = 1 + 2, y = f 3 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ",",TokIdent "y",TokSymbol "=",TokIdent "f",TokNumber 3,TokSymbol "}"]
Just (ERecord [("x",EBinOp "+" (EInt 1) (EInt 2)),("y",EApp (EVar "f") (EInt 3))])

-- space --
-- Input: {  x=1 , y =2}
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
Just (ERecord [("x",EInt 1),("y",EInt 2)])

--  --
-- Input: r { x = 3, y = 4 }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 3,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 4,TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("x",EInt 3),("y",EInt 4)]))

--  --
-- Input: (f x) { y = 10 }
Tokens: [TokSymbol "(",TokIdent "f",TokIdent "x",TokSymbol ")",TokSymbol "{",TokIdent "y",TokSymbol "=",TokNumber 10,TokSymbol "}"]
Just (EApp (EApp (EVar "f") (EVar "x")) (ERecord [("y",EInt 10)]))

--  --
-- Input: { x = 1, y = 2 } { x = 9 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 9,TokSymbol "}"]
Just (EApp (ERecord [("x",EInt 1),("y",EInt 2)]) (ERecord [("x",EInt 9)]))

--  --
-- Input: (+ 1)
Tokens: [TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: (1 +)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (EInt 1) "+")

--  --
-- Input: (* 2) (2 *) (> 3) (3 >)
Tokens: [TokSymbol "(",TokOperator "*",TokNumber 2,TokSymbol ")",TokSymbol "(",TokNumber 2,TokOperator "*",TokSymbol ")",TokSymbol "(",TokOperator ">",TokNumber 3,TokSymbol ")",TokSymbol "(",TokNumber 3,TokOperator ">",TokSymbol ")"]
Just (EApp (EApp (EApp (EOpSectionL "*" (EInt 2)) (EOpSectionR (EInt 2) "*")) (EOpSectionL ">" (EInt 3))) (EOpSectionR (EInt 3) ">"))

--  --
-- Input: ((+ 1))
Tokens: [TokSymbol "(",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ")"]
Just (EOpSectionL "+" (EInt 1))

--  --
-- Input: { f = (+ 1) }
Tokens: [TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol "}"]
Just (ERecord [("f",EOpSectionL "+" (EInt 1))])

--  --
-- Input: r { f = (1 +) }
Tokens: [TokIdent "r",TokSymbol "{",TokIdent "f",TokSymbol "=",TokSymbol "(",TokNumber 1,TokOperator "+",TokSymbol ")",TokSymbol "}"]
Just (EApp (EVar "r") (ERecord [("f",EOpSectionR (EInt 1) "+")]))

--  --
-- Input: ({ x = 1 } +)
Tokens: [TokSymbol "(",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokOperator "+",TokSymbol ")"]
Just (EOpSectionR (ERecord [("x",EInt 1)]) "+")

--  --
-- Input: do { let r = { x = 1 }; return r }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokIdent "r",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "r",ERecord [("x",EInt 1)])],ExprStmt (EReturn (EVar "r"))])

--  --
-- Input: do { let r = { x = 1 }; return (r { x = 2 }) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "r",TokSymbol "=",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol "}",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "r",TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 2,TokSymbol "}",TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "r",ERecord [("x",EInt 1)])],ExprStmt (EReturn (EApp (EVar "r") (ERecord [("x",EInt 2)])))])

--  --
-- Input: do { let f = (+ 1); return (f 10) }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "f",TokSymbol "=",TokSymbol "(",TokOperator "+",TokNumber 1,TokSymbol ")",TokSymbol ";",TokKeyword "return",TokSymbol "(",TokIdent "f",TokNumber 10,TokSymbol ")",TokSymbol "}"]
Just (EDo [LetStmt [(PVar "f",EOpSectionL "+" (EInt 1))],ExprStmt (EReturn (EApp (EVar "f") (EInt 10)))])

-- error1 --
-- Input: { = 1 }
Tokens: [TokSymbol "{",TokSymbol "=",TokNumber 1,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
<< exprCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
Nothing

-- error2 --
-- Input: { x = 1,, y = 2 }
Tokens: [TokSymbol "{",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ",",TokSymbol ",",TokIdent "y",TokSymbol "=",TokNumber 2,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol "{"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol "{"
<< atomBaseCore next token: TokSymbol "{"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol "{"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
Nothing

-- error3 --
-- Input: ()
Tokens: [TokSymbol "(",TokSymbol ")"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< exprCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "("
Nothing

-- error4 Ok --
-- Input: (1 + 2)
Tokens: [TokSymbol "(",TokNumber 1,TokOperator "+",TokNumber 2,TokSymbol ")"]
Just (EBinOp "+" (EInt 1) (EInt 2))

-- case guard1 --
-- Input: case x of { p | cond1 -> e1; p2 | cond2 -> e2; p3 -> e3 }
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokSymbol "{",TokIdent "p",TokSymbol "|",TokIdent "cond1",TokArrow,TokIdent "e1",TokSymbol ";",TokIdent "p2",TokSymbol "|",TokIdent "cond2",TokArrow,TokIdent "e2",TokSymbol ";",TokIdent "p3",TokArrow,TokIdent "e3",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< pattern1: (pAsPattern <|> makeCons)PVar "p"
<< exprCore next token: TokIdent "cond1"
<< atomBaseCore next token: TokIdent "cond1"
<< atomBaseCore next token: TokArrow
<< exprCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< pattern1: (pAsPattern <|> makeCons)PVar "p"
<< exprCore next token: TokIdent "cond1"
<< atomBaseCore next token: TokIdent "cond1"
<< atomBaseCore next token: TokArrow
<< exprCore next token: TokIdent "e1"
<< atomBaseCore next token: TokIdent "e1"
<< atomBaseCore next token: TokSymbol ";"
Nothing

-- case guard2 --
-- Input: case x of n | n < 0 -> 1 
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber 1]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- case guard3 --
-- Input: case x of n | n < 0 -> -1 | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- case guard4 --
-- Input: case x of n | n < 0 -> -1
  0 -> 0
  n | n > 0 -> 1
Tokens: [TokKeyword "case",TokIdent "x",TokKeyword "of",TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator "<",TokNumber 0,TokArrow,TokNumber (-1),TokNewline,TokNumber 0,TokArrow,TokNumber 0,TokNewline,TokIdent "n",TokSymbol "|",TokIdent "n",TokOperator ">",TokNumber 0,TokArrow,TokNumber 1]
XX Parser failed! Re-running with trace:
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
<< keyword: case
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokKeyword "of"
<< keyword: of
Nothing

-- list1 --
-- Input: [1, 2, 3]
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- list2 --
-- Input: [x * 2 | x <- xs]
Tokens: [TokSymbol "[",TokIdent "x",TokOperator "*",TokNumber 2,TokSymbol "|",TokIdent "x",TokSymbol "<-",TokIdent "xs",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokOperator "*"
<< atomBaseCore next token: TokNumber 2
<< int: 2
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokOperator "*"
<< atomBaseCore next token: TokNumber 2
<< int: 2
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list3 --
-- Input: [x | x <- xs, x > 0]
Tokens: [TokSymbol "[",TokIdent "x",TokSymbol "|",TokIdent "x",TokSymbol "<-",TokIdent "xs",TokSymbol ",",TokIdent "x",TokOperator ">",TokNumber 0,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list4 --
-- Input: [(x, y) | x <- xs, y <- ys]
Tokens: [TokSymbol "[",TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSymbol "|",TokIdent "x",TokSymbol "<-",TokIdent "xs",TokSymbol ",",TokIdent "y",TokSymbol "<-",TokIdent "ys",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "y"
<< atomBaseCore next token: TokIdent "y"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "("
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokIdent "y"
<< atomBaseCore next token: TokIdent "y"
<< atomBaseCore next token: TokSymbol ")"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list5 --
-- Input: [x | let y = f x, y > 0]
Tokens: [TokSymbol "[",TokIdent "x",TokSymbol "|",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokSymbol ",",TokIdent "y",TokOperator ">",TokNumber 0,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list6 --
-- Input: [x | Just x <- xs]
Tokens: [TokSymbol "[",TokIdent "x",TokSymbol "|",TokTypeIdent "Just",TokIdent "x",TokSymbol "<-",TokIdent "xs",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list7 --
-- Input: do { let xs = [x | x <- ys]; return xs }
Tokens: [TokKeyword "do",TokSymbol "{",TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokIdent "x",TokSymbol "|",TokIdent "x",TokSymbol "<-",TokIdent "ys",TokSymbol "]",TokSymbol ";",TokKeyword "return",TokIdent "xs",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- list8 --
-- Input: [x | let y = f x, y > 0]
Tokens: [TokSymbol "[",TokIdent "x",TokSymbol "|",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokSymbol ",",TokIdent "y",TokOperator ">",TokNumber 0,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokIdent "x"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol "|"
<< exprCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
<< atomBaseCore next token: TokSymbol "|"
Nothing

-- for1 --
-- Input: for x in xs -> x * 2
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokArrow,TokIdent "x",TokOperator "*",TokNumber 2]
Just (EListComp (EBinOp "*" (EVar "x") (EInt 2)) [QGenerator (PVar "x") (EVar "xs")])

-- for2 --
-- Input: for x in xs, y in ys -> (x, y)
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokIdent "y",TokKeyword "in",TokIdent "ys",TokArrow,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")"]
Just (EListComp (ETuple [EVar "x",EVar "y"]) [QGenerator (PVar "x") (EVar "xs"),QGenerator (PVar "y") (EVar "ys")])

-- for3 --
-- Input: for x in xs, y in ys, z in zs -> (x,y,z)
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokIdent "y",TokKeyword "in",TokIdent "ys",TokSymbol ",",TokIdent "z",TokKeyword "in",TokIdent "zs",TokArrow,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ",",TokIdent "z",TokSymbol ")"]
Just (EListComp (ETuple [EVar "x",EVar "y",EVar "z"]) [QGenerator (PVar "x") (EVar "xs"),QGenerator (PVar "y") (EVar "ys"),QGenerator (PVar "z") (EVar "zs")])

-- for3 --
-- Input: for x in xs, y in ys, z in zs -> ...
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokIdent "y",TokKeyword "in",TokIdent "ys",TokSymbol ",",TokIdent "z",TokKeyword "in",TokIdent "zs",TokArrow,TokEllipsis]
XX Parser failed! Re-running with trace:
<< keyword: for
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: in
<< exprCore next token: TokIdent "xs"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ","
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: in
<< exprCore next token: TokIdent "ys"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ","
<< pattern1: (pAsPattern <|> makeCons)PVar "z"
<< keyword: in
<< exprCore next token: TokIdent "zs"
<< atomBaseCore next token: TokIdent "zs"
<< atomBaseCore next token: TokArrow
<< exprCore next token: TokEllipsis
<< atomBaseCore next token: TokEllipsis
<< atomBaseCore next token: TokEllipsis
<< keyword: for
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< keyword: in
<< exprCore next token: TokIdent "xs"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ","
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< keyword: in
<< exprCore next token: TokIdent "ys"
<< atomBaseCore next token: TokIdent "ys"
<< atomBaseCore next token: TokSymbol ","
<< pattern1: (pAsPattern <|> makeCons)PVar "z"
<< keyword: in
<< exprCore next token: TokIdent "zs"
<< atomBaseCore next token: TokIdent "zs"
<< atomBaseCore next token: TokArrow
<< exprCore next token: TokEllipsis
<< atomBaseCore next token: TokEllipsis
<< atomBaseCore next token: TokEllipsis
Nothing

-- for4 --
-- Input: for x in xs, x > 0 -> x
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokIdent "x",TokOperator ">",TokNumber 0,TokArrow,TokIdent "x"]
Just (EListComp (EVar "x") [QGenerator (PVar "x") (EVar "xs"),QGuard (EBinOp ">" (EVar "x") (EInt 0))])

-- for5 --
-- Input: for x in xs, let y = f x -> y
Tokens: [TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokArrow,TokIdent "y"]
Just (EListComp (EVar "y") [QGenerator (PVar "x") (EVar "xs"),QGuard (ELet [(PVar "y",EApp (EVar "f") (EVar "x"))] (EVar "__unit__"))])

-- do1 --
-- Input: do {
  (x, y) <- f z;
  return x }
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokSymbol "(",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ")",TokSymbol "<-",TokIdent "f",TokIdent "z",TokSymbol ";",TokNewline,TokKeyword "return",TokIdent "x",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< pattern1: (pAsPattern <|> makeCons)PTuple [PVar "x",PVar "y"]
<< exprCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "z"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< keyword: do
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< pattern1: (pAsPattern <|> makeCons)PTuple [PVar "x",PVar "y"]
<< exprCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "z"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
Nothing

-- do2 --
-- Input: do {
      let y = f x;
      z <- g y;
      print z }
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokSymbol ";",TokNewline,TokIdent "z",TokSymbol "<-",TokIdent "g",TokIdent "y",TokSymbol ";",TokNewline,TokIdent "print",TokIdent "z",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< exprCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "y"
<< exprCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "f"
<< atomBaseCore next token: TokIdent "x"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
Nothing

-- do3 --
-- Input: do {
      x <- xs;
      if x > 0 then return x else fail }  
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokIdent "x",TokSymbol "<-",TokIdent "xs",TokSymbol ";",TokNewline,TokKeyword "if",TokIdent "x",TokOperator ">",TokNumber 0,TokKeyword "then",TokKeyword "return",TokIdent "x",TokKeyword "else",TokIdent "fail",TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokIdent "xs"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< keyword: do
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokIdent "xs"
<< atomBaseCore next token: TokIdent "xs"
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
Nothing

-- do2 --
-- Input: do {
  let xs = [1,2,3];
  for x in xs, x > 1 -> x
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokSymbol ";",TokNewline,TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokIdent "x",TokOperator ">",TokNumber 1,TokArrow,TokIdent "x",TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- do3 --
-- Input: do {
  let xs = [1,2,3];
  for x in xs, let y = f x -> y
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokSymbol ";",TokNewline,TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokArrow,TokIdent "y",TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- do4 --
-- Input: do {
  let xs = [1,2,3];
  for x in xs -> ...
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokSymbol ";",TokNewline,TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokArrow,TokEllipsis,TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- nested do --
-- Input: do {
  let x = 1;
  do {
    let y = x + 1;
    return y
  }
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "x",TokSymbol "=",TokNumber 1,TokSymbol ";",TokNewline,TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "x",TokOperator "+",TokNumber 1,TokSymbol ";",TokNewline,TokKeyword "return",TokIdent "y",TokNewline,TokSymbol "}",TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "x"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ";"
<< exprCore next token: TokNewline
<< atomBaseCore next token: TokNewline
<< atomBaseCore next token: TokNewline
Nothing

-- complex --
-- Input: do {
  let xs = [1,2,3];
  for x in xs, let y = f x, y > 1 -> y
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokSymbol ";",TokNewline,TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokSymbol ",",TokIdent "y",TokOperator ">",TokNumber 1,TokArrow,TokIdent "y",TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- complex2 --
-- Input: do {
  let xs = [1,2,3];
  for x in xs, let y = f x, y > 1 -> ...
}
Tokens: [TokKeyword "do",TokSymbol "{",TokNewline,TokKeyword "let",TokIdent "xs",TokSymbol "=",TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokSymbol ";",TokNewline,TokKeyword "for",TokIdent "x",TokKeyword "in",TokIdent "xs",TokSymbol ",",TokKeyword "let",TokIdent "y",TokSymbol "=",TokIdent "f",TokIdent "x",TokSymbol ",",TokIdent "y",TokOperator ">",TokNumber 1,TokArrow,TokEllipsis,TokNewline,TokSymbol "}"]
XX Parser failed! Re-running with trace:
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: do
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< keyword: let
<< pattern1: (pAsPattern <|> makeCons)PVar "xs"
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- list1 --
-- Input: [1 .. 10]
    [x .. y]
    [0 .. -5]
    [a .. b]
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol "..",TokNumber 10,TokSymbol "]",TokNewline,TokSymbol "[",TokIdent "x",TokSymbol "..",TokIdent "y",TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 0,TokSymbol "..",TokNumber (-5),TokSymbol "]",TokNewline,TokSymbol "[",TokIdent "a",TokSymbol "..",TokIdent "b",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
Nothing

-- list2 --
-- Input: [1, 3 .. 10]
[10, 8 .. 0]
[x, y .. z]
[0, 0 .. 0]
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 3,TokSymbol "..",TokNumber 10,TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 10,TokSymbol ",",TokNumber 8,TokSymbol "..",TokNumber 0,TokSymbol "]",TokNewline,TokSymbol "[",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol "..",TokIdent "z",TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 0,TokSymbol ",",TokNumber 0,TokSymbol "..",TokNumber 0,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- list3 --
-- Input: [1,2,3]
[x, y, z]
[1, 2, 3,]
[]
[   ]
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]",TokNewline,TokSymbol "[",TokIdent "x",TokSymbol ",",TokIdent "y",TokSymbol ",",TokIdent "z",TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol ",",TokSymbol "]",TokNewline,TokSymbol "[",TokSymbol "]",TokNewline,TokSymbol "[",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- list4 --
-- Input: [1, 2 .. 3]     -- rangeStep
[1 ,2 ..3]      -- whitespace variations
[1 .. 2, 3]     -- should be normal list? or error?（仕様確認
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol "..",TokNumber 3,TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 1,TokSymbol ",",TokNumber 2,TokSymbol "..",TokNumber 3,TokSymbol "]",TokNewline,TokSymbol "[",TokNumber 1,TokSymbol "..",TokNumber 2,TokSymbol ",",TokNumber 3,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ","
<< exprCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
<< atomBaseCore next token: TokSymbol ","
Nothing

-- list error1 --
-- Input: [1 ..]          -- エラーになるべき
Tokens: [TokSymbol "[",TokNumber 1,TokSymbol "..",TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokNumber 1
<< atomBaseCore next token: TokNumber 1
<< int: 1
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
Nothing

-- list error2 --
-- Input: [.. 10]         -- エラーになるべき
Tokens: [TokSymbol "[",TokSymbol "..",TokNumber 10,TokSymbol "]"]
XX Parser failed! Re-running with trace:
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< exprCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
<< atomBaseCore next token: TokSymbol ".."
Nothing
